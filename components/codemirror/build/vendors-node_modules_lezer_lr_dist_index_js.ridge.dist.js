"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(globalThis["webpackChunkridge_codemirror"] = globalThis["webpackChunkridge_codemirror"] || []).push([["vendors-node_modules_lezer_lr_dist_index_js"],{

/***/ "../../node_modules/@lezer/lr/dist/index.js":
/*!**************************************************!*\
  !*** ../../node_modules/@lezer/lr/dist/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ContextTracker: () => (/* binding */ ContextTracker),\n/* harmony export */   ExternalTokenizer: () => (/* binding */ ExternalTokenizer),\n/* harmony export */   InputStream: () => (/* binding */ InputStream),\n/* harmony export */   LRParser: () => (/* binding */ LRParser),\n/* harmony export */   LocalTokenGroup: () => (/* binding */ LocalTokenGroup),\n/* harmony export */   Stack: () => (/* binding */ Stack)\n/* harmony export */ });\n/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/common */ \"../../node_modules/@lezer/common/dist/index.js\");\n\n\n/**\nA parse stack. These are used internally by the parser to track\nparsing progress. They also provide some properties and methods\nthat external code such as a tokenizer can use to get information\nabout the parse state.\n*/\nclass Stack {\n  /**\n  @internal\n  */\n  constructor(\n  /**\n  The parse that this stack is part of @internal\n  */\n  p,\n  /**\n  Holds state, input pos, buffer index triplets for all but the\n  top state @internal\n  */\n  stack,\n  /**\n  The current parse state @internal\n  */\n  state,\n  // The position at which the next reduce should take place. This\n  // can be less than `this.pos` when skipped expressions have been\n  // added to the stack (which should be moved outside of the next\n  // reduction)\n  /**\n  @internal\n  */\n  reducePos,\n  /**\n  The input position up to which this stack has parsed.\n  */\n  pos,\n  /**\n  The dynamic score of the stack, including dynamic precedence\n  and error-recovery penalties\n  @internal\n  */\n  score,\n  // The output buffer. Holds (type, start, end, size) quads\n  // representing nodes created by the parser, where `size` is\n  // amount of buffer array entries covered by this node.\n  /**\n  @internal\n  */\n  buffer,\n  // The base offset of the buffer. When stacks are split, the split\n  // instance shared the buffer history with its parent up to\n  // `bufferBase`, which is the absolute offset (including the\n  // offset of previous splits) into the buffer at which this stack\n  // starts writing.\n  /**\n  @internal\n  */\n  bufferBase,\n  /**\n  @internal\n  */\n  curContext,\n  /**\n  @internal\n  */\n  lookAhead = 0,\n  // A parent stack from which this was split off, if any. This is\n  // set up so that it always points to a stack that has some\n  // additional buffer content, never to a stack with an equal\n  // `bufferBase`.\n  /**\n  @internal\n  */\n  parent) {\n    this.p = p;\n    this.stack = stack;\n    this.state = state;\n    this.reducePos = reducePos;\n    this.pos = pos;\n    this.score = score;\n    this.buffer = buffer;\n    this.bufferBase = bufferBase;\n    this.curContext = curContext;\n    this.lookAhead = lookAhead;\n    this.parent = parent;\n  }\n  /**\n  @internal\n  */\n  toString() {\n    return `[${this.stack.filter((_, i) => i % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? \"!\" + this.score : \"\"}`;\n  }\n  // Start an empty stack\n  /**\n  @internal\n  */\n  static start(p, state, pos = 0) {\n    let cx = p.parser.context;\n    return new Stack(p, [], state, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, 0, null);\n  }\n  /**\n  The stack's current [context](#lr.ContextTracker) value, if\n  any. Its type will depend on the context tracker's type\n  parameter, or it will be `null` if there is no context\n  tracker.\n  */\n  get context() {\n    return this.curContext ? this.curContext.context : null;\n  }\n  // Push a state onto the stack, tracking its start position as well\n  // as the buffer base at that point.\n  /**\n  @internal\n  */\n  pushState(state, start) {\n    this.stack.push(this.state, start, this.bufferBase + this.buffer.length);\n    this.state = state;\n  }\n  // Apply a reduce action\n  /**\n  @internal\n  */\n  reduce(action) {\n    var _a;\n    let depth = action >> 19 /* Action.ReduceDepthShift */,\n      type = action & 65535 /* Action.ValueMask */;\n    let {\n      parser\n    } = this.p;\n    if (this.reducePos < this.pos - 25 /* Lookahead.Margin */) this.setLookAhead(this.pos);\n    let dPrec = parser.dynamicPrecedence(type);\n    if (dPrec) this.score += dPrec;\n    if (depth == 0) {\n      this.pushState(parser.getGoto(this.state, type, true), this.reducePos);\n      // Zero-depth reductions are a special caseâ€”they add stuff to\n      // the stack without popping anything off.\n      if (type < parser.minRepeatTerm) this.storeNode(type, this.reducePos, this.reducePos, 4, true);\n      this.reduceContext(type, this.reducePos);\n      return;\n    }\n    // Find the base index into `this.stack`, content after which will\n    // be dropped. Note that with `StayFlag` reductions we need to\n    // consume two extra frames (the dummy parent node for the skipped\n    // expression and the state that we'll be staying in, which should\n    // be moved to `this.state`).\n    let base = this.stack.length - (depth - 1) * 3 - (action & 262144 /* Action.StayFlag */ ? 6 : 0);\n    let start = base ? this.stack[base - 2] : this.p.ranges[0].from,\n      size = this.reducePos - start;\n    // This is a kludge to try and detect overly deep left-associative\n    // trees, which will not increase the parse stack depth and thus\n    // won't be caught by the regular stack-depth limit check.\n    if (size >= 2000 /* Recover.MinBigReduction */ && !((_a = this.p.parser.nodeSet.types[type]) === null || _a === void 0 ? void 0 : _a.isAnonymous)) {\n      if (start == this.p.lastBigReductionStart) {\n        this.p.bigReductionCount++;\n        this.p.lastBigReductionSize = size;\n      } else if (this.p.lastBigReductionSize < size) {\n        this.p.bigReductionCount = 1;\n        this.p.lastBigReductionStart = start;\n        this.p.lastBigReductionSize = size;\n      }\n    }\n    let bufferBase = base ? this.stack[base - 1] : 0,\n      count = this.bufferBase + this.buffer.length - bufferBase;\n    // Store normal terms or `R -> R R` repeat reductions\n    if (type < parser.minRepeatTerm || action & 131072 /* Action.RepeatFlag */) {\n      let pos = parser.stateFlag(this.state, 1 /* StateFlag.Skipped */) ? this.pos : this.reducePos;\n      this.storeNode(type, start, pos, count + 4, true);\n    }\n    if (action & 262144 /* Action.StayFlag */) {\n      this.state = this.stack[base];\n    } else {\n      let baseStateID = this.stack[base - 3];\n      this.state = parser.getGoto(baseStateID, type, true);\n    }\n    while (this.stack.length > base) this.stack.pop();\n    this.reduceContext(type, start);\n  }\n  // Shift a value into the buffer\n  /**\n  @internal\n  */\n  storeNode(term, start, end, size = 4, isReduce = false) {\n    if (term == 0 /* Term.Err */ && (!this.stack.length || this.stack[this.stack.length - 1] < this.buffer.length + this.bufferBase)) {\n      // Try to omit/merge adjacent error nodes\n      let cur = this,\n        top = this.buffer.length;\n      if (top == 0 && cur.parent) {\n        top = cur.bufferBase - cur.parent.bufferBase;\n        cur = cur.parent;\n      }\n      if (top > 0 && cur.buffer[top - 4] == 0 /* Term.Err */ && cur.buffer[top - 1] > -1) {\n        if (start == end) return;\n        if (cur.buffer[top - 2] >= start) {\n          cur.buffer[top - 2] = end;\n          return;\n        }\n      }\n    }\n    if (!isReduce || this.pos == end) {\n      // Simple case, just append\n      this.buffer.push(term, start, end, size);\n    } else {\n      // There may be skipped nodes that have to be moved forward\n      let index = this.buffer.length;\n      if (index > 0 && this.buffer[index - 4] != 0 /* Term.Err */) while (index > 0 && this.buffer[index - 2] > end) {\n        // Move this record forward\n        this.buffer[index] = this.buffer[index - 4];\n        this.buffer[index + 1] = this.buffer[index - 3];\n        this.buffer[index + 2] = this.buffer[index - 2];\n        this.buffer[index + 3] = this.buffer[index - 1];\n        index -= 4;\n        if (size > 4) size -= 4;\n      }\n      this.buffer[index] = term;\n      this.buffer[index + 1] = start;\n      this.buffer[index + 2] = end;\n      this.buffer[index + 3] = size;\n    }\n  }\n  // Apply a shift action\n  /**\n  @internal\n  */\n  shift(action, type, start, end) {\n    if (action & 131072 /* Action.GotoFlag */) {\n      this.pushState(action & 65535 /* Action.ValueMask */, this.pos);\n    } else if ((action & 262144 /* Action.StayFlag */) == 0) {\n      // Regular shift\n      let nextState = action,\n        {\n          parser\n        } = this.p;\n      if (end > this.pos || type <= parser.maxNode) {\n        this.pos = end;\n        if (!parser.stateFlag(nextState, 1 /* StateFlag.Skipped */)) this.reducePos = end;\n      }\n      this.pushState(nextState, start);\n      this.shiftContext(type, start);\n      if (type <= parser.maxNode) this.buffer.push(type, start, end, 4);\n    } else {\n      // Shift-and-stay, which means this is a skipped token\n      this.pos = end;\n      this.shiftContext(type, start);\n      if (type <= this.p.parser.maxNode) this.buffer.push(type, start, end, 4);\n    }\n  }\n  // Apply an action\n  /**\n  @internal\n  */\n  apply(action, next, nextStart, nextEnd) {\n    if (action & 65536 /* Action.ReduceFlag */) this.reduce(action);else this.shift(action, next, nextStart, nextEnd);\n  }\n  // Add a prebuilt (reused) node into the buffer.\n  /**\n  @internal\n  */\n  useNode(value, next) {\n    let index = this.p.reused.length - 1;\n    if (index < 0 || this.p.reused[index] != value) {\n      this.p.reused.push(value);\n      index++;\n    }\n    let start = this.pos;\n    this.reducePos = this.pos = start + value.length;\n    this.pushState(next, start);\n    this.buffer.push(index, start, this.reducePos, -1 /* size == -1 means this is a reused value */);\n    if (this.curContext) this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this, this.p.stream.reset(this.pos - value.length)));\n  }\n  // Split the stack. Due to the buffer sharing and the fact\n  // that `this.stack` tends to stay quite shallow, this isn't very\n  // expensive.\n  /**\n  @internal\n  */\n  split() {\n    let parent = this;\n    let off = parent.buffer.length;\n    // Because the top of the buffer (after this.pos) may be mutated\n    // to reorder reductions and skipped tokens, and shared buffers\n    // should be immutable, this copies any outstanding skipped tokens\n    // to the new buffer, and puts the base pointer before them.\n    while (off > 0 && parent.buffer[off - 2] > parent.reducePos) off -= 4;\n    let buffer = parent.buffer.slice(off),\n      base = parent.bufferBase + off;\n    // Make sure parent points to an actual parent with content, if there is such a parent.\n    while (parent && base == parent.bufferBase) parent = parent.parent;\n    return new Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base, this.curContext, this.lookAhead, parent);\n  }\n  // Try to recover from an error by 'deleting' (ignoring) one token.\n  /**\n  @internal\n  */\n  recoverByDelete(next, nextEnd) {\n    let isNode = next <= this.p.parser.maxNode;\n    if (isNode) this.storeNode(next, this.pos, nextEnd, 4);\n    this.storeNode(0 /* Term.Err */, this.pos, nextEnd, isNode ? 8 : 4);\n    this.pos = this.reducePos = nextEnd;\n    this.score -= 190 /* Recover.Delete */;\n  }\n  /**\n  Check if the given term would be able to be shifted (optionally\n  after some reductions) on this stack. This can be useful for\n  external tokenizers that want to make sure they only provide a\n  given token when it applies.\n  */\n  canShift(term) {\n    for (let sim = new SimulatedStack(this);;) {\n      let action = this.p.parser.stateSlot(sim.state, 4 /* ParseState.DefaultReduce */) || this.p.parser.hasAction(sim.state, term);\n      if (action == 0) return false;\n      if ((action & 65536 /* Action.ReduceFlag */) == 0) return true;\n      sim.reduce(action);\n    }\n  }\n  // Apply up to Recover.MaxNext recovery actions that conceptually\n  // inserts some missing token or rule.\n  /**\n  @internal\n  */\n  recoverByInsert(next) {\n    if (this.stack.length >= 300 /* Recover.MaxInsertStackDepth */) return [];\n    let nextStates = this.p.parser.nextStates(this.state);\n    if (nextStates.length > 4 /* Recover.MaxNext */ << 1 || this.stack.length >= 120 /* Recover.DampenInsertStackDepth */) {\n      let best = [];\n      for (let i = 0, s; i < nextStates.length; i += 2) {\n        if ((s = nextStates[i + 1]) != this.state && this.p.parser.hasAction(s, next)) best.push(nextStates[i], s);\n      }\n      if (this.stack.length < 120 /* Recover.DampenInsertStackDepth */) for (let i = 0; best.length < 4 /* Recover.MaxNext */ << 1 && i < nextStates.length; i += 2) {\n        let s = nextStates[i + 1];\n        if (!best.some((v, i) => i & 1 && v == s)) best.push(nextStates[i], s);\n      }\n      nextStates = best;\n    }\n    let result = [];\n    for (let i = 0; i < nextStates.length && result.length < 4 /* Recover.MaxNext */; i += 2) {\n      let s = nextStates[i + 1];\n      if (s == this.state) continue;\n      let stack = this.split();\n      stack.pushState(s, this.pos);\n      stack.storeNode(0 /* Term.Err */, stack.pos, stack.pos, 4, true);\n      stack.shiftContext(nextStates[i], this.pos);\n      stack.reducePos = this.pos;\n      stack.score -= 200 /* Recover.Insert */;\n      result.push(stack);\n    }\n    return result;\n  }\n  // Force a reduce, if possible. Return false if that can't\n  // be done.\n  /**\n  @internal\n  */\n  forceReduce() {\n    let {\n      parser\n    } = this.p;\n    let reduce = parser.stateSlot(this.state, 5 /* ParseState.ForcedReduce */);\n    if ((reduce & 65536 /* Action.ReduceFlag */) == 0) return false;\n    if (!parser.validAction(this.state, reduce)) {\n      let depth = reduce >> 19 /* Action.ReduceDepthShift */,\n        term = reduce & 65535 /* Action.ValueMask */;\n      let target = this.stack.length - depth * 3;\n      if (target < 0 || parser.getGoto(this.stack[target], term, false) < 0) {\n        let backup = this.findForcedReduction();\n        if (backup == null) return false;\n        reduce = backup;\n      }\n      this.storeNode(0 /* Term.Err */, this.pos, this.pos, 4, true);\n      this.score -= 100 /* Recover.Reduce */;\n    }\n    this.reducePos = this.pos;\n    this.reduce(reduce);\n    return true;\n  }\n  /**\n  Try to scan through the automaton to find some kind of reduction\n  that can be applied. Used when the regular ForcedReduce field\n  isn't a valid action. @internal\n  */\n  findForcedReduction() {\n    let {\n        parser\n      } = this.p,\n      seen = [];\n    let explore = (state, depth) => {\n      if (seen.includes(state)) return;\n      seen.push(state);\n      return parser.allActions(state, action => {\n        if (action & (262144 /* Action.StayFlag */ | 131072 /* Action.GotoFlag */)) ;else if (action & 65536 /* Action.ReduceFlag */) {\n          let rDepth = (action >> 19 /* Action.ReduceDepthShift */) - depth;\n          if (rDepth > 1) {\n            let term = action & 65535 /* Action.ValueMask */,\n              target = this.stack.length - rDepth * 3;\n            if (target >= 0 && parser.getGoto(this.stack[target], term, false) >= 0) return rDepth << 19 /* Action.ReduceDepthShift */ | 65536 /* Action.ReduceFlag */ | term;\n          }\n        } else {\n          let found = explore(action, depth + 1);\n          if (found != null) return found;\n        }\n      });\n    };\n    return explore(this.state, 0);\n  }\n  /**\n  @internal\n  */\n  forceAll() {\n    while (!this.p.parser.stateFlag(this.state, 2 /* StateFlag.Accepting */)) {\n      if (!this.forceReduce()) {\n        this.storeNode(0 /* Term.Err */, this.pos, this.pos, 4, true);\n        break;\n      }\n    }\n    return this;\n  }\n  /**\n  Check whether this state has no further actions (assumed to be a direct descendant of the\n  top state, since any other states must be able to continue\n  somehow). @internal\n  */\n  get deadEnd() {\n    if (this.stack.length != 3) return false;\n    let {\n      parser\n    } = this.p;\n    return parser.data[parser.stateSlot(this.state, 1 /* ParseState.Actions */)] == 65535 /* Seq.End */ && !parser.stateSlot(this.state, 4 /* ParseState.DefaultReduce */);\n  }\n  /**\n  Restart the stack (put it back in its start state). Only safe\n  when this.stack.length == 3 (state is directly below the top\n  state). @internal\n  */\n  restart() {\n    this.storeNode(0 /* Term.Err */, this.pos, this.pos, 4, true);\n    this.state = this.stack[0];\n    this.stack.length = 0;\n  }\n  /**\n  @internal\n  */\n  sameState(other) {\n    if (this.state != other.state || this.stack.length != other.stack.length) return false;\n    for (let i = 0; i < this.stack.length; i += 3) if (this.stack[i] != other.stack[i]) return false;\n    return true;\n  }\n  /**\n  Get the parser used by this stack.\n  */\n  get parser() {\n    return this.p.parser;\n  }\n  /**\n  Test whether a given dialect (by numeric ID, as exported from\n  the terms file) is enabled.\n  */\n  dialectEnabled(dialectID) {\n    return this.p.parser.dialect.flags[dialectID];\n  }\n  shiftContext(term, start) {\n    if (this.curContext) this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this, this.p.stream.reset(start)));\n  }\n  reduceContext(term, start) {\n    if (this.curContext) this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this, this.p.stream.reset(start)));\n  }\n  /**\n  @internal\n  */\n  emitContext() {\n    let last = this.buffer.length - 1;\n    if (last < 0 || this.buffer[last] != -3) this.buffer.push(this.curContext.hash, this.pos, this.pos, -3);\n  }\n  /**\n  @internal\n  */\n  emitLookAhead() {\n    let last = this.buffer.length - 1;\n    if (last < 0 || this.buffer[last] != -4) this.buffer.push(this.lookAhead, this.pos, this.pos, -4);\n  }\n  updateContext(context) {\n    if (context != this.curContext.context) {\n      let newCx = new StackContext(this.curContext.tracker, context);\n      if (newCx.hash != this.curContext.hash) this.emitContext();\n      this.curContext = newCx;\n    }\n  }\n  /**\n  @internal\n  */\n  setLookAhead(lookAhead) {\n    if (lookAhead > this.lookAhead) {\n      this.emitLookAhead();\n      this.lookAhead = lookAhead;\n    }\n  }\n  /**\n  @internal\n  */\n  close() {\n    if (this.curContext && this.curContext.tracker.strict) this.emitContext();\n    if (this.lookAhead > 0) this.emitLookAhead();\n  }\n}\nclass StackContext {\n  constructor(tracker, context) {\n    this.tracker = tracker;\n    this.context = context;\n    this.hash = tracker.strict ? tracker.hash(context) : 0;\n  }\n}\n// Used to cheaply run some reductions to scan ahead without mutating\n// an entire stack\nclass SimulatedStack {\n  constructor(start) {\n    this.start = start;\n    this.state = start.state;\n    this.stack = start.stack;\n    this.base = this.stack.length;\n  }\n  reduce(action) {\n    let term = action & 65535 /* Action.ValueMask */,\n      depth = action >> 19 /* Action.ReduceDepthShift */;\n    if (depth == 0) {\n      if (this.stack == this.start.stack) this.stack = this.stack.slice();\n      this.stack.push(this.state, 0, 0);\n      this.base += 3;\n    } else {\n      this.base -= (depth - 1) * 3;\n    }\n    let goto = this.start.p.parser.getGoto(this.stack[this.base - 3], term, true);\n    this.state = goto;\n  }\n}\n// This is given to `Tree.build` to build a buffer, and encapsulates\n// the parent-stack-walking necessary to read the nodes.\nclass StackBufferCursor {\n  constructor(stack, pos, index) {\n    this.stack = stack;\n    this.pos = pos;\n    this.index = index;\n    this.buffer = stack.buffer;\n    if (this.index == 0) this.maybeNext();\n  }\n  static create(stack, pos = stack.bufferBase + stack.buffer.length) {\n    return new StackBufferCursor(stack, pos, pos - stack.bufferBase);\n  }\n  maybeNext() {\n    let next = this.stack.parent;\n    if (next != null) {\n      this.index = this.stack.bufferBase - next.bufferBase;\n      this.stack = next;\n      this.buffer = next.buffer;\n    }\n  }\n  get id() {\n    return this.buffer[this.index - 4];\n  }\n  get start() {\n    return this.buffer[this.index - 3];\n  }\n  get end() {\n    return this.buffer[this.index - 2];\n  }\n  get size() {\n    return this.buffer[this.index - 1];\n  }\n  next() {\n    this.index -= 4;\n    this.pos -= 4;\n    if (this.index == 0) this.maybeNext();\n  }\n  fork() {\n    return new StackBufferCursor(this.stack, this.pos, this.index);\n  }\n}\n\n// See lezer-generator/src/encode.ts for comments about the encoding\n// used here\nfunction decodeArray(input, Type = Uint16Array) {\n  if (typeof input != \"string\") return input;\n  let array = null;\n  for (let pos = 0, out = 0; pos < input.length;) {\n    let value = 0;\n    for (;;) {\n      let next = input.charCodeAt(pos++),\n        stop = false;\n      if (next == 126 /* Encode.BigValCode */) {\n        value = 65535 /* Encode.BigVal */;\n        break;\n      }\n      if (next >= 92 /* Encode.Gap2 */) next--;\n      if (next >= 34 /* Encode.Gap1 */) next--;\n      let digit = next - 32 /* Encode.Start */;\n      if (digit >= 46 /* Encode.Base */) {\n        digit -= 46 /* Encode.Base */;\n        stop = true;\n      }\n      value += digit;\n      if (stop) break;\n      value *= 46 /* Encode.Base */;\n    }\n    if (array) array[out++] = value;else array = new Type(value);\n  }\n  return array;\n}\nclass CachedToken {\n  constructor() {\n    this.start = -1;\n    this.value = -1;\n    this.end = -1;\n    this.extended = -1;\n    this.lookAhead = 0;\n    this.mask = 0;\n    this.context = 0;\n  }\n}\nconst nullToken = new CachedToken();\n/**\n[Tokenizers](#lr.ExternalTokenizer) interact with the input\nthrough this interface. It presents the input as a stream of\ncharacters, tracking lookahead and hiding the complexity of\n[ranges](#common.Parser.parse^ranges) from tokenizer code.\n*/\nclass InputStream {\n  /**\n  @internal\n  */\n  constructor(\n  /**\n  @internal\n  */\n  input,\n  /**\n  @internal\n  */\n  ranges) {\n    this.input = input;\n    this.ranges = ranges;\n    /**\n    @internal\n    */\n    this.chunk = \"\";\n    /**\n    @internal\n    */\n    this.chunkOff = 0;\n    /**\n    Backup chunk\n    */\n    this.chunk2 = \"\";\n    this.chunk2Pos = 0;\n    /**\n    The character code of the next code unit in the input, or -1\n    when the stream is at the end of the input.\n    */\n    this.next = -1;\n    /**\n    @internal\n    */\n    this.token = nullToken;\n    this.rangeIndex = 0;\n    this.pos = this.chunkPos = ranges[0].from;\n    this.range = ranges[0];\n    this.end = ranges[ranges.length - 1].to;\n    this.readNext();\n  }\n  /**\n  @internal\n  */\n  resolveOffset(offset, assoc) {\n    let range = this.range,\n      index = this.rangeIndex;\n    let pos = this.pos + offset;\n    while (pos < range.from) {\n      if (!index) return null;\n      let next = this.ranges[--index];\n      pos -= range.from - next.to;\n      range = next;\n    }\n    while (assoc < 0 ? pos > range.to : pos >= range.to) {\n      if (index == this.ranges.length - 1) return null;\n      let next = this.ranges[++index];\n      pos += next.from - range.to;\n      range = next;\n    }\n    return pos;\n  }\n  /**\n  @internal\n  */\n  clipPos(pos) {\n    if (pos >= this.range.from && pos < this.range.to) return pos;\n    for (let range of this.ranges) if (range.to > pos) return Math.max(pos, range.from);\n    return this.end;\n  }\n  /**\n  Look at a code unit near the stream position. `.peek(0)` equals\n  `.next`, `.peek(-1)` gives you the previous character, and so\n  on.\n  \n  Note that looking around during tokenizing creates dependencies\n  on potentially far-away content, which may reduce the\n  effectiveness incremental parsingâ€”when looking forwardâ€”or even\n  cause invalid reparses when looking backward more than 25 code\n  units, since the library does not track lookbehind.\n  */\n  peek(offset) {\n    let idx = this.chunkOff + offset,\n      pos,\n      result;\n    if (idx >= 0 && idx < this.chunk.length) {\n      pos = this.pos + offset;\n      result = this.chunk.charCodeAt(idx);\n    } else {\n      let resolved = this.resolveOffset(offset, 1);\n      if (resolved == null) return -1;\n      pos = resolved;\n      if (pos >= this.chunk2Pos && pos < this.chunk2Pos + this.chunk2.length) {\n        result = this.chunk2.charCodeAt(pos - this.chunk2Pos);\n      } else {\n        let i = this.rangeIndex,\n          range = this.range;\n        while (range.to <= pos) range = this.ranges[++i];\n        this.chunk2 = this.input.chunk(this.chunk2Pos = pos);\n        if (pos + this.chunk2.length > range.to) this.chunk2 = this.chunk2.slice(0, range.to - pos);\n        result = this.chunk2.charCodeAt(0);\n      }\n    }\n    if (pos >= this.token.lookAhead) this.token.lookAhead = pos + 1;\n    return result;\n  }\n  /**\n  Accept a token. By default, the end of the token is set to the\n  current stream position, but you can pass an offset (relative to\n  the stream position) to change that.\n  */\n  acceptToken(token, endOffset = 0) {\n    let end = endOffset ? this.resolveOffset(endOffset, -1) : this.pos;\n    if (end == null || end < this.token.start) throw new RangeError(\"Token end out of bounds\");\n    this.token.value = token;\n    this.token.end = end;\n  }\n  /**\n  Accept a token ending at a specific given position.\n  */\n  acceptTokenTo(token, endPos) {\n    this.token.value = token;\n    this.token.end = endPos;\n  }\n  getChunk() {\n    if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {\n      let {\n        chunk,\n        chunkPos\n      } = this;\n      this.chunk = this.chunk2;\n      this.chunkPos = this.chunk2Pos;\n      this.chunk2 = chunk;\n      this.chunk2Pos = chunkPos;\n      this.chunkOff = this.pos - this.chunkPos;\n    } else {\n      this.chunk2 = this.chunk;\n      this.chunk2Pos = this.chunkPos;\n      let nextChunk = this.input.chunk(this.pos);\n      let end = this.pos + nextChunk.length;\n      this.chunk = end > this.range.to ? nextChunk.slice(0, this.range.to - this.pos) : nextChunk;\n      this.chunkPos = this.pos;\n      this.chunkOff = 0;\n    }\n  }\n  readNext() {\n    if (this.chunkOff >= this.chunk.length) {\n      this.getChunk();\n      if (this.chunkOff == this.chunk.length) return this.next = -1;\n    }\n    return this.next = this.chunk.charCodeAt(this.chunkOff);\n  }\n  /**\n  Move the stream forward N (defaults to 1) code units. Returns\n  the new value of [`next`](#lr.InputStream.next).\n  */\n  advance(n = 1) {\n    this.chunkOff += n;\n    while (this.pos + n >= this.range.to) {\n      if (this.rangeIndex == this.ranges.length - 1) return this.setDone();\n      n -= this.range.to - this.pos;\n      this.range = this.ranges[++this.rangeIndex];\n      this.pos = this.range.from;\n    }\n    this.pos += n;\n    if (this.pos >= this.token.lookAhead) this.token.lookAhead = this.pos + 1;\n    return this.readNext();\n  }\n  setDone() {\n    this.pos = this.chunkPos = this.end;\n    this.range = this.ranges[this.rangeIndex = this.ranges.length - 1];\n    this.chunk = \"\";\n    return this.next = -1;\n  }\n  /**\n  @internal\n  */\n  reset(pos, token) {\n    if (token) {\n      this.token = token;\n      token.start = pos;\n      token.lookAhead = pos + 1;\n      token.value = token.extended = -1;\n    } else {\n      this.token = nullToken;\n    }\n    if (this.pos != pos) {\n      this.pos = pos;\n      if (pos == this.end) {\n        this.setDone();\n        return this;\n      }\n      while (pos < this.range.from) this.range = this.ranges[--this.rangeIndex];\n      while (pos >= this.range.to) this.range = this.ranges[++this.rangeIndex];\n      if (pos >= this.chunkPos && pos < this.chunkPos + this.chunk.length) {\n        this.chunkOff = pos - this.chunkPos;\n      } else {\n        this.chunk = \"\";\n        this.chunkOff = 0;\n      }\n      this.readNext();\n    }\n    return this;\n  }\n  /**\n  @internal\n  */\n  read(from, to) {\n    if (from >= this.chunkPos && to <= this.chunkPos + this.chunk.length) return this.chunk.slice(from - this.chunkPos, to - this.chunkPos);\n    if (from >= this.chunk2Pos && to <= this.chunk2Pos + this.chunk2.length) return this.chunk2.slice(from - this.chunk2Pos, to - this.chunk2Pos);\n    if (from >= this.range.from && to <= this.range.to) return this.input.read(from, to);\n    let result = \"\";\n    for (let r of this.ranges) {\n      if (r.from >= to) break;\n      if (r.to > from) result += this.input.read(Math.max(r.from, from), Math.min(r.to, to));\n    }\n    return result;\n  }\n}\n/**\n@internal\n*/\nclass TokenGroup {\n  constructor(data, id) {\n    this.data = data;\n    this.id = id;\n  }\n  token(input, stack) {\n    let {\n      parser\n    } = stack.p;\n    readToken(this.data, input, stack, this.id, parser.data, parser.tokenPrecTable);\n  }\n}\nTokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;\n/**\n@hide\n*/\nclass LocalTokenGroup {\n  constructor(data, precTable, elseToken) {\n    this.precTable = precTable;\n    this.elseToken = elseToken;\n    this.data = typeof data == \"string\" ? decodeArray(data) : data;\n  }\n  token(input, stack) {\n    let start = input.pos,\n      skipped = 0;\n    for (;;) {\n      let atEof = input.next < 0,\n        nextPos = input.resolveOffset(1, 1);\n      readToken(this.data, input, stack, 0, this.data, this.precTable);\n      if (input.token.value > -1) break;\n      if (this.elseToken == null) return;\n      if (!atEof) skipped++;\n      if (nextPos == null) break;\n      input.reset(nextPos, input.token);\n    }\n    if (skipped) {\n      input.reset(start, input.token);\n      input.acceptToken(this.elseToken, skipped);\n    }\n  }\n}\nLocalTokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;\n/**\n`@external tokens` declarations in the grammar should resolve to\nan instance of this class.\n*/\nclass ExternalTokenizer {\n  /**\n  Create a tokenizer. The first argument is the function that,\n  given an input stream, scans for the types of tokens it\n  recognizes at the stream's position, and calls\n  [`acceptToken`](#lr.InputStream.acceptToken) when it finds\n  one.\n  */\n  constructor(\n  /**\n  @internal\n  */\n  token, options = {}) {\n    this.token = token;\n    this.contextual = !!options.contextual;\n    this.fallback = !!options.fallback;\n    this.extend = !!options.extend;\n  }\n}\n// Tokenizer data is stored a big uint16 array containing, for each\n// state:\n//\n//  - A group bitmask, indicating what token groups are reachable from\n//    this state, so that paths that can only lead to tokens not in\n//    any of the current groups can be cut off early.\n//\n//  - The position of the end of the state's sequence of accepting\n//    tokens\n//\n//  - The number of outgoing edges for the state\n//\n//  - The accepting tokens, as (token id, group mask) pairs\n//\n//  - The outgoing edges, as (start character, end character, state\n//    index) triples, with end character being exclusive\n//\n// This function interprets that data, running through a stream as\n// long as new states with the a matching group mask can be reached,\n// and updating `input.token` when it matches a token.\nfunction readToken(data, input, stack, group, precTable, precOffset) {\n  let state = 0,\n    groupMask = 1 << group,\n    {\n      dialect\n    } = stack.p.parser;\n  scan: for (;;) {\n    if ((groupMask & data[state]) == 0) break;\n    let accEnd = data[state + 1];\n    // Check whether this state can lead to a token in the current group\n    // Accept tokens in this state, possibly overwriting\n    // lower-precedence / shorter tokens\n    for (let i = state + 3; i < accEnd; i += 2) if ((data[i + 1] & groupMask) > 0) {\n      let term = data[i];\n      if (dialect.allows(term) && (input.token.value == -1 || input.token.value == term || overrides(term, input.token.value, precTable, precOffset))) {\n        input.acceptToken(term);\n        break;\n      }\n    }\n    let next = input.next,\n      low = 0,\n      high = data[state + 2];\n    // Special case for EOF\n    if (input.next < 0 && high > low && data[accEnd + high * 3 - 3] == 65535 /* Seq.End */) {\n      state = data[accEnd + high * 3 - 1];\n      continue scan;\n    }\n    // Do a binary search on the state's edges\n    for (; low < high;) {\n      let mid = low + high >> 1;\n      let index = accEnd + mid + (mid << 1);\n      let from = data[index],\n        to = data[index + 1] || 0x10000;\n      if (next < from) high = mid;else if (next >= to) low = mid + 1;else {\n        state = data[index + 2];\n        input.advance();\n        continue scan;\n      }\n    }\n    break;\n  }\n}\nfunction findOffset(data, start, term) {\n  for (let i = start, next; (next = data[i]) != 65535 /* Seq.End */; i++) if (next == term) return i - start;\n  return -1;\n}\nfunction overrides(token, prev, tableData, tableOffset) {\n  let iPrev = findOffset(tableData, tableOffset, prev);\n  return iPrev < 0 || findOffset(tableData, tableOffset, token) < iPrev;\n}\n\n// Environment variable used to control console output\nconst verbose = typeof process != \"undefined\" && process.env && /\\bparse\\b/.test(process.env.LOG);\nlet stackIDs = null;\nfunction cutAt(tree, pos, side) {\n  let cursor = tree.cursor(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.IterMode.IncludeAnonymous);\n  cursor.moveTo(pos);\n  for (;;) {\n    if (!(side < 0 ? cursor.childBefore(pos) : cursor.childAfter(pos))) for (;;) {\n      if ((side < 0 ? cursor.to < pos : cursor.from > pos) && !cursor.type.isError) return side < 0 ? Math.max(0, Math.min(cursor.to - 1, pos - 25 /* Lookahead.Margin */)) : Math.min(tree.length, Math.max(cursor.from + 1, pos + 25 /* Lookahead.Margin */));\n      if (side < 0 ? cursor.prevSibling() : cursor.nextSibling()) break;\n      if (!cursor.parent()) return side < 0 ? 0 : tree.length;\n    }\n  }\n}\nclass FragmentCursor {\n  constructor(fragments, nodeSet) {\n    this.fragments = fragments;\n    this.nodeSet = nodeSet;\n    this.i = 0;\n    this.fragment = null;\n    this.safeFrom = -1;\n    this.safeTo = -1;\n    this.trees = [];\n    this.start = [];\n    this.index = [];\n    this.nextFragment();\n  }\n  nextFragment() {\n    let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];\n    if (fr) {\n      this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;\n      this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;\n      while (this.trees.length) {\n        this.trees.pop();\n        this.start.pop();\n        this.index.pop();\n      }\n      this.trees.push(fr.tree);\n      this.start.push(-fr.offset);\n      this.index.push(0);\n      this.nextStart = this.safeFrom;\n    } else {\n      this.nextStart = 1e9;\n    }\n  }\n  // `pos` must be >= any previously given `pos` for this cursor\n  nodeAt(pos) {\n    if (pos < this.nextStart) return null;\n    while (this.fragment && this.safeTo <= pos) this.nextFragment();\n    if (!this.fragment) return null;\n    for (;;) {\n      let last = this.trees.length - 1;\n      if (last < 0) {\n        // End of tree\n        this.nextFragment();\n        return null;\n      }\n      let top = this.trees[last],\n        index = this.index[last];\n      if (index == top.children.length) {\n        this.trees.pop();\n        this.start.pop();\n        this.index.pop();\n        continue;\n      }\n      let next = top.children[index];\n      let start = this.start[last] + top.positions[index];\n      if (start > pos) {\n        this.nextStart = start;\n        return null;\n      }\n      if (next instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree) {\n        if (start == pos) {\n          if (start < this.safeFrom) return null;\n          let end = start + next.length;\n          if (end <= this.safeTo) {\n            let lookAhead = next.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.lookAhead);\n            if (!lookAhead || end + lookAhead < this.fragment.to) return next;\n          }\n        }\n        this.index[last]++;\n        if (start + next.length >= Math.max(this.safeFrom, pos)) {\n          // Enter this node\n          this.trees.push(next);\n          this.start.push(start);\n          this.index.push(0);\n        }\n      } else {\n        this.index[last]++;\n        this.nextStart = start + next.length;\n      }\n    }\n  }\n}\nclass TokenCache {\n  constructor(parser, stream) {\n    this.stream = stream;\n    this.tokens = [];\n    this.mainToken = null;\n    this.actions = [];\n    this.tokens = parser.tokenizers.map(_ => new CachedToken());\n  }\n  getActions(stack) {\n    let actionIndex = 0;\n    let main = null;\n    let {\n        parser\n      } = stack.p,\n      {\n        tokenizers\n      } = parser;\n    let mask = parser.stateSlot(stack.state, 3 /* ParseState.TokenizerMask */);\n    let context = stack.curContext ? stack.curContext.hash : 0;\n    let lookAhead = 0;\n    for (let i = 0; i < tokenizers.length; i++) {\n      if ((1 << i & mask) == 0) continue;\n      let tokenizer = tokenizers[i],\n        token = this.tokens[i];\n      if (main && !tokenizer.fallback) continue;\n      if (tokenizer.contextual || token.start != stack.pos || token.mask != mask || token.context != context) {\n        this.updateCachedToken(token, tokenizer, stack);\n        token.mask = mask;\n        token.context = context;\n      }\n      if (token.lookAhead > token.end + 25 /* Lookahead.Margin */) lookAhead = Math.max(token.lookAhead, lookAhead);\n      if (token.value != 0 /* Term.Err */) {\n        let startIndex = actionIndex;\n        if (token.extended > -1) actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);\n        actionIndex = this.addActions(stack, token.value, token.end, actionIndex);\n        if (!tokenizer.extend) {\n          main = token;\n          if (actionIndex > startIndex) break;\n        }\n      }\n    }\n    while (this.actions.length > actionIndex) this.actions.pop();\n    if (lookAhead) stack.setLookAhead(lookAhead);\n    if (!main && stack.pos == this.stream.end) {\n      main = new CachedToken();\n      main.value = stack.p.parser.eofTerm;\n      main.start = main.end = stack.pos;\n      actionIndex = this.addActions(stack, main.value, main.end, actionIndex);\n    }\n    this.mainToken = main;\n    return this.actions;\n  }\n  getMainToken(stack) {\n    if (this.mainToken) return this.mainToken;\n    let main = new CachedToken(),\n      {\n        pos,\n        p\n      } = stack;\n    main.start = pos;\n    main.end = Math.min(pos + 1, p.stream.end);\n    main.value = pos == p.stream.end ? p.parser.eofTerm : 0 /* Term.Err */;\n    return main;\n  }\n  updateCachedToken(token, tokenizer, stack) {\n    let start = this.stream.clipPos(stack.pos);\n    tokenizer.token(this.stream.reset(start, token), stack);\n    if (token.value > -1) {\n      let {\n        parser\n      } = stack.p;\n      for (let i = 0; i < parser.specialized.length; i++) if (parser.specialized[i] == token.value) {\n        let result = parser.specializers[i](this.stream.read(token.start, token.end), stack);\n        if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {\n          if ((result & 1) == 0 /* Specialize.Specialize */) token.value = result >> 1;else token.extended = result >> 1;\n          break;\n        }\n      }\n    } else {\n      token.value = 0 /* Term.Err */;\n      token.end = this.stream.clipPos(start + 1);\n    }\n  }\n  putAction(action, token, end, index) {\n    // Don't add duplicate actions\n    for (let i = 0; i < index; i += 3) if (this.actions[i] == action) return index;\n    this.actions[index++] = action;\n    this.actions[index++] = token;\n    this.actions[index++] = end;\n    return index;\n  }\n  addActions(stack, token, end, index) {\n    let {\n        state\n      } = stack,\n      {\n        parser\n      } = stack.p,\n      {\n        data\n      } = parser;\n    for (let set = 0; set < 2; set++) {\n      for (let i = parser.stateSlot(state, set ? 2 /* ParseState.Skip */ : 1 /* ParseState.Actions */);; i += 3) {\n        if (data[i] == 65535 /* Seq.End */) {\n          if (data[i + 1] == 1 /* Seq.Next */) {\n            i = pair(data, i + 2);\n          } else {\n            if (index == 0 && data[i + 1] == 2 /* Seq.Other */) index = this.putAction(pair(data, i + 2), token, end, index);\n            break;\n          }\n        }\n        if (data[i] == token) index = this.putAction(pair(data, i + 1), token, end, index);\n      }\n    }\n    return index;\n  }\n}\nclass Parse {\n  constructor(parser, input, fragments, ranges) {\n    this.parser = parser;\n    this.input = input;\n    this.ranges = ranges;\n    this.recovering = 0;\n    this.nextStackID = 0x2654; // â™”, â™•, â™–, â™—, â™˜, â™™, â™ , â™¡, â™¢, â™£, â™¤, â™¥, â™¦, â™§\n    this.minStackPos = 0;\n    this.reused = [];\n    this.stoppedAt = null;\n    this.lastBigReductionStart = -1;\n    this.lastBigReductionSize = 0;\n    this.bigReductionCount = 0;\n    this.stream = new InputStream(input, ranges);\n    this.tokens = new TokenCache(parser, this.stream);\n    this.topTerm = parser.top[1];\n    let {\n      from\n    } = ranges[0];\n    this.stacks = [Stack.start(this, parser.top[0], from)];\n    this.fragments = fragments.length && this.stream.end - from > parser.bufferLength * 4 ? new FragmentCursor(fragments, parser.nodeSet) : null;\n  }\n  get parsedPos() {\n    return this.minStackPos;\n  }\n  // Move the parser forward. This will process all parse stacks at\n  // `this.pos` and try to advance them to a further position. If no\n  // stack for such a position is found, it'll start error-recovery.\n  //\n  // When the parse is finished, this will return a syntax tree. When\n  // not, it returns `null`.\n  advance() {\n    let stacks = this.stacks,\n      pos = this.minStackPos;\n    // This will hold stacks beyond `pos`.\n    let newStacks = this.stacks = [];\n    let stopped, stoppedTokens;\n    // If a large amount of reductions happened with the same start\n    // position, force the stack out of that production in order to\n    // avoid creating a tree too deep to recurse through.\n    // (This is an ugly kludge, because unfortunately there is no\n    // straightforward, cheap way to check for this happening, due to\n    // the history of reductions only being available in an\n    // expensive-to-access format in the stack buffers.)\n    if (this.bigReductionCount > 300 /* Rec.MaxLeftAssociativeReductionCount */ && stacks.length == 1) {\n      let [s] = stacks;\n      while (s.forceReduce() && s.stack.length && s.stack[s.stack.length - 2] >= this.lastBigReductionStart) {}\n      this.bigReductionCount = this.lastBigReductionSize = 0;\n    }\n    // Keep advancing any stacks at `pos` until they either move\n    // forward or can't be advanced. Gather stacks that can't be\n    // advanced further in `stopped`.\n    for (let i = 0; i < stacks.length; i++) {\n      let stack = stacks[i];\n      for (;;) {\n        this.tokens.mainToken = null;\n        if (stack.pos > pos) {\n          newStacks.push(stack);\n        } else if (this.advanceStack(stack, newStacks, stacks)) {\n          continue;\n        } else {\n          if (!stopped) {\n            stopped = [];\n            stoppedTokens = [];\n          }\n          stopped.push(stack);\n          let tok = this.tokens.getMainToken(stack);\n          stoppedTokens.push(tok.value, tok.end);\n        }\n        break;\n      }\n    }\n    if (!newStacks.length) {\n      let finished = stopped && findFinished(stopped);\n      if (finished) {\n        if (verbose) console.log(\"Finish with \" + this.stackID(finished));\n        return this.stackToTree(finished);\n      }\n      if (this.parser.strict) {\n        if (verbose && stopped) console.log(\"Stuck with token \" + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : \"none\"));\n        throw new SyntaxError(\"No parse at \" + pos);\n      }\n      if (!this.recovering) this.recovering = 5 /* Rec.Distance */;\n    }\n    if (this.recovering && stopped) {\n      let finished = this.stoppedAt != null && stopped[0].pos > this.stoppedAt ? stopped[0] : this.runRecovery(stopped, stoppedTokens, newStacks);\n      if (finished) {\n        if (verbose) console.log(\"Force-finish \" + this.stackID(finished));\n        return this.stackToTree(finished.forceAll());\n      }\n    }\n    if (this.recovering) {\n      let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3 /* Rec.MaxRemainingPerStep */;\n      if (newStacks.length > maxRemaining) {\n        newStacks.sort((a, b) => b.score - a.score);\n        while (newStacks.length > maxRemaining) newStacks.pop();\n      }\n      if (newStacks.some(s => s.reducePos > pos)) this.recovering--;\n    } else if (newStacks.length > 1) {\n      // Prune stacks that are in the same state, or that have been\n      // running without splitting for a while, to avoid getting stuck\n      // with multiple successful stacks running endlessly on.\n      outer: for (let i = 0; i < newStacks.length - 1; i++) {\n        let stack = newStacks[i];\n        for (let j = i + 1; j < newStacks.length; j++) {\n          let other = newStacks[j];\n          if (stack.sameState(other) || stack.buffer.length > 500 /* Rec.MinBufferLengthPrune */ && other.buffer.length > 500 /* Rec.MinBufferLengthPrune */) {\n            if ((stack.score - other.score || stack.buffer.length - other.buffer.length) > 0) {\n              newStacks.splice(j--, 1);\n            } else {\n              newStacks.splice(i--, 1);\n              continue outer;\n            }\n          }\n        }\n      }\n      if (newStacks.length > 12 /* Rec.MaxStackCount */) newStacks.splice(12 /* Rec.MaxStackCount */, newStacks.length - 12 /* Rec.MaxStackCount */);\n    }\n    this.minStackPos = newStacks[0].pos;\n    for (let i = 1; i < newStacks.length; i++) if (newStacks[i].pos < this.minStackPos) this.minStackPos = newStacks[i].pos;\n    return null;\n  }\n  stopAt(pos) {\n    if (this.stoppedAt != null && this.stoppedAt < pos) throw new RangeError(\"Can't move stoppedAt forward\");\n    this.stoppedAt = pos;\n  }\n  // Returns an updated version of the given stack, or null if the\n  // stack can't advance normally. When `split` and `stacks` are\n  // given, stacks split off by ambiguous operations will be pushed to\n  // `split`, or added to `stacks` if they move `pos` forward.\n  advanceStack(stack, stacks, split) {\n    let start = stack.pos,\n      {\n        parser\n      } = this;\n    let base = verbose ? this.stackID(stack) + \" -> \" : \"\";\n    if (this.stoppedAt != null && start > this.stoppedAt) return stack.forceReduce() ? stack : null;\n    if (this.fragments) {\n      let strictCx = stack.curContext && stack.curContext.tracker.strict,\n        cxHash = strictCx ? stack.curContext.hash : 0;\n      for (let cached = this.fragments.nodeAt(start); cached;) {\n        let match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser.getGoto(stack.state, cached.type.id) : -1;\n        if (match > -1 && cached.length && (!strictCx || (cached.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.contextHash) || 0) == cxHash)) {\n          stack.useNode(cached, match);\n          if (verbose) console.log(base + this.stackID(stack) + ` (via reuse of ${parser.getName(cached.type.id)})`);\n          return true;\n        }\n        if (!(cached instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree) || cached.children.length == 0 || cached.positions[0] > 0) break;\n        let inner = cached.children[0];\n        if (inner instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree && cached.positions[0] == 0) cached = inner;else break;\n      }\n    }\n    let defaultReduce = parser.stateSlot(stack.state, 4 /* ParseState.DefaultReduce */);\n    if (defaultReduce > 0) {\n      stack.reduce(defaultReduce);\n      if (verbose) console.log(base + this.stackID(stack) + ` (via always-reduce ${parser.getName(defaultReduce & 65535 /* Action.ValueMask */)})`);\n      return true;\n    }\n    if (stack.stack.length >= 8400 /* Rec.CutDepth */) {\n      while (stack.stack.length > 6000 /* Rec.CutTo */ && stack.forceReduce()) {}\n    }\n    let actions = this.tokens.getActions(stack);\n    for (let i = 0; i < actions.length;) {\n      let action = actions[i++],\n        term = actions[i++],\n        end = actions[i++];\n      let last = i == actions.length || !split;\n      let localStack = last ? stack : stack.split();\n      let main = this.tokens.mainToken;\n      localStack.apply(action, term, main ? main.start : localStack.pos, end);\n      if (verbose) console.log(base + this.stackID(localStack) + ` (via ${(action & 65536 /* Action.ReduceFlag */) == 0 ? \"shift\" : `reduce of ${parser.getName(action & 65535 /* Action.ValueMask */)}`} for ${parser.getName(term)} @ ${start}${localStack == stack ? \"\" : \", split\"})`);\n      if (last) return true;else if (localStack.pos > start) stacks.push(localStack);else split.push(localStack);\n    }\n    return false;\n  }\n  // Advance a given stack forward as far as it will go. Returns the\n  // (possibly updated) stack if it got stuck, or null if it moved\n  // forward and was given to `pushStackDedup`.\n  advanceFully(stack, newStacks) {\n    let pos = stack.pos;\n    for (;;) {\n      if (!this.advanceStack(stack, null, null)) return false;\n      if (stack.pos > pos) {\n        pushStackDedup(stack, newStacks);\n        return true;\n      }\n    }\n  }\n  runRecovery(stacks, tokens, newStacks) {\n    let finished = null,\n      restarted = false;\n    for (let i = 0; i < stacks.length; i++) {\n      let stack = stacks[i],\n        token = tokens[i << 1],\n        tokenEnd = tokens[(i << 1) + 1];\n      let base = verbose ? this.stackID(stack) + \" -> \" : \"\";\n      if (stack.deadEnd) {\n        if (restarted) continue;\n        restarted = true;\n        stack.restart();\n        if (verbose) console.log(base + this.stackID(stack) + \" (restarted)\");\n        let done = this.advanceFully(stack, newStacks);\n        if (done) continue;\n      }\n      let force = stack.split(),\n        forceBase = base;\n      for (let j = 0; force.forceReduce() && j < 10 /* Rec.ForceReduceLimit */; j++) {\n        if (verbose) console.log(forceBase + this.stackID(force) + \" (via force-reduce)\");\n        let done = this.advanceFully(force, newStacks);\n        if (done) break;\n        if (verbose) forceBase = this.stackID(force) + \" -> \";\n      }\n      for (let insert of stack.recoverByInsert(token)) {\n        if (verbose) console.log(base + this.stackID(insert) + \" (via recover-insert)\");\n        this.advanceFully(insert, newStacks);\n      }\n      if (this.stream.end > stack.pos) {\n        if (tokenEnd == stack.pos) {\n          tokenEnd++;\n          token = 0 /* Term.Err */;\n        }\n        stack.recoverByDelete(token, tokenEnd);\n        if (verbose) console.log(base + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`);\n        pushStackDedup(stack, newStacks);\n      } else if (!finished || finished.score < stack.score) {\n        finished = stack;\n      }\n    }\n    return finished;\n  }\n  // Convert the stack's buffer to a syntax tree.\n  stackToTree(stack) {\n    stack.close();\n    return _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.build({\n      buffer: StackBufferCursor.create(stack),\n      nodeSet: this.parser.nodeSet,\n      topID: this.topTerm,\n      maxBufferLength: this.parser.bufferLength,\n      reused: this.reused,\n      start: this.ranges[0].from,\n      length: stack.pos - this.ranges[0].from,\n      minRepeatType: this.parser.minRepeatTerm\n    });\n  }\n  stackID(stack) {\n    let id = (stackIDs || (stackIDs = new WeakMap())).get(stack);\n    if (!id) stackIDs.set(stack, id = String.fromCodePoint(this.nextStackID++));\n    return id + stack;\n  }\n}\nfunction pushStackDedup(stack, newStacks) {\n  for (let i = 0; i < newStacks.length; i++) {\n    let other = newStacks[i];\n    if (other.pos == stack.pos && other.sameState(stack)) {\n      if (newStacks[i].score < stack.score) newStacks[i] = stack;\n      return;\n    }\n  }\n  newStacks.push(stack);\n}\nclass Dialect {\n  constructor(source, flags, disabled) {\n    this.source = source;\n    this.flags = flags;\n    this.disabled = disabled;\n  }\n  allows(term) {\n    return !this.disabled || this.disabled[term] == 0;\n  }\n}\nconst id = x => x;\n/**\nContext trackers are used to track stateful context (such as\nindentation in the Python grammar, or parent elements in the XML\ngrammar) needed by external tokenizers. You declare them in a\ngrammar file as `@context exportName from \"module\"`.\n\nContext values should be immutable, and can be updated (replaced)\non shift or reduce actions.\n\nThe export used in a `@context` declaration should be of this\ntype.\n*/\nclass ContextTracker {\n  /**\n  Define a context tracker.\n  */\n  constructor(spec) {\n    this.start = spec.start;\n    this.shift = spec.shift || id;\n    this.reduce = spec.reduce || id;\n    this.reuse = spec.reuse || id;\n    this.hash = spec.hash || (() => 0);\n    this.strict = spec.strict !== false;\n  }\n}\n/**\nHolds the parse tables for a given grammar, as generated by\n`lezer-generator`, and provides [methods](#common.Parser) to parse\ncontent with.\n*/\nclass LRParser extends _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Parser {\n  /**\n  @internal\n  */\n  constructor(spec) {\n    super();\n    /**\n    @internal\n    */\n    this.wrappers = [];\n    if (spec.version != 14 /* File.Version */) throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${14 /* File.Version */})`);\n    let nodeNames = spec.nodeNames.split(\" \");\n    this.minRepeatTerm = nodeNames.length;\n    for (let i = 0; i < spec.repeatNodeCount; i++) nodeNames.push(\"\");\n    let topTerms = Object.keys(spec.topRules).map(r => spec.topRules[r][1]);\n    let nodeProps = [];\n    for (let i = 0; i < nodeNames.length; i++) nodeProps.push([]);\n    function setProp(nodeID, prop, value) {\n      nodeProps[nodeID].push([prop, prop.deserialize(String(value))]);\n    }\n    if (spec.nodeProps) for (let propSpec of spec.nodeProps) {\n      let prop = propSpec[0];\n      if (typeof prop == \"string\") prop = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp[prop];\n      for (let i = 1; i < propSpec.length;) {\n        let next = propSpec[i++];\n        if (next >= 0) {\n          setProp(next, prop, propSpec[i++]);\n        } else {\n          let value = propSpec[i + -next];\n          for (let j = -next; j > 0; j--) setProp(propSpec[i++], prop, value);\n          i++;\n        }\n      }\n    }\n    this.nodeSet = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeSet(nodeNames.map((name, i) => _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.define({\n      name: i >= this.minRepeatTerm ? undefined : name,\n      id: i,\n      props: nodeProps[i],\n      top: topTerms.indexOf(i) > -1,\n      error: i == 0,\n      skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i) > -1\n    })));\n    if (spec.propSources) this.nodeSet = this.nodeSet.extend(...spec.propSources);\n    this.strict = false;\n    this.bufferLength = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.DefaultBufferLength;\n    let tokenArray = decodeArray(spec.tokenData);\n    this.context = spec.context;\n    this.specializerSpecs = spec.specialized || [];\n    this.specialized = new Uint16Array(this.specializerSpecs.length);\n    for (let i = 0; i < this.specializerSpecs.length; i++) this.specialized[i] = this.specializerSpecs[i].term;\n    this.specializers = this.specializerSpecs.map(getSpecializer);\n    this.states = decodeArray(spec.states, Uint32Array);\n    this.data = decodeArray(spec.stateData);\n    this.goto = decodeArray(spec.goto);\n    this.maxTerm = spec.maxTerm;\n    this.tokenizers = spec.tokenizers.map(value => typeof value == \"number\" ? new TokenGroup(tokenArray, value) : value);\n    this.topRules = spec.topRules;\n    this.dialects = spec.dialects || {};\n    this.dynamicPrecedences = spec.dynamicPrecedences || null;\n    this.tokenPrecTable = spec.tokenPrec;\n    this.termNames = spec.termNames || null;\n    this.maxNode = this.nodeSet.types.length - 1;\n    this.dialect = this.parseDialect();\n    this.top = this.topRules[Object.keys(this.topRules)[0]];\n  }\n  createParse(input, fragments, ranges) {\n    let parse = new Parse(this, input, fragments, ranges);\n    for (let w of this.wrappers) parse = w(parse, input, fragments, ranges);\n    return parse;\n  }\n  /**\n  Get a goto table entry @internal\n  */\n  getGoto(state, term, loose = false) {\n    let table = this.goto;\n    if (term >= table[0]) return -1;\n    for (let pos = table[term + 1];;) {\n      let groupTag = table[pos++],\n        last = groupTag & 1;\n      let target = table[pos++];\n      if (last && loose) return target;\n      for (let end = pos + (groupTag >> 1); pos < end; pos++) if (table[pos] == state) return target;\n      if (last) return -1;\n    }\n  }\n  /**\n  Check if this state has an action for a given terminal @internal\n  */\n  hasAction(state, terminal) {\n    let data = this.data;\n    for (let set = 0; set < 2; set++) {\n      for (let i = this.stateSlot(state, set ? 2 /* ParseState.Skip */ : 1 /* ParseState.Actions */), next;; i += 3) {\n        if ((next = data[i]) == 65535 /* Seq.End */) {\n          if (data[i + 1] == 1 /* Seq.Next */) next = data[i = pair(data, i + 2)];else if (data[i + 1] == 2 /* Seq.Other */) return pair(data, i + 2);else break;\n        }\n        if (next == terminal || next == 0 /* Term.Err */) return pair(data, i + 1);\n      }\n    }\n    return 0;\n  }\n  /**\n  @internal\n  */\n  stateSlot(state, slot) {\n    return this.states[state * 6 /* ParseState.Size */ + slot];\n  }\n  /**\n  @internal\n  */\n  stateFlag(state, flag) {\n    return (this.stateSlot(state, 0 /* ParseState.Flags */) & flag) > 0;\n  }\n  /**\n  @internal\n  */\n  validAction(state, action) {\n    return !!this.allActions(state, a => a == action ? true : null);\n  }\n  /**\n  @internal\n  */\n  allActions(state, action) {\n    let deflt = this.stateSlot(state, 4 /* ParseState.DefaultReduce */);\n    let result = deflt ? action(deflt) : undefined;\n    for (let i = this.stateSlot(state, 1 /* ParseState.Actions */); result == null; i += 3) {\n      if (this.data[i] == 65535 /* Seq.End */) {\n        if (this.data[i + 1] == 1 /* Seq.Next */) i = pair(this.data, i + 2);else break;\n      }\n      result = action(pair(this.data, i + 1));\n    }\n    return result;\n  }\n  /**\n  Get the states that can follow this one through shift actions or\n  goto jumps. @internal\n  */\n  nextStates(state) {\n    let result = [];\n    for (let i = this.stateSlot(state, 1 /* ParseState.Actions */);; i += 3) {\n      if (this.data[i] == 65535 /* Seq.End */) {\n        if (this.data[i + 1] == 1 /* Seq.Next */) i = pair(this.data, i + 2);else break;\n      }\n      if ((this.data[i + 2] & 65536 /* Action.ReduceFlag */ >> 16) == 0) {\n        let value = this.data[i + 1];\n        if (!result.some((v, i) => i & 1 && v == value)) result.push(this.data[i], value);\n      }\n    }\n    return result;\n  }\n  /**\n  Configure the parser. Returns a new parser instance that has the\n  given settings modified. Settings not provided in `config` are\n  kept from the original parser.\n  */\n  configure(config) {\n    // Hideous reflection-based kludge to make it easy to create a\n    // slightly modified copy of a parser.\n    let copy = Object.assign(Object.create(LRParser.prototype), this);\n    if (config.props) copy.nodeSet = this.nodeSet.extend(...config.props);\n    if (config.top) {\n      let info = this.topRules[config.top];\n      if (!info) throw new RangeError(`Invalid top rule name ${config.top}`);\n      copy.top = info;\n    }\n    if (config.tokenizers) copy.tokenizers = this.tokenizers.map(t => {\n      let found = config.tokenizers.find(r => r.from == t);\n      return found ? found.to : t;\n    });\n    if (config.specializers) {\n      copy.specializers = this.specializers.slice();\n      copy.specializerSpecs = this.specializerSpecs.map((s, i) => {\n        let found = config.specializers.find(r => r.from == s.external);\n        if (!found) return s;\n        let spec = Object.assign(Object.assign({}, s), {\n          external: found.to\n        });\n        copy.specializers[i] = getSpecializer(spec);\n        return spec;\n      });\n    }\n    if (config.contextTracker) copy.context = config.contextTracker;\n    if (config.dialect) copy.dialect = this.parseDialect(config.dialect);\n    if (config.strict != null) copy.strict = config.strict;\n    if (config.wrap) copy.wrappers = copy.wrappers.concat(config.wrap);\n    if (config.bufferLength != null) copy.bufferLength = config.bufferLength;\n    return copy;\n  }\n  /**\n  Tells you whether any [parse wrappers](#lr.ParserConfig.wrap)\n  are registered for this parser.\n  */\n  hasWrappers() {\n    return this.wrappers.length > 0;\n  }\n  /**\n  Returns the name associated with a given term. This will only\n  work for all terms when the parser was generated with the\n  `--names` option. By default, only the names of tagged terms are\n  stored.\n  */\n  getName(term) {\n    return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);\n  }\n  /**\n  The eof term id is always allocated directly after the node\n  types. @internal\n  */\n  get eofTerm() {\n    return this.maxNode + 1;\n  }\n  /**\n  The type of top node produced by the parser.\n  */\n  get topNode() {\n    return this.nodeSet.types[this.top[1]];\n  }\n  /**\n  @internal\n  */\n  dynamicPrecedence(term) {\n    let prec = this.dynamicPrecedences;\n    return prec == null ? 0 : prec[term] || 0;\n  }\n  /**\n  @internal\n  */\n  parseDialect(dialect) {\n    let values = Object.keys(this.dialects),\n      flags = values.map(() => false);\n    if (dialect) for (let part of dialect.split(\" \")) {\n      let id = values.indexOf(part);\n      if (id >= 0) flags[id] = true;\n    }\n    let disabled = null;\n    for (let i = 0; i < values.length; i++) if (!flags[i]) {\n      for (let j = this.dialects[values[i]], id; (id = this.data[j++]) != 65535 /* Seq.End */;) (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id] = 1;\n    }\n    return new Dialect(dialect, flags, disabled);\n  }\n  /**\n  Used by the output of the parser generator. Not available to\n  user code. @hide\n  */\n  static deserialize(spec) {\n    return new LRParser(spec);\n  }\n}\nfunction pair(data, off) {\n  return data[off] | data[off + 1] << 16;\n}\nfunction findFinished(stacks) {\n  let best = null;\n  for (let stack of stacks) {\n    let stopped = stack.p.stoppedAt;\n    if ((stack.pos == stack.p.stream.end || stopped != null && stack.pos > stopped) && stack.p.parser.stateFlag(stack.state, 2 /* StateFlag.Accepting */) && (!best || best.score < stack.score)) best = stack;\n  }\n  return best;\n}\nfunction getSpecializer(spec) {\n  if (spec.external) {\n    let mask = spec.extend ? 1 /* Specialize.Extend */ : 0 /* Specialize.Specialize */;\n    return (value, stack) => spec.external(value, stack) << 1 | mask;\n  }\n  return spec.get;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BsZXplci9sci9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBeUc7O0FBRXpHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU1PLEtBQUssQ0FBQztFQUNSO0FBQ0o7QUFDQTtFQUNJQyxXQUFXQTtFQUNYO0FBQ0o7QUFDQTtFQUNJQyxDQUFDO0VBQ0Q7QUFDSjtBQUNBO0FBQ0E7RUFDSUMsS0FBSztFQUNMO0FBQ0o7QUFDQTtFQUNJQyxLQUFLO0VBQ0w7RUFDQTtFQUNBO0VBQ0E7RUFDQTtBQUNKO0FBQ0E7RUFDSUMsU0FBUztFQUNUO0FBQ0o7QUFDQTtFQUNJQyxHQUFHO0VBQ0g7QUFDSjtBQUNBO0FBQ0E7QUFDQTtFQUNJQyxLQUFLO0VBQ0w7RUFDQTtFQUNBO0VBQ0E7QUFDSjtBQUNBO0VBQ0lDLE1BQU07RUFDTjtFQUNBO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDSjtBQUNBO0VBQ0lDLFVBQVU7RUFDVjtBQUNKO0FBQ0E7RUFDSUMsVUFBVTtFQUNWO0FBQ0o7QUFDQTtFQUNJQyxTQUFTLEdBQUcsQ0FBQztFQUNiO0VBQ0E7RUFDQTtFQUNBO0VBQ0E7QUFDSjtBQUNBO0VBQ0lDLE1BQU0sRUFBRTtJQUNKLElBQUksQ0FBQ1YsQ0FBQyxHQUFHQSxDQUFDO0lBQ1YsSUFBSSxDQUFDQyxLQUFLLEdBQUdBLEtBQUs7SUFDbEIsSUFBSSxDQUFDQyxLQUFLLEdBQUdBLEtBQUs7SUFDbEIsSUFBSSxDQUFDQyxTQUFTLEdBQUdBLFNBQVM7SUFDMUIsSUFBSSxDQUFDQyxHQUFHLEdBQUdBLEdBQUc7SUFDZCxJQUFJLENBQUNDLEtBQUssR0FBR0EsS0FBSztJQUNsQixJQUFJLENBQUNDLE1BQU0sR0FBR0EsTUFBTTtJQUNwQixJQUFJLENBQUNDLFVBQVUsR0FBR0EsVUFBVTtJQUM1QixJQUFJLENBQUNDLFVBQVUsR0FBR0EsVUFBVTtJQUM1QixJQUFJLENBQUNDLFNBQVMsR0FBR0EsU0FBUztJQUMx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QUssSUFBSW5GLEtBQUssSUFBSStQLE1BQU0sRUFBRTtJQUN0QixJQUFJSSxPQUFPLEdBQUduUSxLQUFLLENBQUNELENBQUMsQ0FBQzhQLFNBQVM7SUFDL0IsSUFBSSxDQUFDN1AsS0FBSyxDQUFDRyxHQUFHLElBQUlILEtBQUssQ0FBQ0QsQ0FBQyxDQUFDc0UsTUFBTSxDQUFDbkIsR0FBRyxJQUFJaU4sT0FBTyxJQUFJLElBQUksSUFBSW5RLEtBQUssQ0FBQ0csR0FBRyxHQUFHZ1EsT0FBTyxLQUMxRW5RLEtBQUssQ0FBQ0QsQ0FBQyxDQUFDa0IsTUFBTSxDQUFDNkIsU0FBUyxDQUFDOUMsS0FBSyxDQUFDQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLHlCQUF5QixDQUFDLEtBQ2pFLENBQUNrRixJQUFJLElBQUlBLElBQUksQ0FBQy9FLEtBQUssR0FBR0osS0FBSyxDQUFDSSxLQUFLLENBQUMsRUFDbkMrRSxJQUFJLEdBQUduRixLQUFLO0VBQ3BCO0VBQ0EsT0FBT21GLElBQUk7QUFDZjtBQUNBLFNBQVM0UCxjQUFjQSxDQUFDMUIsSUFBSSxFQUFFO0VBQzFCLElBQUlBLElBQUksQ0FBQ3FELFFBQVEsRUFBRTtJQUNmLElBQUlyTyxJQUFJLEdBQUdnTCxJQUFJLENBQUN2SSxNQUFNLEdBQUcsQ0FBQyxDQUFDLDBCQUEwQixDQUFDLENBQUM7SUFDdkQsT0FBTyxDQUFDOUcsS0FBSyxFQUFFaEUsS0FBSyxLQUFNcVQsSUFBSSxDQUFDcUQsUUFBUSxDQUFDMVMsS0FBSyxFQUFFaEUsS0FBSyxDQUFDLElBQUksQ0FBQyxHQUFJcUksSUFBSTtFQUN0RTtFQUNBLE9BQU9nTCxJQUFJLENBQUNSLEdBQUc7QUFDbkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yaWRnZS1jb2RlbWlycm9yLy4uLy4uL25vZGVfbW9kdWxlcy9AbGV6ZXIvbHIvZGlzdC9pbmRleC5qcz85MDY3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBhcnNlciwgTm9kZVByb3AsIE5vZGVTZXQsIE5vZGVUeXBlLCBEZWZhdWx0QnVmZmVyTGVuZ3RoLCBUcmVlLCBJdGVyTW9kZSB9IGZyb20gJ0BsZXplci9jb21tb24nO1xuXG4vKipcbkEgcGFyc2Ugc3RhY2suIFRoZXNlIGFyZSB1c2VkIGludGVybmFsbHkgYnkgdGhlIHBhcnNlciB0byB0cmFja1xucGFyc2luZyBwcm9ncmVzcy4gVGhleSBhbHNvIHByb3ZpZGUgc29tZSBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzXG50aGF0IGV4dGVybmFsIGNvZGUgc3VjaCBhcyBhIHRva2VuaXplciBjYW4gdXNlIHRvIGdldCBpbmZvcm1hdGlvblxuYWJvdXQgdGhlIHBhcnNlIHN0YXRlLlxuKi9cbmNsYXNzIFN0YWNrIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBwYXJzZSB0aGF0IHRoaXMgc3RhY2sgaXMgcGFydCBvZiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHAsIFxuICAgIC8qKlxuICAgIEhvbGRzIHN0YXRlLCBpbnB1dCBwb3MsIGJ1ZmZlciBpbmRleCB0cmlwbGV0cyBmb3IgYWxsIGJ1dCB0aGVcbiAgICB0b3Agc3RhdGUgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGFjaywgXG4gICAgLyoqXG4gICAgVGhlIGN1cnJlbnQgcGFyc2Ugc3RhdGUgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0ZSwgXG4gICAgLy8gVGhlIHBvc2l0aW9uIGF0IHdoaWNoIHRoZSBuZXh0IHJlZHVjZSBzaG91bGQgdGFrZSBwbGFjZS4gVGhpc1xuICAgIC8vIGNhbiBiZSBsZXNzIHRoYW4gYHRoaXMucG9zYCB3aGVuIHNraXBwZWQgZXhwcmVzc2lvbnMgaGF2ZSBiZWVuXG4gICAgLy8gYWRkZWQgdG8gdGhlIHN0YWNrICh3aGljaCBzaG91bGQgYmUgbW92ZWQgb3V0c2lkZSBvZiB0aGUgbmV4dFxuICAgIC8vIHJlZHVjdGlvbilcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJlZHVjZVBvcywgXG4gICAgLyoqXG4gICAgVGhlIGlucHV0IHBvc2l0aW9uIHVwIHRvIHdoaWNoIHRoaXMgc3RhY2sgaGFzIHBhcnNlZC5cbiAgICAqL1xuICAgIHBvcywgXG4gICAgLyoqXG4gICAgVGhlIGR5bmFtaWMgc2NvcmUgb2YgdGhlIHN0YWNrLCBpbmNsdWRpbmcgZHluYW1pYyBwcmVjZWRlbmNlXG4gICAgYW5kIGVycm9yLXJlY292ZXJ5IHBlbmFsdGllc1xuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2NvcmUsIFxuICAgIC8vIFRoZSBvdXRwdXQgYnVmZmVyLiBIb2xkcyAodHlwZSwgc3RhcnQsIGVuZCwgc2l6ZSkgcXVhZHNcbiAgICAvLyByZXByZXNlbnRpbmcgbm9kZXMgY3JlYXRlZCBieSB0aGUgcGFyc2VyLCB3aGVyZSBgc2l6ZWAgaXNcbiAgICAvLyBhbW91bnQgb2YgYnVmZmVyIGFycmF5IGVudHJpZXMgY292ZXJlZCBieSB0aGlzIG5vZGUuXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBidWZmZXIsIFxuICAgIC8vIFRoZSBiYXNlIG9mZnNldCBvZiB0aGUgYnVmZmVyLiBXaGVuIHN0YWNrcyBhcmUgc3BsaXQsIHRoZSBzcGxpdFxuICAgIC8vIGluc3RhbmNlIHNoYXJlZCB0aGUgYnVmZmVyIGhpc3Rvcnkgd2l0aCBpdHMgcGFyZW50IHVwIHRvXG4gICAgLy8gYGJ1ZmZlckJhc2VgLCB3aGljaCBpcyB0aGUgYWJzb2x1dGUgb2Zmc2V0IChpbmNsdWRpbmcgdGhlXG4gICAgLy8gb2Zmc2V0IG9mIHByZXZpb3VzIHNwbGl0cykgaW50byB0aGUgYnVmZmVyIGF0IHdoaWNoIHRoaXMgc3RhY2tcbiAgICAvLyBzdGFydHMgd3JpdGluZy5cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGJ1ZmZlckJhc2UsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY3VyQ29udGV4dCwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBsb29rQWhlYWQgPSAwLCBcbiAgICAvLyBBIHBhcmVudCBzdGFjayBmcm9tIHdoaWNoIHRoaXMgd2FzIHNwbGl0IG9mZiwgaWYgYW55LiBUaGlzIGlzXG4gICAgLy8gc2V0IHVwIHNvIHRoYXQgaXQgYWx3YXlzIHBvaW50cyB0byBhIHN0YWNrIHRoYXQgaGFzIHNvbWVcbiAgICAvLyBhZGRpdGlvbmFsIGJ1ZmZlciBjb250ZW50LCBuZXZlciB0byBhIHN0YWNrIHdpdGggYW4gZXF1YWxcbiAgICAvLyBgYnVmZmVyQmFzZWAuXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBwYXJlbnQpIHtcbiAgICAgICAgdGhpcy5wID0gcDtcbiAgICAgICAgdGhpcy5zdGFjayA9IHN0YWNrO1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHRoaXMucmVkdWNlUG9zID0gcmVkdWNlUG9zO1xuICAgICAgICB0aGlzLnBvcyA9IHBvcztcbiAgICAgICAgdGhpcy5zY29yZSA9IHNjb3JlO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgdGhpcy5idWZmZXJCYXNlID0gYnVmZmVyQmFzZTtcbiAgICAgICAgdGhpcy5jdXJDb250ZXh0ID0gY3VyQ29udGV4dDtcbiAgICAgICAgdGhpcy5sb29rQWhlYWQgPSBsb29rQWhlYWQ7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYFske3RoaXMuc3RhY2suZmlsdGVyKChfLCBpKSA9PiBpICUgMyA9PSAwKS5jb25jYXQodGhpcy5zdGF0ZSl9XUAke3RoaXMucG9zfSR7dGhpcy5zY29yZSA/IFwiIVwiICsgdGhpcy5zY29yZSA6IFwiXCJ9YDtcbiAgICB9XG4gICAgLy8gU3RhcnQgYW4gZW1wdHkgc3RhY2tcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBzdGFydChwLCBzdGF0ZSwgcG9zID0gMCkge1xuICAgICAgICBsZXQgY3ggPSBwLnBhcnNlci5jb250ZXh0O1xuICAgICAgICByZXR1cm4gbmV3IFN0YWNrKHAsIFtdLCBzdGF0ZSwgcG9zLCBwb3MsIDAsIFtdLCAwLCBjeCA/IG5ldyBTdGFja0NvbnRleHQoY3gsIGN4LnN0YXJ0KSA6IG51bGwsIDAsIG51bGwpO1xuICAgIH1cbiAgICAvKipcbiAgICBUaGUgc3RhY2sncyBjdXJyZW50IFtjb250ZXh0XSgjbHIuQ29udGV4dFRyYWNrZXIpIHZhbHVlLCBpZlxuICAgIGFueS4gSXRzIHR5cGUgd2lsbCBkZXBlbmQgb24gdGhlIGNvbnRleHQgdHJhY2tlcidzIHR5cGVcbiAgICBwYXJhbWV0ZXIsIG9yIGl0IHdpbGwgYmUgYG51bGxgIGlmIHRoZXJlIGlzIG5vIGNvbnRleHRcbiAgICB0cmFja2VyLlxuICAgICovXG4gICAgZ2V0IGNvbnRleHQoKSB7IHJldHVybiB0aGlzLmN1ckNvbnRleHQgPyB0aGlzLmN1ckNvbnRleHQuY29udGV4dCA6IG51bGw7IH1cbiAgICAvLyBQdXNoIGEgc3RhdGUgb250byB0aGUgc3RhY2ssIHRyYWNraW5nIGl0cyBzdGFydCBwb3NpdGlvbiBhcyB3ZWxsXG4gICAgLy8gYXMgdGhlIGJ1ZmZlciBiYXNlIGF0IHRoYXQgcG9pbnQuXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBwdXNoU3RhdGUoc3RhdGUsIHN0YXJ0KSB7XG4gICAgICAgIHRoaXMuc3RhY2sucHVzaCh0aGlzLnN0YXRlLCBzdGFydCwgdGhpcy5idWZmZXJCYXNlICsgdGhpcy5idWZmZXIubGVuZ3RoKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlO1xuICAgIH1cbiAgICAvLyBBcHBseSBhIHJlZHVjZSBhY3Rpb25cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJlZHVjZShhY3Rpb24pIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgZGVwdGggPSBhY3Rpb24gPj4gMTkgLyogQWN0aW9uLlJlZHVjZURlcHRoU2hpZnQgKi8sIHR5cGUgPSBhY3Rpb24gJiA2NTUzNSAvKiBBY3Rpb24uVmFsdWVNYXNrICovO1xuICAgICAgICBsZXQgeyBwYXJzZXIgfSA9IHRoaXMucDtcbiAgICAgICAgaWYgKHRoaXMucmVkdWNlUG9zIDwgdGhpcy5wb3MgLSAyNSAvKiBMb29rYWhlYWQuTWFyZ2luICovKVxuICAgICAgICAgICAgdGhpcy5zZXRMb29rQWhlYWQodGhpcy5wb3MpO1xuICAgICAgICBsZXQgZFByZWMgPSBwYXJzZXIuZHluYW1pY1ByZWNlZGVuY2UodHlwZSk7XG4gICAgICAgIGlmIChkUHJlYylcbiAgICAgICAgICAgIHRoaXMuc2NvcmUgKz0gZFByZWM7XG4gICAgICAgIGlmIChkZXB0aCA9PSAwKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2hTdGF0ZShwYXJzZXIuZ2V0R290byh0aGlzLnN0YXRlLCB0eXBlLCB0cnVlKSwgdGhpcy5yZWR1Y2VQb3MpO1xuICAgICAgICAgICAgLy8gWmVyby1kZXB0aCByZWR1Y3Rpb25zIGFyZSBhIHNwZWNpYWwgY2FzZeKAlHRoZXkgYWRkIHN0dWZmIHRvXG4gICAgICAgICAgICAvLyB0aGUgc3RhY2sgd2l0aG91dCBwb3BwaW5nIGFueXRoaW5nIG9mZi5cbiAgICAgICAgICAgIGlmICh0eXBlIDwgcGFyc2VyLm1pblJlcGVhdFRlcm0pXG4gICAgICAgICAgICAgICAgdGhpcy5zdG9yZU5vZGUodHlwZSwgdGhpcy5yZWR1Y2VQb3MsIHRoaXMucmVkdWNlUG9zLCA0LCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMucmVkdWNlQ29udGV4dCh0eXBlLCB0aGlzLnJlZHVjZVBvcyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmluZCB0aGUgYmFzZSBpbmRleCBpbnRvIGB0aGlzLnN0YWNrYCwgY29udGVudCBhZnRlciB3aGljaCB3aWxsXG4gICAgICAgIC8vIGJlIGRyb3BwZWQuIE5vdGUgdGhhdCB3aXRoIGBTdGF5RmxhZ2AgcmVkdWN0aW9ucyB3ZSBuZWVkIHRvXG4gICAgICAgIC8vIGNvbnN1bWUgdHdvIGV4dHJhIGZyYW1lcyAodGhlIGR1bW15IHBhcmVudCBub2RlIGZvciB0aGUgc2tpcHBlZFxuICAgICAgICAvLyBleHByZXNzaW9uIGFuZCB0aGUgc3RhdGUgdGhhdCB3ZSdsbCBiZSBzdGF5aW5nIGluLCB3aGljaCBzaG91bGRcbiAgICAgICAgLy8gYmUgbW92ZWQgdG8gYHRoaXMuc3RhdGVgKS5cbiAgICAgICAgbGV0IGJhc2UgPSB0aGlzLnN0YWNrLmxlbmd0aCAtICgoZGVwdGggLSAxKSAqIDMpIC0gKGFjdGlvbiAmIDI2MjE0NCAvKiBBY3Rpb24uU3RheUZsYWcgKi8gPyA2IDogMCk7XG4gICAgICAgIGxldCBzdGFydCA9IGJhc2UgPyB0aGlzLnN0YWNrW2Jhc2UgLSAyXSA6IHRoaXMucC5yYW5nZXNbMF0uZnJvbSwgc2l6ZSA9IHRoaXMucmVkdWNlUG9zIC0gc3RhcnQ7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBrbHVkZ2UgdG8gdHJ5IGFuZCBkZXRlY3Qgb3Zlcmx5IGRlZXAgbGVmdC1hc3NvY2lhdGl2ZVxuICAgICAgICAvLyB0cmVlcywgd2hpY2ggd2lsbCBub3QgaW5jcmVhc2UgdGhlIHBhcnNlIHN0YWNrIGRlcHRoIGFuZCB0aHVzXG4gICAgICAgIC8vIHdvbid0IGJlIGNhdWdodCBieSB0aGUgcmVndWxhciBzdGFjay1kZXB0aCBsaW1pdCBjaGVjay5cbiAgICAgICAgaWYgKHNpemUgPj0gMjAwMCAvKiBSZWNvdmVyLk1pbkJpZ1JlZHVjdGlvbiAqLyAmJiAhKChfYSA9IHRoaXMucC5wYXJzZXIubm9kZVNldC50eXBlc1t0eXBlXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzQW5vbnltb3VzKSkge1xuICAgICAgICAgICAgaWYgKHN0YXJ0ID09IHRoaXMucC5sYXN0QmlnUmVkdWN0aW9uU3RhcnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnAuYmlnUmVkdWN0aW9uQ291bnQrKztcbiAgICAgICAgICAgICAgICB0aGlzLnAubGFzdEJpZ1JlZHVjdGlvblNpemUgPSBzaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5wLmxhc3RCaWdSZWR1Y3Rpb25TaXplIDwgc2l6ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucC5iaWdSZWR1Y3Rpb25Db3VudCA9IDE7XG4gICAgICAgICAgICAgICAgdGhpcy5wLmxhc3RCaWdSZWR1Y3Rpb25TdGFydCA9IHN0YXJ0O1xuICAgICAgICAgICAgICAgIHRoaXMucC5sYXN0QmlnUmVkdWN0aW9uU2l6ZSA9IHNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGJ1ZmZlckJhc2UgPSBiYXNlID8gdGhpcy5zdGFja1tiYXNlIC0gMV0gOiAwLCBjb3VudCA9IHRoaXMuYnVmZmVyQmFzZSArIHRoaXMuYnVmZmVyLmxlbmd0aCAtIGJ1ZmZlckJhc2U7XG4gICAgICAgIC8vIFN0b3JlIG5vcm1hbCB0ZXJtcyBvciBgUiAtPiBSIFJgIHJlcGVhdCByZWR1Y3Rpb25zXG4gICAgICAgIGlmICh0eXBlIDwgcGFyc2VyLm1pblJlcGVhdFRlcm0gfHwgKGFjdGlvbiAmIDEzMTA3MiAvKiBBY3Rpb24uUmVwZWF0RmxhZyAqLykpIHtcbiAgICAgICAgICAgIGxldCBwb3MgPSBwYXJzZXIuc3RhdGVGbGFnKHRoaXMuc3RhdGUsIDEgLyogU3RhdGVGbGFnLlNraXBwZWQgKi8pID8gdGhpcy5wb3MgOiB0aGlzLnJlZHVjZVBvcztcbiAgICAgICAgICAgIHRoaXMuc3RvcmVOb2RlKHR5cGUsIHN0YXJ0LCBwb3MsIGNvdW50ICsgNCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFjdGlvbiAmIDI2MjE0NCAvKiBBY3Rpb24uU3RheUZsYWcgKi8pIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLnN0YWNrW2Jhc2VdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGJhc2VTdGF0ZUlEID0gdGhpcy5zdGFja1tiYXNlIC0gM107XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gcGFyc2VyLmdldEdvdG8oYmFzZVN0YXRlSUQsIHR5cGUsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0aGlzLnN0YWNrLmxlbmd0aCA+IGJhc2UpXG4gICAgICAgICAgICB0aGlzLnN0YWNrLnBvcCgpO1xuICAgICAgICB0aGlzLnJlZHVjZUNvbnRleHQodHlwZSwgc3RhcnQpO1xuICAgIH1cbiAgICAvLyBTaGlmdCBhIHZhbHVlIGludG8gdGhlIGJ1ZmZlclxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RvcmVOb2RlKHRlcm0sIHN0YXJ0LCBlbmQsIHNpemUgPSA0LCBpc1JlZHVjZSA9IGZhbHNlKSB7XG4gICAgICAgIGlmICh0ZXJtID09IDAgLyogVGVybS5FcnIgKi8gJiZcbiAgICAgICAgICAgICghdGhpcy5zdGFjay5sZW5ndGggfHwgdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdIDwgdGhpcy5idWZmZXIubGVuZ3RoICsgdGhpcy5idWZmZXJCYXNlKSkge1xuICAgICAgICAgICAgLy8gVHJ5IHRvIG9taXQvbWVyZ2UgYWRqYWNlbnQgZXJyb3Igbm9kZXNcbiAgICAgICAgICAgIGxldCBjdXIgPSB0aGlzLCB0b3AgPSB0aGlzLmJ1ZmZlci5sZW5ndGg7XG4gICAgICAgICAgICBpZiAodG9wID09IDAgJiYgY3VyLnBhcmVudCkge1xuICAgICAgICAgICAgICAgIHRvcCA9IGN1ci5idWZmZXJCYXNlIC0gY3VyLnBhcmVudC5idWZmZXJCYXNlO1xuICAgICAgICAgICAgICAgIGN1ciA9IGN1ci5wYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9wID4gMCAmJiBjdXIuYnVmZmVyW3RvcCAtIDRdID09IDAgLyogVGVybS5FcnIgKi8gJiYgY3VyLmJ1ZmZlclt0b3AgLSAxXSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXJ0ID09IGVuZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGlmIChjdXIuYnVmZmVyW3RvcCAtIDJdID49IHN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGN1ci5idWZmZXJbdG9wIC0gMl0gPSBlbmQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1JlZHVjZSB8fCB0aGlzLnBvcyA9PSBlbmQpIHsgLy8gU2ltcGxlIGNhc2UsIGp1c3QgYXBwZW5kXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKHRlcm0sIHN0YXJ0LCBlbmQsIHNpemUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBUaGVyZSBtYXkgYmUgc2tpcHBlZCBub2RlcyB0aGF0IGhhdmUgdG8gYmUgbW92ZWQgZm9yd2FyZFxuICAgICAgICAgICAgbGV0IGluZGV4ID0gdGhpcy5idWZmZXIubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gMCAmJiB0aGlzLmJ1ZmZlcltpbmRleCAtIDRdICE9IDAgLyogVGVybS5FcnIgKi8pXG4gICAgICAgICAgICAgICAgd2hpbGUgKGluZGV4ID4gMCAmJiB0aGlzLmJ1ZmZlcltpbmRleCAtIDJdID4gZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1vdmUgdGhpcyByZWNvcmQgZm9yd2FyZFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleF0gPSB0aGlzLmJ1ZmZlcltpbmRleCAtIDRdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleCArIDFdID0gdGhpcy5idWZmZXJbaW5kZXggLSAzXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5idWZmZXJbaW5kZXggKyAyXSA9IHRoaXMuYnVmZmVyW2luZGV4IC0gMl07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyW2luZGV4ICsgM10gPSB0aGlzLmJ1ZmZlcltpbmRleCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBpbmRleCAtPSA0O1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2l6ZSA+IDQpXG4gICAgICAgICAgICAgICAgICAgICAgICBzaXplIC09IDQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5idWZmZXJbaW5kZXhdID0gdGVybTtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyW2luZGV4ICsgMV0gPSBzdGFydDtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyW2luZGV4ICsgMl0gPSBlbmQ7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcltpbmRleCArIDNdID0gc2l6ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBBcHBseSBhIHNoaWZ0IGFjdGlvblxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2hpZnQoYWN0aW9uLCB0eXBlLCBzdGFydCwgZW5kKSB7XG4gICAgICAgIGlmIChhY3Rpb24gJiAxMzEwNzIgLyogQWN0aW9uLkdvdG9GbGFnICovKSB7XG4gICAgICAgICAgICB0aGlzLnB1c2hTdGF0ZShhY3Rpb24gJiA2NTUzNSAvKiBBY3Rpb24uVmFsdWVNYXNrICovLCB0aGlzLnBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGFjdGlvbiAmIDI2MjE0NCAvKiBBY3Rpb24uU3RheUZsYWcgKi8pID09IDApIHsgLy8gUmVndWxhciBzaGlmdFxuICAgICAgICAgICAgbGV0IG5leHRTdGF0ZSA9IGFjdGlvbiwgeyBwYXJzZXIgfSA9IHRoaXMucDtcbiAgICAgICAgICAgIGlmIChlbmQgPiB0aGlzLnBvcyB8fCB0eXBlIDw9IHBhcnNlci5tYXhOb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgPSBlbmQ7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJzZXIuc3RhdGVGbGFnKG5leHRTdGF0ZSwgMSAvKiBTdGF0ZUZsYWcuU2tpcHBlZCAqLykpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVkdWNlUG9zID0gZW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wdXNoU3RhdGUobmV4dFN0YXRlLCBzdGFydCk7XG4gICAgICAgICAgICB0aGlzLnNoaWZ0Q29udGV4dCh0eXBlLCBzdGFydCk7XG4gICAgICAgICAgICBpZiAodHlwZSA8PSBwYXJzZXIubWF4Tm9kZSlcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKHR5cGUsIHN0YXJ0LCBlbmQsIDQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBTaGlmdC1hbmQtc3RheSwgd2hpY2ggbWVhbnMgdGhpcyBpcyBhIHNraXBwZWQgdG9rZW5cbiAgICAgICAgICAgIHRoaXMucG9zID0gZW5kO1xuICAgICAgICAgICAgdGhpcy5zaGlmdENvbnRleHQodHlwZSwgc3RhcnQpO1xuICAgICAgICAgICAgaWYgKHR5cGUgPD0gdGhpcy5wLnBhcnNlci5tYXhOb2RlKVxuICAgICAgICAgICAgICAgIHRoaXMuYnVmZmVyLnB1c2godHlwZSwgc3RhcnQsIGVuZCwgNCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQXBwbHkgYW4gYWN0aW9uXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBhcHBseShhY3Rpb24sIG5leHQsIG5leHRTdGFydCwgbmV4dEVuZCkge1xuICAgICAgICBpZiAoYWN0aW9uICYgNjU1MzYgLyogQWN0aW9uLlJlZHVjZUZsYWcgKi8pXG4gICAgICAgICAgICB0aGlzLnJlZHVjZShhY3Rpb24pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLnNoaWZ0KGFjdGlvbiwgbmV4dCwgbmV4dFN0YXJ0LCBuZXh0RW5kKTtcbiAgICB9XG4gICAgLy8gQWRkIGEgcHJlYnVpbHQgKHJldXNlZCkgbm9kZSBpbnRvIHRoZSBidWZmZXIuXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB1c2VOb2RlKHZhbHVlLCBuZXh0KSB7XG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMucC5yZXVzZWQubGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGluZGV4IDwgMCB8fCB0aGlzLnAucmV1c2VkW2luZGV4XSAhPSB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5wLnJldXNlZC5wdXNoKHZhbHVlKTtcbiAgICAgICAgICAgIGluZGV4Kys7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICAgIHRoaXMucmVkdWNlUG9zID0gdGhpcy5wb3MgPSBzdGFydCArIHZhbHVlLmxlbmd0aDtcbiAgICAgICAgdGhpcy5wdXNoU3RhdGUobmV4dCwgc3RhcnQpO1xuICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKGluZGV4LCBzdGFydCwgdGhpcy5yZWR1Y2VQb3MsIC0xIC8qIHNpemUgPT0gLTEgbWVhbnMgdGhpcyBpcyBhIHJldXNlZCB2YWx1ZSAqLyk7XG4gICAgICAgIGlmICh0aGlzLmN1ckNvbnRleHQpXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUNvbnRleHQodGhpcy5jdXJDb250ZXh0LnRyYWNrZXIucmV1c2UodGhpcy5jdXJDb250ZXh0LmNvbnRleHQsIHZhbHVlLCB0aGlzLCB0aGlzLnAuc3RyZWFtLnJlc2V0KHRoaXMucG9zIC0gdmFsdWUubGVuZ3RoKSkpO1xuICAgIH1cbiAgICAvLyBTcGxpdCB0aGUgc3RhY2suIER1ZSB0byB0aGUgYnVmZmVyIHNoYXJpbmcgYW5kIHRoZSBmYWN0XG4gICAgLy8gdGhhdCBgdGhpcy5zdGFja2AgdGVuZHMgdG8gc3RheSBxdWl0ZSBzaGFsbG93LCB0aGlzIGlzbid0IHZlcnlcbiAgICAvLyBleHBlbnNpdmUuXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzcGxpdCgpIHtcbiAgICAgICAgbGV0IHBhcmVudCA9IHRoaXM7XG4gICAgICAgIGxldCBvZmYgPSBwYXJlbnQuYnVmZmVyLmxlbmd0aDtcbiAgICAgICAgLy8gQmVjYXVzZSB0aGUgdG9wIG9mIHRoZSBidWZmZXIgKGFmdGVyIHRoaXMucG9zKSBtYXkgYmUgbXV0YXRlZFxuICAgICAgICAvLyB0byByZW9yZGVyIHJlZHVjdGlvbnMgYW5kIHNraXBwZWQgdG9rZW5zLCBhbmQgc2hhcmVkIGJ1ZmZlcnNcbiAgICAgICAgLy8gc2hvdWxkIGJlIGltbXV0YWJsZSwgdGhpcyBjb3BpZXMgYW55IG91dHN0YW5kaW5nIHNraXBwZWQgdG9rZW5zXG4gICAgICAgIC8vIHRvIHRoZSBuZXcgYnVmZmVyLCBhbmQgcHV0cyB0aGUgYmFzZSBwb2ludGVyIGJlZm9yZSB0aGVtLlxuICAgICAgICB3aGlsZSAob2ZmID4gMCAmJiBwYXJlbnQuYnVmZmVyW29mZiAtIDJdID4gcGFyZW50LnJlZHVjZVBvcylcbiAgICAgICAgICAgIG9mZiAtPSA0O1xuICAgICAgICBsZXQgYnVmZmVyID0gcGFyZW50LmJ1ZmZlci5zbGljZShvZmYpLCBiYXNlID0gcGFyZW50LmJ1ZmZlckJhc2UgKyBvZmY7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSBwYXJlbnQgcG9pbnRzIHRvIGFuIGFjdHVhbCBwYXJlbnQgd2l0aCBjb250ZW50LCBpZiB0aGVyZSBpcyBzdWNoIGEgcGFyZW50LlxuICAgICAgICB3aGlsZSAocGFyZW50ICYmIGJhc2UgPT0gcGFyZW50LmJ1ZmZlckJhc2UpXG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgICAgICByZXR1cm4gbmV3IFN0YWNrKHRoaXMucCwgdGhpcy5zdGFjay5zbGljZSgpLCB0aGlzLnN0YXRlLCB0aGlzLnJlZHVjZVBvcywgdGhpcy5wb3MsIHRoaXMuc2NvcmUsIGJ1ZmZlciwgYmFzZSwgdGhpcy5jdXJDb250ZXh0LCB0aGlzLmxvb2tBaGVhZCwgcGFyZW50KTtcbiAgICB9XG4gICAgLy8gVHJ5IHRvIHJlY292ZXIgZnJvbSBhbiBlcnJvciBieSAnZGVsZXRpbmcnIChpZ25vcmluZykgb25lIHRva2VuLlxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmVjb3ZlckJ5RGVsZXRlKG5leHQsIG5leHRFbmQpIHtcbiAgICAgICAgbGV0IGlzTm9kZSA9IG5leHQgPD0gdGhpcy5wLnBhcnNlci5tYXhOb2RlO1xuICAgICAgICBpZiAoaXNOb2RlKVxuICAgICAgICAgICAgdGhpcy5zdG9yZU5vZGUobmV4dCwgdGhpcy5wb3MsIG5leHRFbmQsIDQpO1xuICAgICAgICB0aGlzLnN0b3JlTm9kZSgwIC8qIFRlcm0uRXJyICovLCB0aGlzLnBvcywgbmV4dEVuZCwgaXNOb2RlID8gOCA6IDQpO1xuICAgICAgICB0aGlzLnBvcyA9IHRoaXMucmVkdWNlUG9zID0gbmV4dEVuZDtcbiAgICAgICAgdGhpcy5zY29yZSAtPSAxOTAgLyogUmVjb3Zlci5EZWxldGUgKi87XG4gICAgfVxuICAgIC8qKlxuICAgIENoZWNrIGlmIHRoZSBnaXZlbiB0ZXJtIHdvdWxkIGJlIGFibGUgdG8gYmUgc2hpZnRlZCAob3B0aW9uYWxseVxuICAgIGFmdGVyIHNvbWUgcmVkdWN0aW9ucykgb24gdGhpcyBzdGFjay4gVGhpcyBjYW4gYmUgdXNlZnVsIGZvclxuICAgIGV4dGVybmFsIHRva2VuaXplcnMgdGhhdCB3YW50IHRvIG1ha2Ugc3VyZSB0aGV5IG9ubHkgcHJvdmlkZSBhXG4gICAgZ2l2ZW4gdG9rZW4gd2hlbiBpdCBhcHBsaWVzLlxuICAgICovXG4gICAgY2FuU2hpZnQodGVybSkge1xuICAgICAgICBmb3IgKGxldCBzaW0gPSBuZXcgU2ltdWxhdGVkU3RhY2sodGhpcyk7Oykge1xuICAgICAgICAgICAgbGV0IGFjdGlvbiA9IHRoaXMucC5wYXJzZXIuc3RhdGVTbG90KHNpbS5zdGF0ZSwgNCAvKiBQYXJzZVN0YXRlLkRlZmF1bHRSZWR1Y2UgKi8pIHx8IHRoaXMucC5wYXJzZXIuaGFzQWN0aW9uKHNpbS5zdGF0ZSwgdGVybSk7XG4gICAgICAgICAgICBpZiAoYWN0aW9uID09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKChhY3Rpb24gJiA2NTUzNiAvKiBBY3Rpb24uUmVkdWNlRmxhZyAqLykgPT0gMClcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIHNpbS5yZWR1Y2UoYWN0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBBcHBseSB1cCB0byBSZWNvdmVyLk1heE5leHQgcmVjb3ZlcnkgYWN0aW9ucyB0aGF0IGNvbmNlcHR1YWxseVxuICAgIC8vIGluc2VydHMgc29tZSBtaXNzaW5nIHRva2VuIG9yIHJ1bGUuXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICByZWNvdmVyQnlJbnNlcnQobmV4dCkge1xuICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPj0gMzAwIC8qIFJlY292ZXIuTWF4SW5zZXJ0U3RhY2tEZXB0aCAqLylcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgbGV0IG5leHRTdGF0ZXMgPSB0aGlzLnAucGFyc2VyLm5leHRTdGF0ZXModGhpcy5zdGF0ZSk7XG4gICAgICAgIGlmIChuZXh0U3RhdGVzLmxlbmd0aCA+IDQgLyogUmVjb3Zlci5NYXhOZXh0ICovIDw8IDEgfHwgdGhpcy5zdGFjay5sZW5ndGggPj0gMTIwIC8qIFJlY292ZXIuRGFtcGVuSW5zZXJ0U3RhY2tEZXB0aCAqLykge1xuICAgICAgICAgICAgbGV0IGJlc3QgPSBbXTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBzOyBpIDwgbmV4dFN0YXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgIGlmICgocyA9IG5leHRTdGF0ZXNbaSArIDFdKSAhPSB0aGlzLnN0YXRlICYmIHRoaXMucC5wYXJzZXIuaGFzQWN0aW9uKHMsIG5leHQpKVxuICAgICAgICAgICAgICAgICAgICBiZXN0LnB1c2gobmV4dFN0YXRlc1tpXSwgcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPCAxMjAgLyogUmVjb3Zlci5EYW1wZW5JbnNlcnRTdGFja0RlcHRoICovKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBiZXN0Lmxlbmd0aCA8IDQgLyogUmVjb3Zlci5NYXhOZXh0ICovIDw8IDEgJiYgaSA8IG5leHRTdGF0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHMgPSBuZXh0U3RhdGVzW2kgKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFiZXN0LnNvbWUoKHYsIGkpID0+IChpICYgMSkgJiYgdiA9PSBzKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlc3QucHVzaChuZXh0U3RhdGVzW2ldLCBzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0U3RhdGVzID0gYmVzdDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV4dFN0YXRlcy5sZW5ndGggJiYgcmVzdWx0Lmxlbmd0aCA8IDQgLyogUmVjb3Zlci5NYXhOZXh0ICovOyBpICs9IDIpIHtcbiAgICAgICAgICAgIGxldCBzID0gbmV4dFN0YXRlc1tpICsgMV07XG4gICAgICAgICAgICBpZiAocyA9PSB0aGlzLnN0YXRlKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgbGV0IHN0YWNrID0gdGhpcy5zcGxpdCgpO1xuICAgICAgICAgICAgc3RhY2sucHVzaFN0YXRlKHMsIHRoaXMucG9zKTtcbiAgICAgICAgICAgIHN0YWNrLnN0b3JlTm9kZSgwIC8qIFRlcm0uRXJyICovLCBzdGFjay5wb3MsIHN0YWNrLnBvcywgNCwgdHJ1ZSk7XG4gICAgICAgICAgICBzdGFjay5zaGlmdENvbnRleHQobmV4dFN0YXRlc1tpXSwgdGhpcy5wb3MpO1xuICAgICAgICAgICAgc3RhY2sucmVkdWNlUG9zID0gdGhpcy5wb3M7XG4gICAgICAgICAgICBzdGFjay5zY29yZSAtPSAyMDAgLyogUmVjb3Zlci5JbnNlcnQgKi87XG4gICAgICAgICAgICByZXN1bHQucHVzaChzdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gRm9yY2UgYSByZWR1Y2UsIGlmIHBvc3NpYmxlLiBSZXR1cm4gZmFsc2UgaWYgdGhhdCBjYW4ndFxuICAgIC8vIGJlIGRvbmUuXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBmb3JjZVJlZHVjZSgpIHtcbiAgICAgICAgbGV0IHsgcGFyc2VyIH0gPSB0aGlzLnA7XG4gICAgICAgIGxldCByZWR1Y2UgPSBwYXJzZXIuc3RhdGVTbG90KHRoaXMuc3RhdGUsIDUgLyogUGFyc2VTdGF0ZS5Gb3JjZWRSZWR1Y2UgKi8pO1xuICAgICAgICBpZiAoKHJlZHVjZSAmIDY1NTM2IC8qIEFjdGlvbi5SZWR1Y2VGbGFnICovKSA9PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIXBhcnNlci52YWxpZEFjdGlvbih0aGlzLnN0YXRlLCByZWR1Y2UpKSB7XG4gICAgICAgICAgICBsZXQgZGVwdGggPSByZWR1Y2UgPj4gMTkgLyogQWN0aW9uLlJlZHVjZURlcHRoU2hpZnQgKi8sIHRlcm0gPSByZWR1Y2UgJiA2NTUzNSAvKiBBY3Rpb24uVmFsdWVNYXNrICovO1xuICAgICAgICAgICAgbGV0IHRhcmdldCA9IHRoaXMuc3RhY2subGVuZ3RoIC0gZGVwdGggKiAzO1xuICAgICAgICAgICAgaWYgKHRhcmdldCA8IDAgfHwgcGFyc2VyLmdldEdvdG8odGhpcy5zdGFja1t0YXJnZXRdLCB0ZXJtLCBmYWxzZSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IGJhY2t1cCA9IHRoaXMuZmluZEZvcmNlZFJlZHVjdGlvbigpO1xuICAgICAgICAgICAgICAgIGlmIChiYWNrdXAgPT0gbnVsbClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIHJlZHVjZSA9IGJhY2t1cDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3RvcmVOb2RlKDAgLyogVGVybS5FcnIgKi8sIHRoaXMucG9zLCB0aGlzLnBvcywgNCwgdHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLnNjb3JlIC09IDEwMCAvKiBSZWNvdmVyLlJlZHVjZSAqLztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlZHVjZVBvcyA9IHRoaXMucG9zO1xuICAgICAgICB0aGlzLnJlZHVjZShyZWR1Y2UpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgVHJ5IHRvIHNjYW4gdGhyb3VnaCB0aGUgYXV0b21hdG9uIHRvIGZpbmQgc29tZSBraW5kIG9mIHJlZHVjdGlvblxuICAgIHRoYXQgY2FuIGJlIGFwcGxpZWQuIFVzZWQgd2hlbiB0aGUgcmVndWxhciBGb3JjZWRSZWR1Y2UgZmllbGRcbiAgICBpc24ndCBhIHZhbGlkIGFjdGlvbi4gQGludGVybmFsXG4gICAgKi9cbiAgICBmaW5kRm9yY2VkUmVkdWN0aW9uKCkge1xuICAgICAgICBsZXQgeyBwYXJzZXIgfSA9IHRoaXMucCwgc2VlbiA9IFtdO1xuICAgICAgICBsZXQgZXhwbG9yZSA9IChzdGF0ZSwgZGVwdGgpID0+IHtcbiAgICAgICAgICAgIGlmIChzZWVuLmluY2x1ZGVzKHN0YXRlKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBzZWVuLnB1c2goc3RhdGUpO1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlci5hbGxBY3Rpb25zKHN0YXRlLCAoYWN0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGFjdGlvbiAmICgyNjIxNDQgLyogQWN0aW9uLlN0YXlGbGFnICovIHwgMTMxMDcyIC8qIEFjdGlvbi5Hb3RvRmxhZyAqLykpIDtcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhY3Rpb24gJiA2NTUzNiAvKiBBY3Rpb24uUmVkdWNlRmxhZyAqLykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgckRlcHRoID0gKGFjdGlvbiA+PiAxOSAvKiBBY3Rpb24uUmVkdWNlRGVwdGhTaGlmdCAqLykgLSBkZXB0aDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJEZXB0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0ZXJtID0gYWN0aW9uICYgNjU1MzUgLyogQWN0aW9uLlZhbHVlTWFzayAqLywgdGFyZ2V0ID0gdGhpcy5zdGFjay5sZW5ndGggLSByRGVwdGggKiAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldCA+PSAwICYmIHBhcnNlci5nZXRHb3RvKHRoaXMuc3RhY2tbdGFyZ2V0XSwgdGVybSwgZmFsc2UpID49IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChyRGVwdGggPDwgMTkgLyogQWN0aW9uLlJlZHVjZURlcHRoU2hpZnQgKi8pIHwgNjU1MzYgLyogQWN0aW9uLlJlZHVjZUZsYWcgKi8gfCB0ZXJtO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBleHBsb3JlKGFjdGlvbiwgZGVwdGggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kICE9IG51bGwpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBleHBsb3JlKHRoaXMuc3RhdGUsIDApO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGZvcmNlQWxsKCkge1xuICAgICAgICB3aGlsZSAoIXRoaXMucC5wYXJzZXIuc3RhdGVGbGFnKHRoaXMuc3RhdGUsIDIgLyogU3RhdGVGbGFnLkFjY2VwdGluZyAqLykpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5mb3JjZVJlZHVjZSgpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdG9yZU5vZGUoMCAvKiBUZXJtLkVyciAqLywgdGhpcy5wb3MsIHRoaXMucG9zLCA0LCB0cnVlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgQ2hlY2sgd2hldGhlciB0aGlzIHN0YXRlIGhhcyBubyBmdXJ0aGVyIGFjdGlvbnMgKGFzc3VtZWQgdG8gYmUgYSBkaXJlY3QgZGVzY2VuZGFudCBvZiB0aGVcbiAgICB0b3Agc3RhdGUsIHNpbmNlIGFueSBvdGhlciBzdGF0ZXMgbXVzdCBiZSBhYmxlIHRvIGNvbnRpbnVlXG4gICAgc29tZWhvdykuIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IGRlYWRFbmQoKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YWNrLmxlbmd0aCAhPSAzKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBsZXQgeyBwYXJzZXIgfSA9IHRoaXMucDtcbiAgICAgICAgcmV0dXJuIHBhcnNlci5kYXRhW3BhcnNlci5zdGF0ZVNsb3QodGhpcy5zdGF0ZSwgMSAvKiBQYXJzZVN0YXRlLkFjdGlvbnMgKi8pXSA9PSA2NTUzNSAvKiBTZXEuRW5kICovICYmXG4gICAgICAgICAgICAhcGFyc2VyLnN0YXRlU2xvdCh0aGlzLnN0YXRlLCA0IC8qIFBhcnNlU3RhdGUuRGVmYXVsdFJlZHVjZSAqLyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJlc3RhcnQgdGhlIHN0YWNrIChwdXQgaXQgYmFjayBpbiBpdHMgc3RhcnQgc3RhdGUpLiBPbmx5IHNhZmVcbiAgICB3aGVuIHRoaXMuc3RhY2subGVuZ3RoID09IDMgKHN0YXRlIGlzIGRpcmVjdGx5IGJlbG93IHRoZSB0b3BcbiAgICBzdGF0ZSkuIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmVzdGFydCgpIHtcbiAgICAgICAgdGhpcy5zdG9yZU5vZGUoMCAvKiBUZXJtLkVyciAqLywgdGhpcy5wb3MsIHRoaXMucG9zLCA0LCB0cnVlKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMuc3RhY2tbMF07XG4gICAgICAgIHRoaXMuc3RhY2subGVuZ3RoID0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzYW1lU3RhdGUob3RoZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT0gb3RoZXIuc3RhdGUgfHwgdGhpcy5zdGFjay5sZW5ndGggIT0gb3RoZXIuc3RhY2subGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3RhY2subGVuZ3RoOyBpICs9IDMpXG4gICAgICAgICAgICBpZiAodGhpcy5zdGFja1tpXSAhPSBvdGhlci5zdGFja1tpXSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHBhcnNlciB1c2VkIGJ5IHRoaXMgc3RhY2suXG4gICAgKi9cbiAgICBnZXQgcGFyc2VyKCkgeyByZXR1cm4gdGhpcy5wLnBhcnNlcjsgfVxuICAgIC8qKlxuICAgIFRlc3Qgd2hldGhlciBhIGdpdmVuIGRpYWxlY3QgKGJ5IG51bWVyaWMgSUQsIGFzIGV4cG9ydGVkIGZyb21cbiAgICB0aGUgdGVybXMgZmlsZSkgaXMgZW5hYmxlZC5cbiAgICAqL1xuICAgIGRpYWxlY3RFbmFibGVkKGRpYWxlY3RJRCkgeyByZXR1cm4gdGhpcy5wLnBhcnNlci5kaWFsZWN0LmZsYWdzW2RpYWxlY3RJRF07IH1cbiAgICBzaGlmdENvbnRleHQodGVybSwgc3RhcnQpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VyQ29udGV4dClcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ29udGV4dCh0aGlzLmN1ckNvbnRleHQudHJhY2tlci5zaGlmdCh0aGlzLmN1ckNvbnRleHQuY29udGV4dCwgdGVybSwgdGhpcywgdGhpcy5wLnN0cmVhbS5yZXNldChzdGFydCkpKTtcbiAgICB9XG4gICAgcmVkdWNlQ29udGV4dCh0ZXJtLCBzdGFydCkge1xuICAgICAgICBpZiAodGhpcy5jdXJDb250ZXh0KVxuICAgICAgICAgICAgdGhpcy51cGRhdGVDb250ZXh0KHRoaXMuY3VyQ29udGV4dC50cmFja2VyLnJlZHVjZSh0aGlzLmN1ckNvbnRleHQuY29udGV4dCwgdGVybSwgdGhpcywgdGhpcy5wLnN0cmVhbS5yZXNldChzdGFydCkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBlbWl0Q29udGV4dCgpIHtcbiAgICAgICAgbGV0IGxhc3QgPSB0aGlzLmJ1ZmZlci5sZW5ndGggLSAxO1xuICAgICAgICBpZiAobGFzdCA8IDAgfHwgdGhpcy5idWZmZXJbbGFzdF0gIT0gLTMpXG4gICAgICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKHRoaXMuY3VyQ29udGV4dC5oYXNoLCB0aGlzLnBvcywgdGhpcy5wb3MsIC0zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBlbWl0TG9va0FoZWFkKCkge1xuICAgICAgICBsZXQgbGFzdCA9IHRoaXMuYnVmZmVyLmxlbmd0aCAtIDE7XG4gICAgICAgIGlmIChsYXN0IDwgMCB8fCB0aGlzLmJ1ZmZlcltsYXN0XSAhPSAtNClcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyLnB1c2godGhpcy5sb29rQWhlYWQsIHRoaXMucG9zLCB0aGlzLnBvcywgLTQpO1xuICAgIH1cbiAgICB1cGRhdGVDb250ZXh0KGNvbnRleHQpIHtcbiAgICAgICAgaWYgKGNvbnRleHQgIT0gdGhpcy5jdXJDb250ZXh0LmNvbnRleHQpIHtcbiAgICAgICAgICAgIGxldCBuZXdDeCA9IG5ldyBTdGFja0NvbnRleHQodGhpcy5jdXJDb250ZXh0LnRyYWNrZXIsIGNvbnRleHQpO1xuICAgICAgICAgICAgaWYgKG5ld0N4Lmhhc2ggIT0gdGhpcy5jdXJDb250ZXh0Lmhhc2gpXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0Q29udGV4dCgpO1xuICAgICAgICAgICAgdGhpcy5jdXJDb250ZXh0ID0gbmV3Q3g7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzZXRMb29rQWhlYWQobG9va0FoZWFkKSB7XG4gICAgICAgIGlmIChsb29rQWhlYWQgPiB0aGlzLmxvb2tBaGVhZCkge1xuICAgICAgICAgICAgdGhpcy5lbWl0TG9va0FoZWFkKCk7XG4gICAgICAgICAgICB0aGlzLmxvb2tBaGVhZCA9IGxvb2tBaGVhZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNsb3NlKCkge1xuICAgICAgICBpZiAodGhpcy5jdXJDb250ZXh0ICYmIHRoaXMuY3VyQ29udGV4dC50cmFja2VyLnN0cmljdClcbiAgICAgICAgICAgIHRoaXMuZW1pdENvbnRleHQoKTtcbiAgICAgICAgaWYgKHRoaXMubG9va0FoZWFkID4gMClcbiAgICAgICAgICAgIHRoaXMuZW1pdExvb2tBaGVhZCgpO1xuICAgIH1cbn1cbmNsYXNzIFN0YWNrQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3IodHJhY2tlciwgY29udGV4dCkge1xuICAgICAgICB0aGlzLnRyYWNrZXIgPSB0cmFja2VyO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLmhhc2ggPSB0cmFja2VyLnN0cmljdCA/IHRyYWNrZXIuaGFzaChjb250ZXh0KSA6IDA7XG4gICAgfVxufVxuLy8gVXNlZCB0byBjaGVhcGx5IHJ1biBzb21lIHJlZHVjdGlvbnMgdG8gc2NhbiBhaGVhZCB3aXRob3V0IG11dGF0aW5nXG4vLyBhbiBlbnRpcmUgc3RhY2tcbmNsYXNzIFNpbXVsYXRlZFN0YWNrIHtcbiAgICBjb25zdHJ1Y3RvcihzdGFydCkge1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGFydC5zdGF0ZTtcbiAgICAgICAgdGhpcy5zdGFjayA9IHN0YXJ0LnN0YWNrO1xuICAgICAgICB0aGlzLmJhc2UgPSB0aGlzLnN0YWNrLmxlbmd0aDtcbiAgICB9XG4gICAgcmVkdWNlKGFjdGlvbikge1xuICAgICAgICBsZXQgdGVybSA9IGFjdGlvbiAmIDY1NTM1IC8qIEFjdGlvbi5WYWx1ZU1hc2sgKi8sIGRlcHRoID0gYWN0aW9uID4+IDE5IC8qIEFjdGlvbi5SZWR1Y2VEZXB0aFNoaWZ0ICovO1xuICAgICAgICBpZiAoZGVwdGggPT0gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhY2sgPT0gdGhpcy5zdGFydC5zdGFjaylcbiAgICAgICAgICAgICAgICB0aGlzLnN0YWNrID0gdGhpcy5zdGFjay5zbGljZSgpO1xuICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKHRoaXMuc3RhdGUsIDAsIDApO1xuICAgICAgICAgICAgdGhpcy5iYXNlICs9IDM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmJhc2UgLT0gKGRlcHRoIC0gMSkgKiAzO1xuICAgICAgICB9XG4gICAgICAgIGxldCBnb3RvID0gdGhpcy5zdGFydC5wLnBhcnNlci5nZXRHb3RvKHRoaXMuc3RhY2tbdGhpcy5iYXNlIC0gM10sIHRlcm0sIHRydWUpO1xuICAgICAgICB0aGlzLnN0YXRlID0gZ290bztcbiAgICB9XG59XG4vLyBUaGlzIGlzIGdpdmVuIHRvIGBUcmVlLmJ1aWxkYCB0byBidWlsZCBhIGJ1ZmZlciwgYW5kIGVuY2Fwc3VsYXRlc1xuLy8gdGhlIHBhcmVudC1zdGFjay13YWxraW5nIG5lY2Vzc2FyeSB0byByZWFkIHRoZSBub2Rlcy5cbmNsYXNzIFN0YWNrQnVmZmVyQ3Vyc29yIHtcbiAgICBjb25zdHJ1Y3RvcihzdGFjaywgcG9zLCBpbmRleCkge1xuICAgICAgICB0aGlzLnN0YWNrID0gc3RhY2s7XG4gICAgICAgIHRoaXMucG9zID0gcG9zO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gc3RhY2suYnVmZmVyO1xuICAgICAgICBpZiAodGhpcy5pbmRleCA9PSAwKVxuICAgICAgICAgICAgdGhpcy5tYXliZU5leHQoKTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZShzdGFjaywgcG9zID0gc3RhY2suYnVmZmVyQmFzZSArIHN0YWNrLmJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdGFja0J1ZmZlckN1cnNvcihzdGFjaywgcG9zLCBwb3MgLSBzdGFjay5idWZmZXJCYXNlKTtcbiAgICB9XG4gICAgbWF5YmVOZXh0KCkge1xuICAgICAgICBsZXQgbmV4dCA9IHRoaXMuc3RhY2sucGFyZW50O1xuICAgICAgICBpZiAobmV4dCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gdGhpcy5zdGFjay5idWZmZXJCYXNlIC0gbmV4dC5idWZmZXJCYXNlO1xuICAgICAgICAgICAgdGhpcy5zdGFjayA9IG5leHQ7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IG5leHQuYnVmZmVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBpZCgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSA0XTsgfVxuICAgIGdldCBzdGFydCgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSAzXTsgfVxuICAgIGdldCBlbmQoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gMl07IH1cbiAgICBnZXQgc2l6ZSgpIHsgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaW5kZXggLSAxXTsgfVxuICAgIG5leHQoKSB7XG4gICAgICAgIHRoaXMuaW5kZXggLT0gNDtcbiAgICAgICAgdGhpcy5wb3MgLT0gNDtcbiAgICAgICAgaWYgKHRoaXMuaW5kZXggPT0gMClcbiAgICAgICAgICAgIHRoaXMubWF5YmVOZXh0KCk7XG4gICAgfVxuICAgIGZvcmsoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RhY2tCdWZmZXJDdXJzb3IodGhpcy5zdGFjaywgdGhpcy5wb3MsIHRoaXMuaW5kZXgpO1xuICAgIH1cbn1cblxuLy8gU2VlIGxlemVyLWdlbmVyYXRvci9zcmMvZW5jb2RlLnRzIGZvciBjb21tZW50cyBhYm91dCB0aGUgZW5jb2Rpbmdcbi8vIHVzZWQgaGVyZVxuZnVuY3Rpb24gZGVjb2RlQXJyYXkoaW5wdXQsIFR5cGUgPSBVaW50MTZBcnJheSkge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgIGxldCBhcnJheSA9IG51bGw7XG4gICAgZm9yIChsZXQgcG9zID0gMCwgb3V0ID0gMDsgcG9zIDwgaW5wdXQubGVuZ3RoOykge1xuICAgICAgICBsZXQgdmFsdWUgPSAwO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgbmV4dCA9IGlucHV0LmNoYXJDb2RlQXQocG9zKyspLCBzdG9wID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAobmV4dCA9PSAxMjYgLyogRW5jb2RlLkJpZ1ZhbENvZGUgKi8pIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IDY1NTM1IC8qIEVuY29kZS5CaWdWYWwgKi87XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV4dCA+PSA5MiAvKiBFbmNvZGUuR2FwMiAqLylcbiAgICAgICAgICAgICAgICBuZXh0LS07XG4gICAgICAgICAgICBpZiAobmV4dCA+PSAzNCAvKiBFbmNvZGUuR2FwMSAqLylcbiAgICAgICAgICAgICAgICBuZXh0LS07XG4gICAgICAgICAgICBsZXQgZGlnaXQgPSBuZXh0IC0gMzIgLyogRW5jb2RlLlN0YXJ0ICovO1xuICAgICAgICAgICAgaWYgKGRpZ2l0ID49IDQ2IC8qIEVuY29kZS5CYXNlICovKSB7XG4gICAgICAgICAgICAgICAgZGlnaXQgLT0gNDYgLyogRW5jb2RlLkJhc2UgKi87XG4gICAgICAgICAgICAgICAgc3RvcCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSArPSBkaWdpdDtcbiAgICAgICAgICAgIGlmIChzdG9wKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgdmFsdWUgKj0gNDYgLyogRW5jb2RlLkJhc2UgKi87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFycmF5KVxuICAgICAgICAgICAgYXJyYXlbb3V0KytdID0gdmFsdWU7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGFycmF5ID0gbmV3IFR5cGUodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG5cbmNsYXNzIENhY2hlZFRva2VuIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IC0xO1xuICAgICAgICB0aGlzLnZhbHVlID0gLTE7XG4gICAgICAgIHRoaXMuZW5kID0gLTE7XG4gICAgICAgIHRoaXMuZXh0ZW5kZWQgPSAtMTtcbiAgICAgICAgdGhpcy5sb29rQWhlYWQgPSAwO1xuICAgICAgICB0aGlzLm1hc2sgPSAwO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSAwO1xuICAgIH1cbn1cbmNvbnN0IG51bGxUb2tlbiA9IG5ldyBDYWNoZWRUb2tlbjtcbi8qKlxuW1Rva2VuaXplcnNdKCNsci5FeHRlcm5hbFRva2VuaXplcikgaW50ZXJhY3Qgd2l0aCB0aGUgaW5wdXRcbnRocm91Z2ggdGhpcyBpbnRlcmZhY2UuIEl0IHByZXNlbnRzIHRoZSBpbnB1dCBhcyBhIHN0cmVhbSBvZlxuY2hhcmFjdGVycywgdHJhY2tpbmcgbG9va2FoZWFkIGFuZCBoaWRpbmcgdGhlIGNvbXBsZXhpdHkgb2ZcbltyYW5nZXNdKCNjb21tb24uUGFyc2VyLnBhcnNlXnJhbmdlcykgZnJvbSB0b2tlbml6ZXIgY29kZS5cbiovXG5jbGFzcyBJbnB1dFN0cmVhbSB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGlucHV0LCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJhbmdlcykge1xuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgIHRoaXMucmFuZ2VzID0gcmFuZ2VzO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuY2h1bmsgPSBcIlwiO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuY2h1bmtPZmYgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgQmFja3VwIGNodW5rXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuY2h1bmsyID0gXCJcIjtcbiAgICAgICAgdGhpcy5jaHVuazJQb3MgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgVGhlIGNoYXJhY3RlciBjb2RlIG9mIHRoZSBuZXh0IGNvZGUgdW5pdCBpbiB0aGUgaW5wdXQsIG9yIC0xXG4gICAgICAgIHdoZW4gdGhlIHN0cmVhbSBpcyBhdCB0aGUgZW5kIG9mIHRoZSBpbnB1dC5cbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5uZXh0ID0gLTE7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy50b2tlbiA9IG51bGxUb2tlbjtcbiAgICAgICAgdGhpcy5yYW5nZUluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5wb3MgPSB0aGlzLmNodW5rUG9zID0gcmFuZ2VzWzBdLmZyb207XG4gICAgICAgIHRoaXMucmFuZ2UgPSByYW5nZXNbMF07XG4gICAgICAgIHRoaXMuZW5kID0gcmFuZ2VzW3Jhbmdlcy5sZW5ndGggLSAxXS50bztcbiAgICAgICAgdGhpcy5yZWFkTmV4dCgpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJlc29sdmVPZmZzZXQob2Zmc2V0LCBhc3NvYykge1xuICAgICAgICBsZXQgcmFuZ2UgPSB0aGlzLnJhbmdlLCBpbmRleCA9IHRoaXMucmFuZ2VJbmRleDtcbiAgICAgICAgbGV0IHBvcyA9IHRoaXMucG9zICsgb2Zmc2V0O1xuICAgICAgICB3aGlsZSAocG9zIDwgcmFuZ2UuZnJvbSkge1xuICAgICAgICAgICAgaWYgKCFpbmRleClcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gdGhpcy5yYW5nZXNbLS1pbmRleF07XG4gICAgICAgICAgICBwb3MgLT0gcmFuZ2UuZnJvbSAtIG5leHQudG87XG4gICAgICAgICAgICByYW5nZSA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGFzc29jIDwgMCA/IHBvcyA+IHJhbmdlLnRvIDogcG9zID49IHJhbmdlLnRvKSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT0gdGhpcy5yYW5nZXMubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGxldCBuZXh0ID0gdGhpcy5yYW5nZXNbKytpbmRleF07XG4gICAgICAgICAgICBwb3MgKz0gbmV4dC5mcm9tIC0gcmFuZ2UudG87XG4gICAgICAgICAgICByYW5nZSA9IG5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjbGlwUG9zKHBvcykge1xuICAgICAgICBpZiAocG9zID49IHRoaXMucmFuZ2UuZnJvbSAmJiBwb3MgPCB0aGlzLnJhbmdlLnRvKVxuICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgZm9yIChsZXQgcmFuZ2Ugb2YgdGhpcy5yYW5nZXMpXG4gICAgICAgICAgICBpZiAocmFuZ2UudG8gPiBwb3MpXG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgubWF4KHBvcywgcmFuZ2UuZnJvbSk7XG4gICAgICAgIHJldHVybiB0aGlzLmVuZDtcbiAgICB9XG4gICAgLyoqXG4gICAgTG9vayBhdCBhIGNvZGUgdW5pdCBuZWFyIHRoZSBzdHJlYW0gcG9zaXRpb24uIGAucGVlaygwKWAgZXF1YWxzXG4gICAgYC5uZXh0YCwgYC5wZWVrKC0xKWAgZ2l2ZXMgeW91IHRoZSBwcmV2aW91cyBjaGFyYWN0ZXIsIGFuZCBzb1xuICAgIG9uLlxuICAgIFxuICAgIE5vdGUgdGhhdCBsb29raW5nIGFyb3VuZCBkdXJpbmcgdG9rZW5pemluZyBjcmVhdGVzIGRlcGVuZGVuY2llc1xuICAgIG9uIHBvdGVudGlhbGx5IGZhci1hd2F5IGNvbnRlbnQsIHdoaWNoIG1heSByZWR1Y2UgdGhlXG4gICAgZWZmZWN0aXZlbmVzcyBpbmNyZW1lbnRhbCBwYXJzaW5n4oCUd2hlbiBsb29raW5nIGZvcndhcmTigJRvciBldmVuXG4gICAgY2F1c2UgaW52YWxpZCByZXBhcnNlcyB3aGVuIGxvb2tpbmcgYmFja3dhcmQgbW9yZSB0aGFuIDI1IGNvZGVcbiAgICB1bml0cywgc2luY2UgdGhlIGxpYnJhcnkgZG9lcyBub3QgdHJhY2sgbG9va2JlaGluZC5cbiAgICAqL1xuICAgIHBlZWsob2Zmc2V0KSB7XG4gICAgICAgIGxldCBpZHggPSB0aGlzLmNodW5rT2ZmICsgb2Zmc2V0LCBwb3MsIHJlc3VsdDtcbiAgICAgICAgaWYgKGlkeCA+PSAwICYmIGlkeCA8IHRoaXMuY2h1bmsubGVuZ3RoKSB7XG4gICAgICAgICAgICBwb3MgPSB0aGlzLnBvcyArIG9mZnNldDtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuY2h1bmsuY2hhckNvZGVBdChpZHgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IHJlc29sdmVkID0gdGhpcy5yZXNvbHZlT2Zmc2V0KG9mZnNldCwgMSk7XG4gICAgICAgICAgICBpZiAocmVzb2x2ZWQgPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICBwb3MgPSByZXNvbHZlZDtcbiAgICAgICAgICAgIGlmIChwb3MgPj0gdGhpcy5jaHVuazJQb3MgJiYgcG9zIDwgdGhpcy5jaHVuazJQb3MgKyB0aGlzLmNodW5rMi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLmNodW5rMi5jaGFyQ29kZUF0KHBvcyAtIHRoaXMuY2h1bmsyUG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBpID0gdGhpcy5yYW5nZUluZGV4LCByYW5nZSA9IHRoaXMucmFuZ2U7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHJhbmdlLnRvIDw9IHBvcylcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UgPSB0aGlzLnJhbmdlc1srK2ldO1xuICAgICAgICAgICAgICAgIHRoaXMuY2h1bmsyID0gdGhpcy5pbnB1dC5jaHVuayh0aGlzLmNodW5rMlBvcyA9IHBvcyk7XG4gICAgICAgICAgICAgICAgaWYgKHBvcyArIHRoaXMuY2h1bmsyLmxlbmd0aCA+IHJhbmdlLnRvKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNodW5rMiA9IHRoaXMuY2h1bmsyLnNsaWNlKDAsIHJhbmdlLnRvIC0gcG9zKTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLmNodW5rMi5jaGFyQ29kZUF0KDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwb3MgPj0gdGhpcy50b2tlbi5sb29rQWhlYWQpXG4gICAgICAgICAgICB0aGlzLnRva2VuLmxvb2tBaGVhZCA9IHBvcyArIDE7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEFjY2VwdCBhIHRva2VuLiBCeSBkZWZhdWx0LCB0aGUgZW5kIG9mIHRoZSB0b2tlbiBpcyBzZXQgdG8gdGhlXG4gICAgY3VycmVudCBzdHJlYW0gcG9zaXRpb24sIGJ1dCB5b3UgY2FuIHBhc3MgYW4gb2Zmc2V0IChyZWxhdGl2ZSB0b1xuICAgIHRoZSBzdHJlYW0gcG9zaXRpb24pIHRvIGNoYW5nZSB0aGF0LlxuICAgICovXG4gICAgYWNjZXB0VG9rZW4odG9rZW4sIGVuZE9mZnNldCA9IDApIHtcbiAgICAgICAgbGV0IGVuZCA9IGVuZE9mZnNldCA/IHRoaXMucmVzb2x2ZU9mZnNldChlbmRPZmZzZXQsIC0xKSA6IHRoaXMucG9zO1xuICAgICAgICBpZiAoZW5kID09IG51bGwgfHwgZW5kIDwgdGhpcy50b2tlbi5zdGFydClcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiVG9rZW4gZW5kIG91dCBvZiBib3VuZHNcIik7XG4gICAgICAgIHRoaXMudG9rZW4udmFsdWUgPSB0b2tlbjtcbiAgICAgICAgdGhpcy50b2tlbi5lbmQgPSBlbmQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEFjY2VwdCBhIHRva2VuIGVuZGluZyBhdCBhIHNwZWNpZmljIGdpdmVuIHBvc2l0aW9uLlxuICAgICovXG4gICAgYWNjZXB0VG9rZW5Ubyh0b2tlbiwgZW5kUG9zKSB7XG4gICAgICAgIHRoaXMudG9rZW4udmFsdWUgPSB0b2tlbjtcbiAgICAgICAgdGhpcy50b2tlbi5lbmQgPSBlbmRQb3M7XG4gICAgfVxuICAgIGdldENodW5rKCkge1xuICAgICAgICBpZiAodGhpcy5wb3MgPj0gdGhpcy5jaHVuazJQb3MgJiYgdGhpcy5wb3MgPCB0aGlzLmNodW5rMlBvcyArIHRoaXMuY2h1bmsyLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IHsgY2h1bmssIGNodW5rUG9zIH0gPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5jaHVuayA9IHRoaXMuY2h1bmsyO1xuICAgICAgICAgICAgdGhpcy5jaHVua1BvcyA9IHRoaXMuY2h1bmsyUG9zO1xuICAgICAgICAgICAgdGhpcy5jaHVuazIgPSBjaHVuaztcbiAgICAgICAgICAgIHRoaXMuY2h1bmsyUG9zID0gY2h1bmtQb3M7XG4gICAgICAgICAgICB0aGlzLmNodW5rT2ZmID0gdGhpcy5wb3MgLSB0aGlzLmNodW5rUG9zO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jaHVuazIgPSB0aGlzLmNodW5rO1xuICAgICAgICAgICAgdGhpcy5jaHVuazJQb3MgPSB0aGlzLmNodW5rUG9zO1xuICAgICAgICAgICAgbGV0IG5leHRDaHVuayA9IHRoaXMuaW5wdXQuY2h1bmsodGhpcy5wb3MpO1xuICAgICAgICAgICAgbGV0IGVuZCA9IHRoaXMucG9zICsgbmV4dENodW5rLmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuY2h1bmsgPSBlbmQgPiB0aGlzLnJhbmdlLnRvID8gbmV4dENodW5rLnNsaWNlKDAsIHRoaXMucmFuZ2UudG8gLSB0aGlzLnBvcykgOiBuZXh0Q2h1bms7XG4gICAgICAgICAgICB0aGlzLmNodW5rUG9zID0gdGhpcy5wb3M7XG4gICAgICAgICAgICB0aGlzLmNodW5rT2ZmID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWFkTmV4dCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2h1bmtPZmYgPj0gdGhpcy5jaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0Q2h1bmsoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNodW5rT2ZmID09IHRoaXMuY2h1bmsubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm5leHQgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5uZXh0ID0gdGhpcy5jaHVuay5jaGFyQ29kZUF0KHRoaXMuY2h1bmtPZmYpO1xuICAgIH1cbiAgICAvKipcbiAgICBNb3ZlIHRoZSBzdHJlYW0gZm9yd2FyZCBOIChkZWZhdWx0cyB0byAxKSBjb2RlIHVuaXRzLiBSZXR1cm5zXG4gICAgdGhlIG5ldyB2YWx1ZSBvZiBbYG5leHRgXSgjbHIuSW5wdXRTdHJlYW0ubmV4dCkuXG4gICAgKi9cbiAgICBhZHZhbmNlKG4gPSAxKSB7XG4gICAgICAgIHRoaXMuY2h1bmtPZmYgKz0gbjtcbiAgICAgICAgd2hpbGUgKHRoaXMucG9zICsgbiA+PSB0aGlzLnJhbmdlLnRvKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yYW5nZUluZGV4ID09IHRoaXMucmFuZ2VzLmxlbmd0aCAtIDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2V0RG9uZSgpO1xuICAgICAgICAgICAgbiAtPSB0aGlzLnJhbmdlLnRvIC0gdGhpcy5wb3M7XG4gICAgICAgICAgICB0aGlzLnJhbmdlID0gdGhpcy5yYW5nZXNbKyt0aGlzLnJhbmdlSW5kZXhdO1xuICAgICAgICAgICAgdGhpcy5wb3MgPSB0aGlzLnJhbmdlLmZyb207XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wb3MgKz0gbjtcbiAgICAgICAgaWYgKHRoaXMucG9zID49IHRoaXMudG9rZW4ubG9va0FoZWFkKVxuICAgICAgICAgICAgdGhpcy50b2tlbi5sb29rQWhlYWQgPSB0aGlzLnBvcyArIDE7XG4gICAgICAgIHJldHVybiB0aGlzLnJlYWROZXh0KCk7XG4gICAgfVxuICAgIHNldERvbmUoKSB7XG4gICAgICAgIHRoaXMucG9zID0gdGhpcy5jaHVua1BvcyA9IHRoaXMuZW5kO1xuICAgICAgICB0aGlzLnJhbmdlID0gdGhpcy5yYW5nZXNbdGhpcy5yYW5nZUluZGV4ID0gdGhpcy5yYW5nZXMubGVuZ3RoIC0gMV07XG4gICAgICAgIHRoaXMuY2h1bmsgPSBcIlwiO1xuICAgICAgICByZXR1cm4gdGhpcy5uZXh0ID0gLTE7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgcmVzZXQocG9zLCB0b2tlbikge1xuICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgICAgIHRva2VuLnN0YXJ0ID0gcG9zO1xuICAgICAgICAgICAgdG9rZW4ubG9va0FoZWFkID0gcG9zICsgMTtcbiAgICAgICAgICAgIHRva2VuLnZhbHVlID0gdG9rZW4uZXh0ZW5kZWQgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudG9rZW4gPSBudWxsVG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucG9zICE9IHBvcykge1xuICAgICAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgICAgICBpZiAocG9zID09IHRoaXMuZW5kKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXREb25lKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAocG9zIDwgdGhpcy5yYW5nZS5mcm9tKVxuICAgICAgICAgICAgICAgIHRoaXMucmFuZ2UgPSB0aGlzLnJhbmdlc1stLXRoaXMucmFuZ2VJbmRleF07XG4gICAgICAgICAgICB3aGlsZSAocG9zID49IHRoaXMucmFuZ2UudG8pXG4gICAgICAgICAgICAgICAgdGhpcy5yYW5nZSA9IHRoaXMucmFuZ2VzWysrdGhpcy5yYW5nZUluZGV4XTtcbiAgICAgICAgICAgIGlmIChwb3MgPj0gdGhpcy5jaHVua1BvcyAmJiBwb3MgPCB0aGlzLmNodW5rUG9zICsgdGhpcy5jaHVuay5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNodW5rT2ZmID0gcG9zIC0gdGhpcy5jaHVua1BvcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY2h1bmsgPSBcIlwiO1xuICAgICAgICAgICAgICAgIHRoaXMuY2h1bmtPZmYgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZWFkTmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHJlYWQoZnJvbSwgdG8pIHtcbiAgICAgICAgaWYgKGZyb20gPj0gdGhpcy5jaHVua1BvcyAmJiB0byA8PSB0aGlzLmNodW5rUG9zICsgdGhpcy5jaHVuay5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaHVuay5zbGljZShmcm9tIC0gdGhpcy5jaHVua1BvcywgdG8gLSB0aGlzLmNodW5rUG9zKTtcbiAgICAgICAgaWYgKGZyb20gPj0gdGhpcy5jaHVuazJQb3MgJiYgdG8gPD0gdGhpcy5jaHVuazJQb3MgKyB0aGlzLmNodW5rMi5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jaHVuazIuc2xpY2UoZnJvbSAtIHRoaXMuY2h1bmsyUG9zLCB0byAtIHRoaXMuY2h1bmsyUG9zKTtcbiAgICAgICAgaWYgKGZyb20gPj0gdGhpcy5yYW5nZS5mcm9tICYmIHRvIDw9IHRoaXMucmFuZ2UudG8pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbnB1dC5yZWFkKGZyb20sIHRvKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIGZvciAobGV0IHIgb2YgdGhpcy5yYW5nZXMpIHtcbiAgICAgICAgICAgIGlmIChyLmZyb20gPj0gdG8pXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAoci50byA+IGZyb20pXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuaW5wdXQucmVhZChNYXRoLm1heChyLmZyb20sIGZyb20pLCBNYXRoLm1pbihyLnRvLCB0bykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuLyoqXG5AaW50ZXJuYWxcbiovXG5jbGFzcyBUb2tlbkdyb3VwIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhLCBpZCkge1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgfVxuICAgIHRva2VuKGlucHV0LCBzdGFjaykge1xuICAgICAgICBsZXQgeyBwYXJzZXIgfSA9IHN0YWNrLnA7XG4gICAgICAgIHJlYWRUb2tlbih0aGlzLmRhdGEsIGlucHV0LCBzdGFjaywgdGhpcy5pZCwgcGFyc2VyLmRhdGEsIHBhcnNlci50b2tlblByZWNUYWJsZSk7XG4gICAgfVxufVxuVG9rZW5Hcm91cC5wcm90b3R5cGUuY29udGV4dHVhbCA9IFRva2VuR3JvdXAucHJvdG90eXBlLmZhbGxiYWNrID0gVG9rZW5Hcm91cC5wcm90b3R5cGUuZXh0ZW5kID0gZmFsc2U7XG4vKipcbkBoaWRlXG4qL1xuY2xhc3MgTG9jYWxUb2tlbkdyb3VwIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhLCBwcmVjVGFibGUsIGVsc2VUb2tlbikge1xuICAgICAgICB0aGlzLnByZWNUYWJsZSA9IHByZWNUYWJsZTtcbiAgICAgICAgdGhpcy5lbHNlVG9rZW4gPSBlbHNlVG9rZW47XG4gICAgICAgIHRoaXMuZGF0YSA9IHR5cGVvZiBkYXRhID09IFwic3RyaW5nXCIgPyBkZWNvZGVBcnJheShkYXRhKSA6IGRhdGE7XG4gICAgfVxuICAgIHRva2VuKGlucHV0LCBzdGFjaykge1xuICAgICAgICBsZXQgc3RhcnQgPSBpbnB1dC5wb3MsIHNraXBwZWQgPSAwO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgYXRFb2YgPSBpbnB1dC5uZXh0IDwgMCwgbmV4dFBvcyA9IGlucHV0LnJlc29sdmVPZmZzZXQoMSwgMSk7XG4gICAgICAgICAgICByZWFkVG9rZW4odGhpcy5kYXRhLCBpbnB1dCwgc3RhY2ssIDAsIHRoaXMuZGF0YSwgdGhpcy5wcmVjVGFibGUpO1xuICAgICAgICAgICAgaWYgKGlucHV0LnRva2VuLnZhbHVlID4gLTEpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAodGhpcy5lbHNlVG9rZW4gPT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAoIWF0RW9mKVxuICAgICAgICAgICAgICAgIHNraXBwZWQrKztcbiAgICAgICAgICAgIGlmIChuZXh0UG9zID09IG51bGwpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpbnB1dC5yZXNldChuZXh0UG9zLCBpbnB1dC50b2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNraXBwZWQpIHtcbiAgICAgICAgICAgIGlucHV0LnJlc2V0KHN0YXJ0LCBpbnB1dC50b2tlbik7XG4gICAgICAgICAgICBpbnB1dC5hY2NlcHRUb2tlbih0aGlzLmVsc2VUb2tlbiwgc2tpcHBlZCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5Mb2NhbFRva2VuR3JvdXAucHJvdG90eXBlLmNvbnRleHR1YWwgPSBUb2tlbkdyb3VwLnByb3RvdHlwZS5mYWxsYmFjayA9IFRva2VuR3JvdXAucHJvdG90eXBlLmV4dGVuZCA9IGZhbHNlO1xuLyoqXG5gQGV4dGVybmFsIHRva2Vuc2AgZGVjbGFyYXRpb25zIGluIHRoZSBncmFtbWFyIHNob3VsZCByZXNvbHZlIHRvXG5hbiBpbnN0YW5jZSBvZiB0aGlzIGNsYXNzLlxuKi9cbmNsYXNzIEV4dGVybmFsVG9rZW5pemVyIHtcbiAgICAvKipcbiAgICBDcmVhdGUgYSB0b2tlbml6ZXIuIFRoZSBmaXJzdCBhcmd1bWVudCBpcyB0aGUgZnVuY3Rpb24gdGhhdCxcbiAgICBnaXZlbiBhbiBpbnB1dCBzdHJlYW0sIHNjYW5zIGZvciB0aGUgdHlwZXMgb2YgdG9rZW5zIGl0XG4gICAgcmVjb2duaXplcyBhdCB0aGUgc3RyZWFtJ3MgcG9zaXRpb24sIGFuZCBjYWxsc1xuICAgIFtgYWNjZXB0VG9rZW5gXSgjbHIuSW5wdXRTdHJlYW0uYWNjZXB0VG9rZW4pIHdoZW4gaXQgZmluZHNcbiAgICBvbmUuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHRva2VuLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgICAgICB0aGlzLmNvbnRleHR1YWwgPSAhIW9wdGlvbnMuY29udGV4dHVhbDtcbiAgICAgICAgdGhpcy5mYWxsYmFjayA9ICEhb3B0aW9ucy5mYWxsYmFjaztcbiAgICAgICAgdGhpcy5leHRlbmQgPSAhIW9wdGlvbnMuZXh0ZW5kO1xuICAgIH1cbn1cbi8vIFRva2VuaXplciBkYXRhIGlzIHN0b3JlZCBhIGJpZyB1aW50MTYgYXJyYXkgY29udGFpbmluZywgZm9yIGVhY2hcbi8vIHN0YXRlOlxuLy9cbi8vICAtIEEgZ3JvdXAgYml0bWFzaywgaW5kaWNhdGluZyB3aGF0IHRva2VuIGdyb3VwcyBhcmUgcmVhY2hhYmxlIGZyb21cbi8vICAgIHRoaXMgc3RhdGUsIHNvIHRoYXQgcGF0aHMgdGhhdCBjYW4gb25seSBsZWFkIHRvIHRva2VucyBub3QgaW5cbi8vICAgIGFueSBvZiB0aGUgY3VycmVudCBncm91cHMgY2FuIGJlIGN1dCBvZmYgZWFybHkuXG4vL1xuLy8gIC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBlbmQgb2YgdGhlIHN0YXRlJ3Mgc2VxdWVuY2Ugb2YgYWNjZXB0aW5nXG4vLyAgICB0b2tlbnNcbi8vXG4vLyAgLSBUaGUgbnVtYmVyIG9mIG91dGdvaW5nIGVkZ2VzIGZvciB0aGUgc3RhdGVcbi8vXG4vLyAgLSBUaGUgYWNjZXB0aW5nIHRva2VucywgYXMgKHRva2VuIGlkLCBncm91cCBtYXNrKSBwYWlyc1xuLy9cbi8vICAtIFRoZSBvdXRnb2luZyBlZGdlcywgYXMgKHN0YXJ0IGNoYXJhY3RlciwgZW5kIGNoYXJhY3Rlciwgc3RhdGVcbi8vICAgIGluZGV4KSB0cmlwbGVzLCB3aXRoIGVuZCBjaGFyYWN0ZXIgYmVpbmcgZXhjbHVzaXZlXG4vL1xuLy8gVGhpcyBmdW5jdGlvbiBpbnRlcnByZXRzIHRoYXQgZGF0YSwgcnVubmluZyB0aHJvdWdoIGEgc3RyZWFtIGFzXG4vLyBsb25nIGFzIG5ldyBzdGF0ZXMgd2l0aCB0aGUgYSBtYXRjaGluZyBncm91cCBtYXNrIGNhbiBiZSByZWFjaGVkLFxuLy8gYW5kIHVwZGF0aW5nIGBpbnB1dC50b2tlbmAgd2hlbiBpdCBtYXRjaGVzIGEgdG9rZW4uXG5mdW5jdGlvbiByZWFkVG9rZW4oZGF0YSwgaW5wdXQsIHN0YWNrLCBncm91cCwgcHJlY1RhYmxlLCBwcmVjT2Zmc2V0KSB7XG4gICAgbGV0IHN0YXRlID0gMCwgZ3JvdXBNYXNrID0gMSA8PCBncm91cCwgeyBkaWFsZWN0IH0gPSBzdGFjay5wLnBhcnNlcjtcbiAgICBzY2FuOiBmb3IgKDs7KSB7XG4gICAgICAgIGlmICgoZ3JvdXBNYXNrICYgZGF0YVtzdGF0ZV0pID09IDApXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgbGV0IGFjY0VuZCA9IGRhdGFbc3RhdGUgKyAxXTtcbiAgICAgICAgLy8gQ2hlY2sgd2hldGhlciB0aGlzIHN0YXRlIGNhbiBsZWFkIHRvIGEgdG9rZW4gaW4gdGhlIGN1cnJlbnQgZ3JvdXBcbiAgICAgICAgLy8gQWNjZXB0IHRva2VucyBpbiB0aGlzIHN0YXRlLCBwb3NzaWJseSBvdmVyd3JpdGluZ1xuICAgICAgICAvLyBsb3dlci1wcmVjZWRlbmNlIC8gc2hvcnRlciB0b2tlbnNcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXRlICsgMzsgaSA8IGFjY0VuZDsgaSArPSAyKVxuICAgICAgICAgICAgaWYgKChkYXRhW2kgKyAxXSAmIGdyb3VwTWFzaykgPiAwKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRlcm0gPSBkYXRhW2ldO1xuICAgICAgICAgICAgICAgIGlmIChkaWFsZWN0LmFsbG93cyh0ZXJtKSAmJlxuICAgICAgICAgICAgICAgICAgICAoaW5wdXQudG9rZW4udmFsdWUgPT0gLTEgfHwgaW5wdXQudG9rZW4udmFsdWUgPT0gdGVybSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcnJpZGVzKHRlcm0sIGlucHV0LnRva2VuLnZhbHVlLCBwcmVjVGFibGUsIHByZWNPZmZzZXQpKSkge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dC5hY2NlcHRUb2tlbih0ZXJtKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICBsZXQgbmV4dCA9IGlucHV0Lm5leHQsIGxvdyA9IDAsIGhpZ2ggPSBkYXRhW3N0YXRlICsgMl07XG4gICAgICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgRU9GXG4gICAgICAgIGlmIChpbnB1dC5uZXh0IDwgMCAmJiBoaWdoID4gbG93ICYmIGRhdGFbYWNjRW5kICsgaGlnaCAqIDMgLSAzXSA9PSA2NTUzNSAvKiBTZXEuRW5kICovKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IGRhdGFbYWNjRW5kICsgaGlnaCAqIDMgLSAxXTtcbiAgICAgICAgICAgIGNvbnRpbnVlIHNjYW47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG8gYSBiaW5hcnkgc2VhcmNoIG9uIHRoZSBzdGF0ZSdzIGVkZ2VzXG4gICAgICAgIGZvciAoOyBsb3cgPCBoaWdoOykge1xuICAgICAgICAgICAgbGV0IG1pZCA9IChsb3cgKyBoaWdoKSA+PiAxO1xuICAgICAgICAgICAgbGV0IGluZGV4ID0gYWNjRW5kICsgbWlkICsgKG1pZCA8PCAxKTtcbiAgICAgICAgICAgIGxldCBmcm9tID0gZGF0YVtpbmRleF0sIHRvID0gZGF0YVtpbmRleCArIDFdIHx8IDB4MTAwMDA7XG4gICAgICAgICAgICBpZiAobmV4dCA8IGZyb20pXG4gICAgICAgICAgICAgICAgaGlnaCA9IG1pZDtcbiAgICAgICAgICAgIGVsc2UgaWYgKG5leHQgPj0gdG8pXG4gICAgICAgICAgICAgICAgbG93ID0gbWlkICsgMTtcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXRlID0gZGF0YVtpbmRleCArIDJdO1xuICAgICAgICAgICAgICAgIGlucHV0LmFkdmFuY2UoKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZSBzY2FuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbmRPZmZzZXQoZGF0YSwgc3RhcnQsIHRlcm0pIHtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQsIG5leHQ7IChuZXh0ID0gZGF0YVtpXSkgIT0gNjU1MzUgLyogU2VxLkVuZCAqLzsgaSsrKVxuICAgICAgICBpZiAobmV4dCA9PSB0ZXJtKVxuICAgICAgICAgICAgcmV0dXJuIGkgLSBzdGFydDtcbiAgICByZXR1cm4gLTE7XG59XG5mdW5jdGlvbiBvdmVycmlkZXModG9rZW4sIHByZXYsIHRhYmxlRGF0YSwgdGFibGVPZmZzZXQpIHtcbiAgICBsZXQgaVByZXYgPSBmaW5kT2Zmc2V0KHRhYmxlRGF0YSwgdGFibGVPZmZzZXQsIHByZXYpO1xuICAgIHJldHVybiBpUHJldiA8IDAgfHwgZmluZE9mZnNldCh0YWJsZURhdGEsIHRhYmxlT2Zmc2V0LCB0b2tlbikgPCBpUHJldjtcbn1cblxuLy8gRW52aXJvbm1lbnQgdmFyaWFibGUgdXNlZCB0byBjb250cm9sIGNvbnNvbGUgb3V0cHV0XG5jb25zdCB2ZXJib3NlID0gdHlwZW9mIHByb2Nlc3MgIT0gXCJ1bmRlZmluZWRcIiAmJiBwcm9jZXNzLmVudiAmJiAvXFxicGFyc2VcXGIvLnRlc3QocHJvY2Vzcy5lbnYuTE9HKTtcbmxldCBzdGFja0lEcyA9IG51bGw7XG5mdW5jdGlvbiBjdXRBdCh0cmVlLCBwb3MsIHNpZGUpIHtcbiAgICBsZXQgY3Vyc29yID0gdHJlZS5jdXJzb3IoSXRlck1vZGUuSW5jbHVkZUFub255bW91cyk7XG4gICAgY3Vyc29yLm1vdmVUbyhwb3MpO1xuICAgIGZvciAoOzspIHtcbiAgICAgICAgaWYgKCEoc2lkZSA8IDAgPyBjdXJzb3IuY2hpbGRCZWZvcmUocG9zKSA6IGN1cnNvci5jaGlsZEFmdGVyKHBvcykpKVxuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIGlmICgoc2lkZSA8IDAgPyBjdXJzb3IudG8gPCBwb3MgOiBjdXJzb3IuZnJvbSA+IHBvcykgJiYgIWN1cnNvci50eXBlLmlzRXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaWRlIDwgMCA/IE1hdGgubWF4KDAsIE1hdGgubWluKGN1cnNvci50byAtIDEsIHBvcyAtIDI1IC8qIExvb2thaGVhZC5NYXJnaW4gKi8pKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBNYXRoLm1pbih0cmVlLmxlbmd0aCwgTWF0aC5tYXgoY3Vyc29yLmZyb20gKyAxLCBwb3MgKyAyNSAvKiBMb29rYWhlYWQuTWFyZ2luICovKSk7XG4gICAgICAgICAgICAgICAgaWYgKHNpZGUgPCAwID8gY3Vyc29yLnByZXZTaWJsaW5nKCkgOiBjdXJzb3IubmV4dFNpYmxpbmcoKSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKCFjdXJzb3IucGFyZW50KCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaWRlIDwgMCA/IDAgOiB0cmVlLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBGcmFnbWVudEN1cnNvciB7XG4gICAgY29uc3RydWN0b3IoZnJhZ21lbnRzLCBub2RlU2V0KSB7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRzID0gZnJhZ21lbnRzO1xuICAgICAgICB0aGlzLm5vZGVTZXQgPSBub2RlU2V0O1xuICAgICAgICB0aGlzLmkgPSAwO1xuICAgICAgICB0aGlzLmZyYWdtZW50ID0gbnVsbDtcbiAgICAgICAgdGhpcy5zYWZlRnJvbSA9IC0xO1xuICAgICAgICB0aGlzLnNhZmVUbyA9IC0xO1xuICAgICAgICB0aGlzLnRyZWVzID0gW107XG4gICAgICAgIHRoaXMuc3RhcnQgPSBbXTtcbiAgICAgICAgdGhpcy5pbmRleCA9IFtdO1xuICAgICAgICB0aGlzLm5leHRGcmFnbWVudCgpO1xuICAgIH1cbiAgICBuZXh0RnJhZ21lbnQoKSB7XG4gICAgICAgIGxldCBmciA9IHRoaXMuZnJhZ21lbnQgPSB0aGlzLmkgPT0gdGhpcy5mcmFnbWVudHMubGVuZ3RoID8gbnVsbCA6IHRoaXMuZnJhZ21lbnRzW3RoaXMuaSsrXTtcbiAgICAgICAgaWYgKGZyKSB7XG4gICAgICAgICAgICB0aGlzLnNhZmVGcm9tID0gZnIub3BlblN0YXJ0ID8gY3V0QXQoZnIudHJlZSwgZnIuZnJvbSArIGZyLm9mZnNldCwgMSkgLSBmci5vZmZzZXQgOiBmci5mcm9tO1xuICAgICAgICAgICAgdGhpcy5zYWZlVG8gPSBmci5vcGVuRW5kID8gY3V0QXQoZnIudHJlZSwgZnIudG8gKyBmci5vZmZzZXQsIC0xKSAtIGZyLm9mZnNldCA6IGZyLnRvO1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMudHJlZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmVlcy5wb3AoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0LnBvcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXgucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRyZWVzLnB1c2goZnIudHJlZSk7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0LnB1c2goLWZyLm9mZnNldCk7XG4gICAgICAgICAgICB0aGlzLmluZGV4LnB1c2goMCk7XG4gICAgICAgICAgICB0aGlzLm5leHRTdGFydCA9IHRoaXMuc2FmZUZyb207XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm5leHRTdGFydCA9IDFlOTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBgcG9zYCBtdXN0IGJlID49IGFueSBwcmV2aW91c2x5IGdpdmVuIGBwb3NgIGZvciB0aGlzIGN1cnNvclxuICAgIG5vZGVBdChwb3MpIHtcbiAgICAgICAgaWYgKHBvcyA8IHRoaXMubmV4dFN0YXJ0KVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHdoaWxlICh0aGlzLmZyYWdtZW50ICYmIHRoaXMuc2FmZVRvIDw9IHBvcylcbiAgICAgICAgICAgIHRoaXMubmV4dEZyYWdtZW50KCk7XG4gICAgICAgIGlmICghdGhpcy5mcmFnbWVudClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBsZXQgbGFzdCA9IHRoaXMudHJlZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGlmIChsYXN0IDwgMCkgeyAvLyBFbmQgb2YgdHJlZVxuICAgICAgICAgICAgICAgIHRoaXMubmV4dEZyYWdtZW50KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgdG9wID0gdGhpcy50cmVlc1tsYXN0XSwgaW5kZXggPSB0aGlzLmluZGV4W2xhc3RdO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IHRvcC5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyZWVzLnBvcCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnQucG9wKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleC5wb3AoKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBuZXh0ID0gdG9wLmNoaWxkcmVuW2luZGV4XTtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IHRoaXMuc3RhcnRbbGFzdF0gKyB0b3AucG9zaXRpb25zW2luZGV4XTtcbiAgICAgICAgICAgIGlmIChzdGFydCA+IHBvcykge1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dFN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmV4dCBpbnN0YW5jZW9mIFRyZWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnQgPT0gcG9zKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFydCA8IHRoaXMuc2FmZUZyb20pXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGVuZCA9IHN0YXJ0ICsgbmV4dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmQgPD0gdGhpcy5zYWZlVG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBsb29rQWhlYWQgPSBuZXh0LnByb3AoTm9kZVByb3AubG9va0FoZWFkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbG9va0FoZWFkIHx8IGVuZCArIGxvb2tBaGVhZCA8IHRoaXMuZnJhZ21lbnQudG8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5pbmRleFtsYXN0XSsrO1xuICAgICAgICAgICAgICAgIGlmIChzdGFydCArIG5leHQubGVuZ3RoID49IE1hdGgubWF4KHRoaXMuc2FmZUZyb20sIHBvcykpIHsgLy8gRW50ZXIgdGhpcyBub2RlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJlZXMucHVzaChuZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydC5wdXNoKHN0YXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbmRleC5wdXNoKDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5kZXhbbGFzdF0rKztcbiAgICAgICAgICAgICAgICB0aGlzLm5leHRTdGFydCA9IHN0YXJ0ICsgbmV4dC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBUb2tlbkNhY2hlIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIsIHN0cmVhbSkge1xuICAgICAgICB0aGlzLnN0cmVhbSA9IHN0cmVhbTtcbiAgICAgICAgdGhpcy50b2tlbnMgPSBbXTtcbiAgICAgICAgdGhpcy5tYWluVG9rZW4gPSBudWxsO1xuICAgICAgICB0aGlzLmFjdGlvbnMgPSBbXTtcbiAgICAgICAgdGhpcy50b2tlbnMgPSBwYXJzZXIudG9rZW5pemVycy5tYXAoXyA9PiBuZXcgQ2FjaGVkVG9rZW4pO1xuICAgIH1cbiAgICBnZXRBY3Rpb25zKHN0YWNrKSB7XG4gICAgICAgIGxldCBhY3Rpb25JbmRleCA9IDA7XG4gICAgICAgIGxldCBtYWluID0gbnVsbDtcbiAgICAgICAgbGV0IHsgcGFyc2VyIH0gPSBzdGFjay5wLCB7IHRva2VuaXplcnMgfSA9IHBhcnNlcjtcbiAgICAgICAgbGV0IG1hc2sgPSBwYXJzZXIuc3RhdGVTbG90KHN0YWNrLnN0YXRlLCAzIC8qIFBhcnNlU3RhdGUuVG9rZW5pemVyTWFzayAqLyk7XG4gICAgICAgIGxldCBjb250ZXh0ID0gc3RhY2suY3VyQ29udGV4dCA/IHN0YWNrLmN1ckNvbnRleHQuaGFzaCA6IDA7XG4gICAgICAgIGxldCBsb29rQWhlYWQgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRva2VuaXplcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICgoKDEgPDwgaSkgJiBtYXNrKSA9PSAwKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgbGV0IHRva2VuaXplciA9IHRva2VuaXplcnNbaV0sIHRva2VuID0gdGhpcy50b2tlbnNbaV07XG4gICAgICAgICAgICBpZiAobWFpbiAmJiAhdG9rZW5pemVyLmZhbGxiYWNrKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHRva2VuaXplci5jb250ZXh0dWFsIHx8IHRva2VuLnN0YXJ0ICE9IHN0YWNrLnBvcyB8fCB0b2tlbi5tYXNrICE9IG1hc2sgfHwgdG9rZW4uY29udGV4dCAhPSBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVDYWNoZWRUb2tlbih0b2tlbiwgdG9rZW5pemVyLCBzdGFjayk7XG4gICAgICAgICAgICAgICAgdG9rZW4ubWFzayA9IG1hc2s7XG4gICAgICAgICAgICAgICAgdG9rZW4uY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodG9rZW4ubG9va0FoZWFkID4gdG9rZW4uZW5kICsgMjUgLyogTG9va2FoZWFkLk1hcmdpbiAqLylcbiAgICAgICAgICAgICAgICBsb29rQWhlYWQgPSBNYXRoLm1heCh0b2tlbi5sb29rQWhlYWQsIGxvb2tBaGVhZCk7XG4gICAgICAgICAgICBpZiAodG9rZW4udmFsdWUgIT0gMCAvKiBUZXJtLkVyciAqLykge1xuICAgICAgICAgICAgICAgIGxldCBzdGFydEluZGV4ID0gYWN0aW9uSW5kZXg7XG4gICAgICAgICAgICAgICAgaWYgKHRva2VuLmV4dGVuZGVkID4gLTEpXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbkluZGV4ID0gdGhpcy5hZGRBY3Rpb25zKHN0YWNrLCB0b2tlbi5leHRlbmRlZCwgdG9rZW4uZW5kLCBhY3Rpb25JbmRleCk7XG4gICAgICAgICAgICAgICAgYWN0aW9uSW5kZXggPSB0aGlzLmFkZEFjdGlvbnMoc3RhY2ssIHRva2VuLnZhbHVlLCB0b2tlbi5lbmQsIGFjdGlvbkluZGV4KTtcbiAgICAgICAgICAgICAgICBpZiAoIXRva2VuaXplci5leHRlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFpbiA9IHRva2VuO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWN0aW9uSW5kZXggPiBzdGFydEluZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHdoaWxlICh0aGlzLmFjdGlvbnMubGVuZ3RoID4gYWN0aW9uSW5kZXgpXG4gICAgICAgICAgICB0aGlzLmFjdGlvbnMucG9wKCk7XG4gICAgICAgIGlmIChsb29rQWhlYWQpXG4gICAgICAgICAgICBzdGFjay5zZXRMb29rQWhlYWQobG9va0FoZWFkKTtcbiAgICAgICAgaWYgKCFtYWluICYmIHN0YWNrLnBvcyA9PSB0aGlzLnN0cmVhbS5lbmQpIHtcbiAgICAgICAgICAgIG1haW4gPSBuZXcgQ2FjaGVkVG9rZW47XG4gICAgICAgICAgICBtYWluLnZhbHVlID0gc3RhY2sucC5wYXJzZXIuZW9mVGVybTtcbiAgICAgICAgICAgIG1haW4uc3RhcnQgPSBtYWluLmVuZCA9IHN0YWNrLnBvcztcbiAgICAgICAgICAgIGFjdGlvbkluZGV4ID0gdGhpcy5hZGRBY3Rpb25zKHN0YWNrLCBtYWluLnZhbHVlLCBtYWluLmVuZCwgYWN0aW9uSW5kZXgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWFpblRva2VuID0gbWFpbjtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWN0aW9ucztcbiAgICB9XG4gICAgZ2V0TWFpblRva2VuKHN0YWNrKSB7XG4gICAgICAgIGlmICh0aGlzLm1haW5Ub2tlbilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1haW5Ub2tlbjtcbiAgICAgICAgbGV0IG1haW4gPSBuZXcgQ2FjaGVkVG9rZW4sIHsgcG9zLCBwIH0gPSBzdGFjaztcbiAgICAgICAgbWFpbi5zdGFydCA9IHBvcztcbiAgICAgICAgbWFpbi5lbmQgPSBNYXRoLm1pbihwb3MgKyAxLCBwLnN0cmVhbS5lbmQpO1xuICAgICAgICBtYWluLnZhbHVlID0gcG9zID09IHAuc3RyZWFtLmVuZCA/IHAucGFyc2VyLmVvZlRlcm0gOiAwIC8qIFRlcm0uRXJyICovO1xuICAgICAgICByZXR1cm4gbWFpbjtcbiAgICB9XG4gICAgdXBkYXRlQ2FjaGVkVG9rZW4odG9rZW4sIHRva2VuaXplciwgc3RhY2spIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5zdHJlYW0uY2xpcFBvcyhzdGFjay5wb3MpO1xuICAgICAgICB0b2tlbml6ZXIudG9rZW4odGhpcy5zdHJlYW0ucmVzZXQoc3RhcnQsIHRva2VuKSwgc3RhY2spO1xuICAgICAgICBpZiAodG9rZW4udmFsdWUgPiAtMSkge1xuICAgICAgICAgICAgbGV0IHsgcGFyc2VyIH0gPSBzdGFjay5wO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJzZXIuc3BlY2lhbGl6ZWQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlci5zcGVjaWFsaXplZFtpXSA9PSB0b2tlbi52YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcmVzdWx0ID0gcGFyc2VyLnNwZWNpYWxpemVyc1tpXSh0aGlzLnN0cmVhbS5yZWFkKHRva2VuLnN0YXJ0LCB0b2tlbi5lbmQpLCBzdGFjayk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPj0gMCAmJiBzdGFjay5wLnBhcnNlci5kaWFsZWN0LmFsbG93cyhyZXN1bHQgPj4gMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocmVzdWx0ICYgMSkgPT0gMCAvKiBTcGVjaWFsaXplLlNwZWNpYWxpemUgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4udmFsdWUgPSByZXN1bHQgPj4gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbi5leHRlbmRlZCA9IHJlc3VsdCA+PiAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0b2tlbi52YWx1ZSA9IDAgLyogVGVybS5FcnIgKi87XG4gICAgICAgICAgICB0b2tlbi5lbmQgPSB0aGlzLnN0cmVhbS5jbGlwUG9zKHN0YXJ0ICsgMSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHV0QWN0aW9uKGFjdGlvbiwgdG9rZW4sIGVuZCwgaW5kZXgpIHtcbiAgICAgICAgLy8gRG9uJ3QgYWRkIGR1cGxpY2F0ZSBhY3Rpb25zXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5kZXg7IGkgKz0gMylcbiAgICAgICAgICAgIGlmICh0aGlzLmFjdGlvbnNbaV0gPT0gYWN0aW9uKVxuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgdGhpcy5hY3Rpb25zW2luZGV4KytdID0gYWN0aW9uO1xuICAgICAgICB0aGlzLmFjdGlvbnNbaW5kZXgrK10gPSB0b2tlbjtcbiAgICAgICAgdGhpcy5hY3Rpb25zW2luZGV4KytdID0gZW5kO1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICAgIGFkZEFjdGlvbnMoc3RhY2ssIHRva2VuLCBlbmQsIGluZGV4KSB7XG4gICAgICAgIGxldCB7IHN0YXRlIH0gPSBzdGFjaywgeyBwYXJzZXIgfSA9IHN0YWNrLnAsIHsgZGF0YSB9ID0gcGFyc2VyO1xuICAgICAgICBmb3IgKGxldCBzZXQgPSAwOyBzZXQgPCAyOyBzZXQrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHBhcnNlci5zdGF0ZVNsb3Qoc3RhdGUsIHNldCA/IDIgLyogUGFyc2VTdGF0ZS5Ta2lwICovIDogMSAvKiBQYXJzZVN0YXRlLkFjdGlvbnMgKi8pOzsgaSArPSAzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFbaV0gPT0gNjU1MzUgLyogU2VxLkVuZCAqLykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVtpICsgMV0gPT0gMSAvKiBTZXEuTmV4dCAqLykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IHBhaXIoZGF0YSwgaSArIDIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID09IDAgJiYgZGF0YVtpICsgMV0gPT0gMiAvKiBTZXEuT3RoZXIgKi8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXggPSB0aGlzLnB1dEFjdGlvbihwYWlyKGRhdGEsIGkgKyAyKSwgdG9rZW4sIGVuZCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFbaV0gPT0gdG9rZW4pXG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gdGhpcy5wdXRBY3Rpb24ocGFpcihkYXRhLCBpICsgMSksIHRva2VuLCBlbmQsIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxufVxuY2xhc3MgUGFyc2Uge1xuICAgIGNvbnN0cnVjdG9yKHBhcnNlciwgaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XG4gICAgICAgIHRoaXMucmFuZ2VzID0gcmFuZ2VzO1xuICAgICAgICB0aGlzLnJlY292ZXJpbmcgPSAwO1xuICAgICAgICB0aGlzLm5leHRTdGFja0lEID0gMHgyNjU0OyAvLyDimZQsIOKZlSwg4pmWLCDimZcsIOKZmCwg4pmZLCDimaAsIOKZoSwg4pmiLCDimaMsIOKZpCwg4pmlLCDimaYsIOKZp1xuICAgICAgICB0aGlzLm1pblN0YWNrUG9zID0gMDtcbiAgICAgICAgdGhpcy5yZXVzZWQgPSBbXTtcbiAgICAgICAgdGhpcy5zdG9wcGVkQXQgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RCaWdSZWR1Y3Rpb25TdGFydCA9IC0xO1xuICAgICAgICB0aGlzLmxhc3RCaWdSZWR1Y3Rpb25TaXplID0gMDtcbiAgICAgICAgdGhpcy5iaWdSZWR1Y3Rpb25Db3VudCA9IDA7XG4gICAgICAgIHRoaXMuc3RyZWFtID0gbmV3IElucHV0U3RyZWFtKGlucHV0LCByYW5nZXMpO1xuICAgICAgICB0aGlzLnRva2VucyA9IG5ldyBUb2tlbkNhY2hlKHBhcnNlciwgdGhpcy5zdHJlYW0pO1xuICAgICAgICB0aGlzLnRvcFRlcm0gPSBwYXJzZXIudG9wWzFdO1xuICAgICAgICBsZXQgeyBmcm9tIH0gPSByYW5nZXNbMF07XG4gICAgICAgIHRoaXMuc3RhY2tzID0gW1N0YWNrLnN0YXJ0KHRoaXMsIHBhcnNlci50b3BbMF0sIGZyb20pXTtcbiAgICAgICAgdGhpcy5mcmFnbWVudHMgPSBmcmFnbWVudHMubGVuZ3RoICYmIHRoaXMuc3RyZWFtLmVuZCAtIGZyb20gPiBwYXJzZXIuYnVmZmVyTGVuZ3RoICogNFxuICAgICAgICAgICAgPyBuZXcgRnJhZ21lbnRDdXJzb3IoZnJhZ21lbnRzLCBwYXJzZXIubm9kZVNldCkgOiBudWxsO1xuICAgIH1cbiAgICBnZXQgcGFyc2VkUG9zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taW5TdGFja1BvcztcbiAgICB9XG4gICAgLy8gTW92ZSB0aGUgcGFyc2VyIGZvcndhcmQuIFRoaXMgd2lsbCBwcm9jZXNzIGFsbCBwYXJzZSBzdGFja3MgYXRcbiAgICAvLyBgdGhpcy5wb3NgIGFuZCB0cnkgdG8gYWR2YW5jZSB0aGVtIHRvIGEgZnVydGhlciBwb3NpdGlvbi4gSWYgbm9cbiAgICAvLyBzdGFjayBmb3Igc3VjaCBhIHBvc2l0aW9uIGlzIGZvdW5kLCBpdCdsbCBzdGFydCBlcnJvci1yZWNvdmVyeS5cbiAgICAvL1xuICAgIC8vIFdoZW4gdGhlIHBhcnNlIGlzIGZpbmlzaGVkLCB0aGlzIHdpbGwgcmV0dXJuIGEgc3ludGF4IHRyZWUuIFdoZW5cbiAgICAvLyBub3QsIGl0IHJldHVybnMgYG51bGxgLlxuICAgIGFkdmFuY2UoKSB7XG4gICAgICAgIGxldCBzdGFja3MgPSB0aGlzLnN0YWNrcywgcG9zID0gdGhpcy5taW5TdGFja1BvcztcbiAgICAgICAgLy8gVGhpcyB3aWxsIGhvbGQgc3RhY2tzIGJleW9uZCBgcG9zYC5cbiAgICAgICAgbGV0IG5ld1N0YWNrcyA9IHRoaXMuc3RhY2tzID0gW107XG4gICAgICAgIGxldCBzdG9wcGVkLCBzdG9wcGVkVG9rZW5zO1xuICAgICAgICAvLyBJZiBhIGxhcmdlIGFtb3VudCBvZiByZWR1Y3Rpb25zIGhhcHBlbmVkIHdpdGggdGhlIHNhbWUgc3RhcnRcbiAgICAgICAgLy8gcG9zaXRpb24sIGZvcmNlIHRoZSBzdGFjayBvdXQgb2YgdGhhdCBwcm9kdWN0aW9uIGluIG9yZGVyIHRvXG4gICAgICAgIC8vIGF2b2lkIGNyZWF0aW5nIGEgdHJlZSB0b28gZGVlcCB0byByZWN1cnNlIHRocm91Z2guXG4gICAgICAgIC8vIChUaGlzIGlzIGFuIHVnbHkga2x1ZGdlLCBiZWNhdXNlIHVuZm9ydHVuYXRlbHkgdGhlcmUgaXMgbm9cbiAgICAgICAgLy8gc3RyYWlnaHRmb3J3YXJkLCBjaGVhcCB3YXkgdG8gY2hlY2sgZm9yIHRoaXMgaGFwcGVuaW5nLCBkdWUgdG9cbiAgICAgICAgLy8gdGhlIGhpc3Rvcnkgb2YgcmVkdWN0aW9ucyBvbmx5IGJlaW5nIGF2YWlsYWJsZSBpbiBhblxuICAgICAgICAvLyBleHBlbnNpdmUtdG8tYWNjZXNzIGZvcm1hdCBpbiB0aGUgc3RhY2sgYnVmZmVycy4pXG4gICAgICAgIGlmICh0aGlzLmJpZ1JlZHVjdGlvbkNvdW50ID4gMzAwIC8qIFJlYy5NYXhMZWZ0QXNzb2NpYXRpdmVSZWR1Y3Rpb25Db3VudCAqLyAmJiBzdGFja3MubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgIGxldCBbc10gPSBzdGFja3M7XG4gICAgICAgICAgICB3aGlsZSAocy5mb3JjZVJlZHVjZSgpICYmIHMuc3RhY2subGVuZ3RoICYmIHMuc3RhY2tbcy5zdGFjay5sZW5ndGggLSAyXSA+PSB0aGlzLmxhc3RCaWdSZWR1Y3Rpb25TdGFydCkgeyB9XG4gICAgICAgICAgICB0aGlzLmJpZ1JlZHVjdGlvbkNvdW50ID0gdGhpcy5sYXN0QmlnUmVkdWN0aW9uU2l6ZSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gS2VlcCBhZHZhbmNpbmcgYW55IHN0YWNrcyBhdCBgcG9zYCB1bnRpbCB0aGV5IGVpdGhlciBtb3ZlXG4gICAgICAgIC8vIGZvcndhcmQgb3IgY2FuJ3QgYmUgYWR2YW5jZWQuIEdhdGhlciBzdGFja3MgdGhhdCBjYW4ndCBiZVxuICAgICAgICAvLyBhZHZhbmNlZCBmdXJ0aGVyIGluIGBzdG9wcGVkYC5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCBzdGFjayA9IHN0YWNrc1tpXTtcbiAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRva2Vucy5tYWluVG9rZW4gPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChzdGFjay5wb3MgPiBwb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3U3RhY2tzLnB1c2goc3RhY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLmFkdmFuY2VTdGFjayhzdGFjaywgbmV3U3RhY2tzLCBzdGFja3MpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzdG9wcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9wcGVkID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9wcGVkVG9rZW5zID0gW107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RvcHBlZC5wdXNoKHN0YWNrKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHRvayA9IHRoaXMudG9rZW5zLmdldE1haW5Ub2tlbihzdGFjayk7XG4gICAgICAgICAgICAgICAgICAgIHN0b3BwZWRUb2tlbnMucHVzaCh0b2sudmFsdWUsIHRvay5lbmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIW5ld1N0YWNrcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCBmaW5pc2hlZCA9IHN0b3BwZWQgJiYgZmluZEZpbmlzaGVkKHN0b3BwZWQpO1xuICAgICAgICAgICAgaWYgKGZpbmlzaGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRmluaXNoIHdpdGggXCIgKyB0aGlzLnN0YWNrSUQoZmluaXNoZWQpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFja1RvVHJlZShmaW5pc2hlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJzZXIuc3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UgJiYgc3RvcHBlZClcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJTdHVjayB3aXRoIHRva2VuIFwiICsgKHRoaXMudG9rZW5zLm1haW5Ub2tlbiA/IHRoaXMucGFyc2VyLmdldE5hbWUodGhpcy50b2tlbnMubWFpblRva2VuLnZhbHVlKSA6IFwibm9uZVwiKSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFwiTm8gcGFyc2UgYXQgXCIgKyBwb3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLnJlY292ZXJpbmcpXG4gICAgICAgICAgICAgICAgdGhpcy5yZWNvdmVyaW5nID0gNSAvKiBSZWMuRGlzdGFuY2UgKi87XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucmVjb3ZlcmluZyAmJiBzdG9wcGVkKSB7XG4gICAgICAgICAgICBsZXQgZmluaXNoZWQgPSB0aGlzLnN0b3BwZWRBdCAhPSBudWxsICYmIHN0b3BwZWRbMF0ucG9zID4gdGhpcy5zdG9wcGVkQXQgPyBzdG9wcGVkWzBdXG4gICAgICAgICAgICAgICAgOiB0aGlzLnJ1blJlY292ZXJ5KHN0b3BwZWQsIHN0b3BwZWRUb2tlbnMsIG5ld1N0YWNrcyk7XG4gICAgICAgICAgICBpZiAoZmluaXNoZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJGb3JjZS1maW5pc2ggXCIgKyB0aGlzLnN0YWNrSUQoZmluaXNoZWQpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdGFja1RvVHJlZShmaW5pc2hlZC5mb3JjZUFsbCgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZWNvdmVyaW5nKSB7XG4gICAgICAgICAgICBsZXQgbWF4UmVtYWluaW5nID0gdGhpcy5yZWNvdmVyaW5nID09IDEgPyAxIDogdGhpcy5yZWNvdmVyaW5nICogMyAvKiBSZWMuTWF4UmVtYWluaW5nUGVyU3RlcCAqLztcbiAgICAgICAgICAgIGlmIChuZXdTdGFja3MubGVuZ3RoID4gbWF4UmVtYWluaW5nKSB7XG4gICAgICAgICAgICAgICAgbmV3U3RhY2tzLnNvcnQoKGEsIGIpID0+IGIuc2NvcmUgLSBhLnNjb3JlKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAobmV3U3RhY2tzLmxlbmd0aCA+IG1heFJlbWFpbmluZylcbiAgICAgICAgICAgICAgICAgICAgbmV3U3RhY2tzLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5ld1N0YWNrcy5zb21lKHMgPT4gcy5yZWR1Y2VQb3MgPiBwb3MpKVxuICAgICAgICAgICAgICAgIHRoaXMucmVjb3ZlcmluZy0tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5ld1N0YWNrcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAvLyBQcnVuZSBzdGFja3MgdGhhdCBhcmUgaW4gdGhlIHNhbWUgc3RhdGUsIG9yIHRoYXQgaGF2ZSBiZWVuXG4gICAgICAgICAgICAvLyBydW5uaW5nIHdpdGhvdXQgc3BsaXR0aW5nIGZvciBhIHdoaWxlLCB0byBhdm9pZCBnZXR0aW5nIHN0dWNrXG4gICAgICAgICAgICAvLyB3aXRoIG11bHRpcGxlIHN1Y2Nlc3NmdWwgc3RhY2tzIHJ1bm5pbmcgZW5kbGVzc2x5IG9uLlxuICAgICAgICAgICAgb3V0ZXI6IGZvciAobGV0IGkgPSAwOyBpIDwgbmV3U3RhY2tzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBzdGFjayA9IG5ld1N0YWNrc1tpXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gaSArIDE7IGogPCBuZXdTdGFja3MubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG90aGVyID0gbmV3U3RhY2tzW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2suc2FtZVN0YXRlKG90aGVyKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2suYnVmZmVyLmxlbmd0aCA+IDUwMCAvKiBSZWMuTWluQnVmZmVyTGVuZ3RoUHJ1bmUgKi8gJiYgb3RoZXIuYnVmZmVyLmxlbmd0aCA+IDUwMCAvKiBSZWMuTWluQnVmZmVyTGVuZ3RoUHJ1bmUgKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoKHN0YWNrLnNjb3JlIC0gb3RoZXIuc2NvcmUpIHx8IChzdGFjay5idWZmZXIubGVuZ3RoIC0gb3RoZXIuYnVmZmVyLmxlbmd0aCkpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1N0YWNrcy5zcGxpY2Uoai0tLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1N0YWNrcy5zcGxpY2UoaS0tLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXdTdGFja3MubGVuZ3RoID4gMTIgLyogUmVjLk1heFN0YWNrQ291bnQgKi8pXG4gICAgICAgICAgICAgICAgbmV3U3RhY2tzLnNwbGljZSgxMiAvKiBSZWMuTWF4U3RhY2tDb3VudCAqLywgbmV3U3RhY2tzLmxlbmd0aCAtIDEyIC8qIFJlYy5NYXhTdGFja0NvdW50ICovKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1pblN0YWNrUG9zID0gbmV3U3RhY2tzWzBdLnBvcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBuZXdTdGFja3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBpZiAobmV3U3RhY2tzW2ldLnBvcyA8IHRoaXMubWluU3RhY2tQb3MpXG4gICAgICAgICAgICAgICAgdGhpcy5taW5TdGFja1BvcyA9IG5ld1N0YWNrc1tpXS5wb3M7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzdG9wQXQocG9zKSB7XG4gICAgICAgIGlmICh0aGlzLnN0b3BwZWRBdCAhPSBudWxsICYmIHRoaXMuc3RvcHBlZEF0IDwgcG9zKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDYW4ndCBtb3ZlIHN0b3BwZWRBdCBmb3J3YXJkXCIpO1xuICAgICAgICB0aGlzLnN0b3BwZWRBdCA9IHBvcztcbiAgICB9XG4gICAgLy8gUmV0dXJucyBhbiB1cGRhdGVkIHZlcnNpb24gb2YgdGhlIGdpdmVuIHN0YWNrLCBvciBudWxsIGlmIHRoZVxuICAgIC8vIHN0YWNrIGNhbid0IGFkdmFuY2Ugbm9ybWFsbHkuIFdoZW4gYHNwbGl0YCBhbmQgYHN0YWNrc2AgYXJlXG4gICAgLy8gZ2l2ZW4sIHN0YWNrcyBzcGxpdCBvZmYgYnkgYW1iaWd1b3VzIG9wZXJhdGlvbnMgd2lsbCBiZSBwdXNoZWQgdG9cbiAgICAvLyBgc3BsaXRgLCBvciBhZGRlZCB0byBgc3RhY2tzYCBpZiB0aGV5IG1vdmUgYHBvc2AgZm9yd2FyZC5cbiAgICBhZHZhbmNlU3RhY2soc3RhY2ssIHN0YWNrcywgc3BsaXQpIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gc3RhY2sucG9zLCB7IHBhcnNlciB9ID0gdGhpcztcbiAgICAgICAgbGV0IGJhc2UgPSB2ZXJib3NlID8gdGhpcy5zdGFja0lEKHN0YWNrKSArIFwiIC0+IFwiIDogXCJcIjtcbiAgICAgICAgaWYgKHRoaXMuc3RvcHBlZEF0ICE9IG51bGwgJiYgc3RhcnQgPiB0aGlzLnN0b3BwZWRBdClcbiAgICAgICAgICAgIHJldHVybiBzdGFjay5mb3JjZVJlZHVjZSgpID8gc3RhY2sgOiBudWxsO1xuICAgICAgICBpZiAodGhpcy5mcmFnbWVudHMpIHtcbiAgICAgICAgICAgIGxldCBzdHJpY3RDeCA9IHN0YWNrLmN1ckNvbnRleHQgJiYgc3RhY2suY3VyQ29udGV4dC50cmFja2VyLnN0cmljdCwgY3hIYXNoID0gc3RyaWN0Q3ggPyBzdGFjay5jdXJDb250ZXh0Lmhhc2ggOiAwO1xuICAgICAgICAgICAgZm9yIChsZXQgY2FjaGVkID0gdGhpcy5mcmFnbWVudHMubm9kZUF0KHN0YXJ0KTsgY2FjaGVkOykge1xuICAgICAgICAgICAgICAgIGxldCBtYXRjaCA9IHRoaXMucGFyc2VyLm5vZGVTZXQudHlwZXNbY2FjaGVkLnR5cGUuaWRdID09IGNhY2hlZC50eXBlID8gcGFyc2VyLmdldEdvdG8oc3RhY2suc3RhdGUsIGNhY2hlZC50eXBlLmlkKSA6IC0xO1xuICAgICAgICAgICAgICAgIGlmIChtYXRjaCA+IC0xICYmIGNhY2hlZC5sZW5ndGggJiYgKCFzdHJpY3RDeCB8fCAoY2FjaGVkLnByb3AoTm9kZVByb3AuY29udGV4dEhhc2gpIHx8IDApID09IGN4SGFzaCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sudXNlTm9kZShjYWNoZWQsIG1hdGNoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhiYXNlICsgdGhpcy5zdGFja0lEKHN0YWNrKSArIGAgKHZpYSByZXVzZSBvZiAke3BhcnNlci5nZXROYW1lKGNhY2hlZC50eXBlLmlkKX0pYCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIShjYWNoZWQgaW5zdGFuY2VvZiBUcmVlKSB8fCBjYWNoZWQuY2hpbGRyZW4ubGVuZ3RoID09IDAgfHwgY2FjaGVkLnBvc2l0aW9uc1swXSA+IDApXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGxldCBpbm5lciA9IGNhY2hlZC5jaGlsZHJlblswXTtcbiAgICAgICAgICAgICAgICBpZiAoaW5uZXIgaW5zdGFuY2VvZiBUcmVlICYmIGNhY2hlZC5wb3NpdGlvbnNbMF0gPT0gMClcbiAgICAgICAgICAgICAgICAgICAgY2FjaGVkID0gaW5uZXI7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgZGVmYXVsdFJlZHVjZSA9IHBhcnNlci5zdGF0ZVNsb3Qoc3RhY2suc3RhdGUsIDQgLyogUGFyc2VTdGF0ZS5EZWZhdWx0UmVkdWNlICovKTtcbiAgICAgICAgaWYgKGRlZmF1bHRSZWR1Y2UgPiAwKSB7XG4gICAgICAgICAgICBzdGFjay5yZWR1Y2UoZGVmYXVsdFJlZHVjZSk7XG4gICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhiYXNlICsgdGhpcy5zdGFja0lEKHN0YWNrKSArIGAgKHZpYSBhbHdheXMtcmVkdWNlICR7cGFyc2VyLmdldE5hbWUoZGVmYXVsdFJlZHVjZSAmIDY1NTM1IC8qIEFjdGlvbi5WYWx1ZU1hc2sgKi8pfSlgKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFjay5zdGFjay5sZW5ndGggPj0gODQwMCAvKiBSZWMuQ3V0RGVwdGggKi8pIHtcbiAgICAgICAgICAgIHdoaWxlIChzdGFjay5zdGFjay5sZW5ndGggPiA2MDAwIC8qIFJlYy5DdXRUbyAqLyAmJiBzdGFjay5mb3JjZVJlZHVjZSgpKSB7IH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgYWN0aW9ucyA9IHRoaXMudG9rZW5zLmdldEFjdGlvbnMoc3RhY2spO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFjdGlvbnMubGVuZ3RoOykge1xuICAgICAgICAgICAgbGV0IGFjdGlvbiA9IGFjdGlvbnNbaSsrXSwgdGVybSA9IGFjdGlvbnNbaSsrXSwgZW5kID0gYWN0aW9uc1tpKytdO1xuICAgICAgICAgICAgbGV0IGxhc3QgPSBpID09IGFjdGlvbnMubGVuZ3RoIHx8ICFzcGxpdDtcbiAgICAgICAgICAgIGxldCBsb2NhbFN0YWNrID0gbGFzdCA/IHN0YWNrIDogc3RhY2suc3BsaXQoKTtcbiAgICAgICAgICAgIGxldCBtYWluID0gdGhpcy50b2tlbnMubWFpblRva2VuO1xuICAgICAgICAgICAgbG9jYWxTdGFjay5hcHBseShhY3Rpb24sIHRlcm0sIG1haW4gPyBtYWluLnN0YXJ0IDogbG9jYWxTdGFjay5wb3MsIGVuZCk7XG4gICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhiYXNlICsgdGhpcy5zdGFja0lEKGxvY2FsU3RhY2spICsgYCAodmlhICR7KGFjdGlvbiAmIDY1NTM2IC8qIEFjdGlvbi5SZWR1Y2VGbGFnICovKSA9PSAwID8gXCJzaGlmdFwiXG4gICAgICAgICAgICAgICAgICAgIDogYHJlZHVjZSBvZiAke3BhcnNlci5nZXROYW1lKGFjdGlvbiAmIDY1NTM1IC8qIEFjdGlvbi5WYWx1ZU1hc2sgKi8pfWB9IGZvciAke3BhcnNlci5nZXROYW1lKHRlcm0pfSBAICR7c3RhcnR9JHtsb2NhbFN0YWNrID09IHN0YWNrID8gXCJcIiA6IFwiLCBzcGxpdFwifSlgKTtcbiAgICAgICAgICAgIGlmIChsYXN0KVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgZWxzZSBpZiAobG9jYWxTdGFjay5wb3MgPiBzdGFydClcbiAgICAgICAgICAgICAgICBzdGFja3MucHVzaChsb2NhbFN0YWNrKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBzcGxpdC5wdXNoKGxvY2FsU3RhY2spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gQWR2YW5jZSBhIGdpdmVuIHN0YWNrIGZvcndhcmQgYXMgZmFyIGFzIGl0IHdpbGwgZ28uIFJldHVybnMgdGhlXG4gICAgLy8gKHBvc3NpYmx5IHVwZGF0ZWQpIHN0YWNrIGlmIGl0IGdvdCBzdHVjaywgb3IgbnVsbCBpZiBpdCBtb3ZlZFxuICAgIC8vIGZvcndhcmQgYW5kIHdhcyBnaXZlbiB0byBgcHVzaFN0YWNrRGVkdXBgLlxuICAgIGFkdmFuY2VGdWxseShzdGFjaywgbmV3U3RhY2tzKSB7XG4gICAgICAgIGxldCBwb3MgPSBzdGFjay5wb3M7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5hZHZhbmNlU3RhY2soc3RhY2ssIG51bGwsIG51bGwpKVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmIChzdGFjay5wb3MgPiBwb3MpIHtcbiAgICAgICAgICAgICAgICBwdXNoU3RhY2tEZWR1cChzdGFjaywgbmV3U3RhY2tzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBydW5SZWNvdmVyeShzdGFja3MsIHRva2VucywgbmV3U3RhY2tzKSB7XG4gICAgICAgIGxldCBmaW5pc2hlZCA9IG51bGwsIHJlc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHN0YWNrID0gc3RhY2tzW2ldLCB0b2tlbiA9IHRva2Vuc1tpIDw8IDFdLCB0b2tlbkVuZCA9IHRva2Vuc1soaSA8PCAxKSArIDFdO1xuICAgICAgICAgICAgbGV0IGJhc2UgPSB2ZXJib3NlID8gdGhpcy5zdGFja0lEKHN0YWNrKSArIFwiIC0+IFwiIDogXCJcIjtcbiAgICAgICAgICAgIGlmIChzdGFjay5kZWFkRW5kKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3RhcnRlZClcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgcmVzdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzdGFjay5yZXN0YXJ0KCk7XG4gICAgICAgICAgICAgICAgaWYgKHZlcmJvc2UpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGJhc2UgKyB0aGlzLnN0YWNrSUQoc3RhY2spICsgXCIgKHJlc3RhcnRlZClcIik7XG4gICAgICAgICAgICAgICAgbGV0IGRvbmUgPSB0aGlzLmFkdmFuY2VGdWxseShzdGFjaywgbmV3U3RhY2tzKTtcbiAgICAgICAgICAgICAgICBpZiAoZG9uZSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZm9yY2UgPSBzdGFjay5zcGxpdCgpLCBmb3JjZUJhc2UgPSBiYXNlO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGZvcmNlLmZvcmNlUmVkdWNlKCkgJiYgaiA8IDEwIC8qIFJlYy5Gb3JjZVJlZHVjZUxpbWl0ICovOyBqKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZm9yY2VCYXNlICsgdGhpcy5zdGFja0lEKGZvcmNlKSArIFwiICh2aWEgZm9yY2UtcmVkdWNlKVwiKTtcbiAgICAgICAgICAgICAgICBsZXQgZG9uZSA9IHRoaXMuYWR2YW5jZUZ1bGx5KGZvcmNlLCBuZXdTdGFja3MpO1xuICAgICAgICAgICAgICAgIGlmIChkb25lKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICAgICAgZm9yY2VCYXNlID0gdGhpcy5zdGFja0lEKGZvcmNlKSArIFwiIC0+IFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaW5zZXJ0IG9mIHN0YWNrLnJlY292ZXJCeUluc2VydCh0b2tlbikpIHtcbiAgICAgICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYmFzZSArIHRoaXMuc3RhY2tJRChpbnNlcnQpICsgXCIgKHZpYSByZWNvdmVyLWluc2VydClcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5hZHZhbmNlRnVsbHkoaW5zZXJ0LCBuZXdTdGFja3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc3RyZWFtLmVuZCA+IHN0YWNrLnBvcykge1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbkVuZCA9PSBzdGFjay5wb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5FbmQrKztcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSAwIC8qIFRlcm0uRXJyICovO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGFjay5yZWNvdmVyQnlEZWxldGUodG9rZW4sIHRva2VuRW5kKTtcbiAgICAgICAgICAgICAgICBpZiAodmVyYm9zZSlcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYmFzZSArIHRoaXMuc3RhY2tJRChzdGFjaykgKyBgICh2aWEgcmVjb3Zlci1kZWxldGUgJHt0aGlzLnBhcnNlci5nZXROYW1lKHRva2VuKX0pYCk7XG4gICAgICAgICAgICAgICAgcHVzaFN0YWNrRGVkdXAoc3RhY2ssIG5ld1N0YWNrcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghZmluaXNoZWQgfHwgZmluaXNoZWQuc2NvcmUgPCBzdGFjay5zY29yZSkge1xuICAgICAgICAgICAgICAgIGZpbmlzaGVkID0gc3RhY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpbmlzaGVkO1xuICAgIH1cbiAgICAvLyBDb252ZXJ0IHRoZSBzdGFjaydzIGJ1ZmZlciB0byBhIHN5bnRheCB0cmVlLlxuICAgIHN0YWNrVG9UcmVlKHN0YWNrKSB7XG4gICAgICAgIHN0YWNrLmNsb3NlKCk7XG4gICAgICAgIHJldHVybiBUcmVlLmJ1aWxkKHsgYnVmZmVyOiBTdGFja0J1ZmZlckN1cnNvci5jcmVhdGUoc3RhY2spLFxuICAgICAgICAgICAgbm9kZVNldDogdGhpcy5wYXJzZXIubm9kZVNldCxcbiAgICAgICAgICAgIHRvcElEOiB0aGlzLnRvcFRlcm0sXG4gICAgICAgICAgICBtYXhCdWZmZXJMZW5ndGg6IHRoaXMucGFyc2VyLmJ1ZmZlckxlbmd0aCxcbiAgICAgICAgICAgIHJldXNlZDogdGhpcy5yZXVzZWQsXG4gICAgICAgICAgICBzdGFydDogdGhpcy5yYW5nZXNbMF0uZnJvbSxcbiAgICAgICAgICAgIGxlbmd0aDogc3RhY2sucG9zIC0gdGhpcy5yYW5nZXNbMF0uZnJvbSxcbiAgICAgICAgICAgIG1pblJlcGVhdFR5cGU6IHRoaXMucGFyc2VyLm1pblJlcGVhdFRlcm0gfSk7XG4gICAgfVxuICAgIHN0YWNrSUQoc3RhY2spIHtcbiAgICAgICAgbGV0IGlkID0gKHN0YWNrSURzIHx8IChzdGFja0lEcyA9IG5ldyBXZWFrTWFwKSkuZ2V0KHN0YWNrKTtcbiAgICAgICAgaWYgKCFpZClcbiAgICAgICAgICAgIHN0YWNrSURzLnNldChzdGFjaywgaWQgPSBTdHJpbmcuZnJvbUNvZGVQb2ludCh0aGlzLm5leHRTdGFja0lEKyspKTtcbiAgICAgICAgcmV0dXJuIGlkICsgc3RhY2s7XG4gICAgfVxufVxuZnVuY3Rpb24gcHVzaFN0YWNrRGVkdXAoc3RhY2ssIG5ld1N0YWNrcykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV3U3RhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBvdGhlciA9IG5ld1N0YWNrc1tpXTtcbiAgICAgICAgaWYgKG90aGVyLnBvcyA9PSBzdGFjay5wb3MgJiYgb3RoZXIuc2FtZVN0YXRlKHN0YWNrKSkge1xuICAgICAgICAgICAgaWYgKG5ld1N0YWNrc1tpXS5zY29yZSA8IHN0YWNrLnNjb3JlKVxuICAgICAgICAgICAgICAgIG5ld1N0YWNrc1tpXSA9IHN0YWNrO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5ld1N0YWNrcy5wdXNoKHN0YWNrKTtcbn1cbmNsYXNzIERpYWxlY3Qge1xuICAgIGNvbnN0cnVjdG9yKHNvdXJjZSwgZmxhZ3MsIGRpc2FibGVkKSB7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgICAgICB0aGlzLmZsYWdzID0gZmxhZ3M7XG4gICAgICAgIHRoaXMuZGlzYWJsZWQgPSBkaXNhYmxlZDtcbiAgICB9XG4gICAgYWxsb3dzKHRlcm0pIHsgcmV0dXJuICF0aGlzLmRpc2FibGVkIHx8IHRoaXMuZGlzYWJsZWRbdGVybV0gPT0gMDsgfVxufVxuY29uc3QgaWQgPSB4ID0+IHg7XG4vKipcbkNvbnRleHQgdHJhY2tlcnMgYXJlIHVzZWQgdG8gdHJhY2sgc3RhdGVmdWwgY29udGV4dCAoc3VjaCBhc1xuaW5kZW50YXRpb24gaW4gdGhlIFB5dGhvbiBncmFtbWFyLCBvciBwYXJlbnQgZWxlbWVudHMgaW4gdGhlIFhNTFxuZ3JhbW1hcikgbmVlZGVkIGJ5IGV4dGVybmFsIHRva2VuaXplcnMuIFlvdSBkZWNsYXJlIHRoZW0gaW4gYVxuZ3JhbW1hciBmaWxlIGFzIGBAY29udGV4dCBleHBvcnROYW1lIGZyb20gXCJtb2R1bGVcImAuXG5cbkNvbnRleHQgdmFsdWVzIHNob3VsZCBiZSBpbW11dGFibGUsIGFuZCBjYW4gYmUgdXBkYXRlZCAocmVwbGFjZWQpXG5vbiBzaGlmdCBvciByZWR1Y2UgYWN0aW9ucy5cblxuVGhlIGV4cG9ydCB1c2VkIGluIGEgYEBjb250ZXh0YCBkZWNsYXJhdGlvbiBzaG91bGQgYmUgb2YgdGhpc1xudHlwZS5cbiovXG5jbGFzcyBDb250ZXh0VHJhY2tlciB7XG4gICAgLyoqXG4gICAgRGVmaW5lIGEgY29udGV4dCB0cmFja2VyLlxuICAgICovXG4gICAgY29uc3RydWN0b3Ioc3BlYykge1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3BlYy5zdGFydDtcbiAgICAgICAgdGhpcy5zaGlmdCA9IHNwZWMuc2hpZnQgfHwgaWQ7XG4gICAgICAgIHRoaXMucmVkdWNlID0gc3BlYy5yZWR1Y2UgfHwgaWQ7XG4gICAgICAgIHRoaXMucmV1c2UgPSBzcGVjLnJldXNlIHx8IGlkO1xuICAgICAgICB0aGlzLmhhc2ggPSBzcGVjLmhhc2ggfHwgKCgpID0+IDApO1xuICAgICAgICB0aGlzLnN0cmljdCA9IHNwZWMuc3RyaWN0ICE9PSBmYWxzZTtcbiAgICB9XG59XG4vKipcbkhvbGRzIHRoZSBwYXJzZSB0YWJsZXMgZm9yIGEgZ2l2ZW4gZ3JhbW1hciwgYXMgZ2VuZXJhdGVkIGJ5XG5gbGV6ZXItZ2VuZXJhdG9yYCwgYW5kIHByb3ZpZGVzIFttZXRob2RzXSgjY29tbW9uLlBhcnNlcikgdG8gcGFyc2VcbmNvbnRlbnQgd2l0aC5cbiovXG5jbGFzcyBMUlBhcnNlciBleHRlbmRzIFBhcnNlciB7XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzcGVjKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy53cmFwcGVycyA9IFtdO1xuICAgICAgICBpZiAoc3BlYy52ZXJzaW9uICE9IDE0IC8qIEZpbGUuVmVyc2lvbiAqLylcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBQYXJzZXIgdmVyc2lvbiAoJHtzcGVjLnZlcnNpb259KSBkb2Vzbid0IG1hdGNoIHJ1bnRpbWUgdmVyc2lvbiAoJHsxNCAvKiBGaWxlLlZlcnNpb24gKi99KWApO1xuICAgICAgICBsZXQgbm9kZU5hbWVzID0gc3BlYy5ub2RlTmFtZXMuc3BsaXQoXCIgXCIpO1xuICAgICAgICB0aGlzLm1pblJlcGVhdFRlcm0gPSBub2RlTmFtZXMubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNwZWMucmVwZWF0Tm9kZUNvdW50OyBpKyspXG4gICAgICAgICAgICBub2RlTmFtZXMucHVzaChcIlwiKTtcbiAgICAgICAgbGV0IHRvcFRlcm1zID0gT2JqZWN0LmtleXMoc3BlYy50b3BSdWxlcykubWFwKHIgPT4gc3BlYy50b3BSdWxlc1tyXVsxXSk7XG4gICAgICAgIGxldCBub2RlUHJvcHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlTmFtZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBub2RlUHJvcHMucHVzaChbXSk7XG4gICAgICAgIGZ1bmN0aW9uIHNldFByb3Aobm9kZUlELCBwcm9wLCB2YWx1ZSkge1xuICAgICAgICAgICAgbm9kZVByb3BzW25vZGVJRF0ucHVzaChbcHJvcCwgcHJvcC5kZXNlcmlhbGl6ZShTdHJpbmcodmFsdWUpKV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzcGVjLm5vZGVQcm9wcylcbiAgICAgICAgICAgIGZvciAobGV0IHByb3BTcGVjIG9mIHNwZWMubm9kZVByb3BzKSB7XG4gICAgICAgICAgICAgICAgbGV0IHByb3AgPSBwcm9wU3BlY1swXTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHByb3AgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICAgICAgcHJvcCA9IE5vZGVQcm9wW3Byb3BdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcHJvcFNwZWMubGVuZ3RoOykge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IHByb3BTcGVjW2krK107XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFByb3AobmV4dCwgcHJvcCwgcHJvcFNwZWNbaSsrXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBwcm9wU3BlY1tpICsgLW5leHRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IC1uZXh0OyBqID4gMDsgai0tKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFByb3AocHJvcFNwZWNbaSsrXSwgcHJvcCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB0aGlzLm5vZGVTZXQgPSBuZXcgTm9kZVNldChub2RlTmFtZXMubWFwKChuYW1lLCBpKSA9PiBOb2RlVHlwZS5kZWZpbmUoe1xuICAgICAgICAgICAgbmFtZTogaSA+PSB0aGlzLm1pblJlcGVhdFRlcm0gPyB1bmRlZmluZWQgOiBuYW1lLFxuICAgICAgICAgICAgaWQ6IGksXG4gICAgICAgICAgICBwcm9wczogbm9kZVByb3BzW2ldLFxuICAgICAgICAgICAgdG9wOiB0b3BUZXJtcy5pbmRleE9mKGkpID4gLTEsXG4gICAgICAgICAgICBlcnJvcjogaSA9PSAwLFxuICAgICAgICAgICAgc2tpcHBlZDogc3BlYy5za2lwcGVkTm9kZXMgJiYgc3BlYy5za2lwcGVkTm9kZXMuaW5kZXhPZihpKSA+IC0xXG4gICAgICAgIH0pKSk7XG4gICAgICAgIGlmIChzcGVjLnByb3BTb3VyY2VzKVxuICAgICAgICAgICAgdGhpcy5ub2RlU2V0ID0gdGhpcy5ub2RlU2V0LmV4dGVuZCguLi5zcGVjLnByb3BTb3VyY2VzKTtcbiAgICAgICAgdGhpcy5zdHJpY3QgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5idWZmZXJMZW5ndGggPSBEZWZhdWx0QnVmZmVyTGVuZ3RoO1xuICAgICAgICBsZXQgdG9rZW5BcnJheSA9IGRlY29kZUFycmF5KHNwZWMudG9rZW5EYXRhKTtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gc3BlYy5jb250ZXh0O1xuICAgICAgICB0aGlzLnNwZWNpYWxpemVyU3BlY3MgPSBzcGVjLnNwZWNpYWxpemVkIHx8IFtdO1xuICAgICAgICB0aGlzLnNwZWNpYWxpemVkID0gbmV3IFVpbnQxNkFycmF5KHRoaXMuc3BlY2lhbGl6ZXJTcGVjcy5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc3BlY2lhbGl6ZXJTcGVjcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHRoaXMuc3BlY2lhbGl6ZWRbaV0gPSB0aGlzLnNwZWNpYWxpemVyU3BlY3NbaV0udGVybTtcbiAgICAgICAgdGhpcy5zcGVjaWFsaXplcnMgPSB0aGlzLnNwZWNpYWxpemVyU3BlY3MubWFwKGdldFNwZWNpYWxpemVyKTtcbiAgICAgICAgdGhpcy5zdGF0ZXMgPSBkZWNvZGVBcnJheShzcGVjLnN0YXRlcywgVWludDMyQXJyYXkpO1xuICAgICAgICB0aGlzLmRhdGEgPSBkZWNvZGVBcnJheShzcGVjLnN0YXRlRGF0YSk7XG4gICAgICAgIHRoaXMuZ290byA9IGRlY29kZUFycmF5KHNwZWMuZ290byk7XG4gICAgICAgIHRoaXMubWF4VGVybSA9IHNwZWMubWF4VGVybTtcbiAgICAgICAgdGhpcy50b2tlbml6ZXJzID0gc3BlYy50b2tlbml6ZXJzLm1hcCh2YWx1ZSA9PiB0eXBlb2YgdmFsdWUgPT0gXCJudW1iZXJcIiA/IG5ldyBUb2tlbkdyb3VwKHRva2VuQXJyYXksIHZhbHVlKSA6IHZhbHVlKTtcbiAgICAgICAgdGhpcy50b3BSdWxlcyA9IHNwZWMudG9wUnVsZXM7XG4gICAgICAgIHRoaXMuZGlhbGVjdHMgPSBzcGVjLmRpYWxlY3RzIHx8IHt9O1xuICAgICAgICB0aGlzLmR5bmFtaWNQcmVjZWRlbmNlcyA9IHNwZWMuZHluYW1pY1ByZWNlZGVuY2VzIHx8IG51bGw7XG4gICAgICAgIHRoaXMudG9rZW5QcmVjVGFibGUgPSBzcGVjLnRva2VuUHJlYztcbiAgICAgICAgdGhpcy50ZXJtTmFtZXMgPSBzcGVjLnRlcm1OYW1lcyB8fCBudWxsO1xuICAgICAgICB0aGlzLm1heE5vZGUgPSB0aGlzLm5vZGVTZXQudHlwZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgdGhpcy5kaWFsZWN0ID0gdGhpcy5wYXJzZURpYWxlY3QoKTtcbiAgICAgICAgdGhpcy50b3AgPSB0aGlzLnRvcFJ1bGVzW09iamVjdC5rZXlzKHRoaXMudG9wUnVsZXMpWzBdXTtcbiAgICB9XG4gICAgY3JlYXRlUGFyc2UoaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgIGxldCBwYXJzZSA9IG5ldyBQYXJzZSh0aGlzLCBpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpO1xuICAgICAgICBmb3IgKGxldCB3IG9mIHRoaXMud3JhcHBlcnMpXG4gICAgICAgICAgICBwYXJzZSA9IHcocGFyc2UsIGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcyk7XG4gICAgICAgIHJldHVybiBwYXJzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IGEgZ290byB0YWJsZSBlbnRyeSBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGdldEdvdG8oc3RhdGUsIHRlcm0sIGxvb3NlID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IHRhYmxlID0gdGhpcy5nb3RvO1xuICAgICAgICBpZiAodGVybSA+PSB0YWJsZVswXSlcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gdGFibGVbdGVybSArIDFdOzspIHtcbiAgICAgICAgICAgIGxldCBncm91cFRhZyA9IHRhYmxlW3BvcysrXSwgbGFzdCA9IGdyb3VwVGFnICYgMTtcbiAgICAgICAgICAgIGxldCB0YXJnZXQgPSB0YWJsZVtwb3MrK107XG4gICAgICAgICAgICBpZiAobGFzdCAmJiBsb29zZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICAgICAgZm9yIChsZXQgZW5kID0gcG9zICsgKGdyb3VwVGFnID4+IDEpOyBwb3MgPCBlbmQ7IHBvcysrKVxuICAgICAgICAgICAgICAgIGlmICh0YWJsZVtwb3NdID09IHN0YXRlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICAgICAgaWYgKGxhc3QpXG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIENoZWNrIGlmIHRoaXMgc3RhdGUgaGFzIGFuIGFjdGlvbiBmb3IgYSBnaXZlbiB0ZXJtaW5hbCBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGhhc0FjdGlvbihzdGF0ZSwgdGVybWluYWwpIHtcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgIGZvciAobGV0IHNldCA9IDA7IHNldCA8IDI7IHNldCsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5zdGF0ZVNsb3Qoc3RhdGUsIHNldCA/IDIgLyogUGFyc2VTdGF0ZS5Ta2lwICovIDogMSAvKiBQYXJzZVN0YXRlLkFjdGlvbnMgKi8pLCBuZXh0OzsgaSArPSAzKSB7XG4gICAgICAgICAgICAgICAgaWYgKChuZXh0ID0gZGF0YVtpXSkgPT0gNjU1MzUgLyogU2VxLkVuZCAqLykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVtpICsgMV0gPT0gMSAvKiBTZXEuTmV4dCAqLylcbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHQgPSBkYXRhW2kgPSBwYWlyKGRhdGEsIGkgKyAyKV07XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRhdGFbaSArIDFdID09IDIgLyogU2VxLk90aGVyICovKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhaXIoZGF0YSwgaSArIDIpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5leHQgPT0gdGVybWluYWwgfHwgbmV4dCA9PSAwIC8qIFRlcm0uRXJyICovKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFpcihkYXRhLCBpICsgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc3RhdGVTbG90KHN0YXRlLCBzbG90KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlc1soc3RhdGUgKiA2IC8qIFBhcnNlU3RhdGUuU2l6ZSAqLykgKyBzbG90XTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0ZUZsYWcoc3RhdGUsIGZsYWcpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnN0YXRlU2xvdChzdGF0ZSwgMCAvKiBQYXJzZVN0YXRlLkZsYWdzICovKSAmIGZsYWcpID4gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB2YWxpZEFjdGlvbihzdGF0ZSwgYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuYWxsQWN0aW9ucyhzdGF0ZSwgYSA9PiBhID09IGFjdGlvbiA/IHRydWUgOiBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBhbGxBY3Rpb25zKHN0YXRlLCBhY3Rpb24pIHtcbiAgICAgICAgbGV0IGRlZmx0ID0gdGhpcy5zdGF0ZVNsb3Qoc3RhdGUsIDQgLyogUGFyc2VTdGF0ZS5EZWZhdWx0UmVkdWNlICovKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IGRlZmx0ID8gYWN0aW9uKGRlZmx0KSA6IHVuZGVmaW5lZDtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuc3RhdGVTbG90KHN0YXRlLCAxIC8qIFBhcnNlU3RhdGUuQWN0aW9ucyAqLyk7IHJlc3VsdCA9PSBudWxsOyBpICs9IDMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGFbaV0gPT0gNjU1MzUgLyogU2VxLkVuZCAqLykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmRhdGFbaSArIDFdID09IDEgLyogU2VxLk5leHQgKi8pXG4gICAgICAgICAgICAgICAgICAgIGkgPSBwYWlyKHRoaXMuZGF0YSwgaSArIDIpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN1bHQgPSBhY3Rpb24ocGFpcih0aGlzLmRhdGEsIGkgKyAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBzdGF0ZXMgdGhhdCBjYW4gZm9sbG93IHRoaXMgb25lIHRocm91Z2ggc2hpZnQgYWN0aW9ucyBvclxuICAgIGdvdG8ganVtcHMuIEBpbnRlcm5hbFxuICAgICovXG4gICAgbmV4dFN0YXRlcyhzdGF0ZSkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLnN0YXRlU2xvdChzdGF0ZSwgMSAvKiBQYXJzZVN0YXRlLkFjdGlvbnMgKi8pOzsgaSArPSAzKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhW2ldID09IDY1NTM1IC8qIFNlcS5FbmQgKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kYXRhW2kgKyAxXSA9PSAxIC8qIFNlcS5OZXh0ICovKVxuICAgICAgICAgICAgICAgICAgICBpID0gcGFpcih0aGlzLmRhdGEsIGkgKyAyKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCh0aGlzLmRhdGFbaSArIDJdICYgKDY1NTM2IC8qIEFjdGlvbi5SZWR1Y2VGbGFnICovID4+IDE2KSkgPT0gMCkge1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZSA9IHRoaXMuZGF0YVtpICsgMV07XG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQuc29tZSgodiwgaSkgPT4gKGkgJiAxKSAmJiB2ID09IHZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5kYXRhW2ldLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29uZmlndXJlIHRoZSBwYXJzZXIuIFJldHVybnMgYSBuZXcgcGFyc2VyIGluc3RhbmNlIHRoYXQgaGFzIHRoZVxuICAgIGdpdmVuIHNldHRpbmdzIG1vZGlmaWVkLiBTZXR0aW5ncyBub3QgcHJvdmlkZWQgaW4gYGNvbmZpZ2AgYXJlXG4gICAga2VwdCBmcm9tIHRoZSBvcmlnaW5hbCBwYXJzZXIuXG4gICAgKi9cbiAgICBjb25maWd1cmUoY29uZmlnKSB7XG4gICAgICAgIC8vIEhpZGVvdXMgcmVmbGVjdGlvbi1iYXNlZCBrbHVkZ2UgdG8gbWFrZSBpdCBlYXN5IHRvIGNyZWF0ZSBhXG4gICAgICAgIC8vIHNsaWdodGx5IG1vZGlmaWVkIGNvcHkgb2YgYSBwYXJzZXIuXG4gICAgICAgIGxldCBjb3B5ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKExSUGFyc2VyLnByb3RvdHlwZSksIHRoaXMpO1xuICAgICAgICBpZiAoY29uZmlnLnByb3BzKVxuICAgICAgICAgICAgY29weS5ub2RlU2V0ID0gdGhpcy5ub2RlU2V0LmV4dGVuZCguLi5jb25maWcucHJvcHMpO1xuICAgICAgICBpZiAoY29uZmlnLnRvcCkge1xuICAgICAgICAgICAgbGV0IGluZm8gPSB0aGlzLnRvcFJ1bGVzW2NvbmZpZy50b3BdO1xuICAgICAgICAgICAgaWYgKCFpbmZvKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGBJbnZhbGlkIHRvcCBydWxlIG5hbWUgJHtjb25maWcudG9wfWApO1xuICAgICAgICAgICAgY29weS50b3AgPSBpbmZvO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25maWcudG9rZW5pemVycylcbiAgICAgICAgICAgIGNvcHkudG9rZW5pemVycyA9IHRoaXMudG9rZW5pemVycy5tYXAodCA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gY29uZmlnLnRva2VuaXplcnMuZmluZChyID0+IHIuZnJvbSA9PSB0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm91bmQgPyBmb3VuZC50byA6IHQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgaWYgKGNvbmZpZy5zcGVjaWFsaXplcnMpIHtcbiAgICAgICAgICAgIGNvcHkuc3BlY2lhbGl6ZXJzID0gdGhpcy5zcGVjaWFsaXplcnMuc2xpY2UoKTtcbiAgICAgICAgICAgIGNvcHkuc3BlY2lhbGl6ZXJTcGVjcyA9IHRoaXMuc3BlY2lhbGl6ZXJTcGVjcy5tYXAoKHMsIGkpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBjb25maWcuc3BlY2lhbGl6ZXJzLmZpbmQociA9PiByLmZyb20gPT0gcy5leHRlcm5hbCk7XG4gICAgICAgICAgICAgICAgaWYgKCFmb3VuZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgICAgICAgICAgbGV0IHNwZWMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHMpLCB7IGV4dGVybmFsOiBmb3VuZC50byB9KTtcbiAgICAgICAgICAgICAgICBjb3B5LnNwZWNpYWxpemVyc1tpXSA9IGdldFNwZWNpYWxpemVyKHNwZWMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBzcGVjO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZy5jb250ZXh0VHJhY2tlcilcbiAgICAgICAgICAgIGNvcHkuY29udGV4dCA9IGNvbmZpZy5jb250ZXh0VHJhY2tlcjtcbiAgICAgICAgaWYgKGNvbmZpZy5kaWFsZWN0KVxuICAgICAgICAgICAgY29weS5kaWFsZWN0ID0gdGhpcy5wYXJzZURpYWxlY3QoY29uZmlnLmRpYWxlY3QpO1xuICAgICAgICBpZiAoY29uZmlnLnN0cmljdCAhPSBudWxsKVxuICAgICAgICAgICAgY29weS5zdHJpY3QgPSBjb25maWcuc3RyaWN0O1xuICAgICAgICBpZiAoY29uZmlnLndyYXApXG4gICAgICAgICAgICBjb3B5LndyYXBwZXJzID0gY29weS53cmFwcGVycy5jb25jYXQoY29uZmlnLndyYXApO1xuICAgICAgICBpZiAoY29uZmlnLmJ1ZmZlckxlbmd0aCAhPSBudWxsKVxuICAgICAgICAgICAgY29weS5idWZmZXJMZW5ndGggPSBjb25maWcuYnVmZmVyTGVuZ3RoO1xuICAgICAgICByZXR1cm4gY29weTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGVsbHMgeW91IHdoZXRoZXIgYW55IFtwYXJzZSB3cmFwcGVyc10oI2xyLlBhcnNlckNvbmZpZy53cmFwKVxuICAgIGFyZSByZWdpc3RlcmVkIGZvciB0aGlzIHBhcnNlci5cbiAgICAqL1xuICAgIGhhc1dyYXBwZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53cmFwcGVycy5sZW5ndGggPiAwO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIHRoZSBuYW1lIGFzc29jaWF0ZWQgd2l0aCBhIGdpdmVuIHRlcm0uIFRoaXMgd2lsbCBvbmx5XG4gICAgd29yayBmb3IgYWxsIHRlcm1zIHdoZW4gdGhlIHBhcnNlciB3YXMgZ2VuZXJhdGVkIHdpdGggdGhlXG4gICAgYC0tbmFtZXNgIG9wdGlvbi4gQnkgZGVmYXVsdCwgb25seSB0aGUgbmFtZXMgb2YgdGFnZ2VkIHRlcm1zIGFyZVxuICAgIHN0b3JlZC5cbiAgICAqL1xuICAgIGdldE5hbWUodGVybSkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXJtTmFtZXMgPyB0aGlzLnRlcm1OYW1lc1t0ZXJtXSA6IFN0cmluZyh0ZXJtIDw9IHRoaXMubWF4Tm9kZSAmJiB0aGlzLm5vZGVTZXQudHlwZXNbdGVybV0ubmFtZSB8fCB0ZXJtKTtcbiAgICB9XG4gICAgLyoqXG4gICAgVGhlIGVvZiB0ZXJtIGlkIGlzIGFsd2F5cyBhbGxvY2F0ZWQgZGlyZWN0bHkgYWZ0ZXIgdGhlIG5vZGVcbiAgICB0eXBlcy4gQGludGVybmFsXG4gICAgKi9cbiAgICBnZXQgZW9mVGVybSgpIHsgcmV0dXJuIHRoaXMubWF4Tm9kZSArIDE7IH1cbiAgICAvKipcbiAgICBUaGUgdHlwZSBvZiB0b3Agbm9kZSBwcm9kdWNlZCBieSB0aGUgcGFyc2VyLlxuICAgICovXG4gICAgZ2V0IHRvcE5vZGUoKSB7IHJldHVybiB0aGlzLm5vZGVTZXQudHlwZXNbdGhpcy50b3BbMV1dOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBkeW5hbWljUHJlY2VkZW5jZSh0ZXJtKSB7XG4gICAgICAgIGxldCBwcmVjID0gdGhpcy5keW5hbWljUHJlY2VkZW5jZXM7XG4gICAgICAgIHJldHVybiBwcmVjID09IG51bGwgPyAwIDogcHJlY1t0ZXJtXSB8fCAwO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHBhcnNlRGlhbGVjdChkaWFsZWN0KSB7XG4gICAgICAgIGxldCB2YWx1ZXMgPSBPYmplY3Qua2V5cyh0aGlzLmRpYWxlY3RzKSwgZmxhZ3MgPSB2YWx1ZXMubWFwKCgpID0+IGZhbHNlKTtcbiAgICAgICAgaWYgKGRpYWxlY3QpXG4gICAgICAgICAgICBmb3IgKGxldCBwYXJ0IG9mIGRpYWxlY3Quc3BsaXQoXCIgXCIpKSB7XG4gICAgICAgICAgICAgICAgbGV0IGlkID0gdmFsdWVzLmluZGV4T2YocGFydCk7XG4gICAgICAgICAgICAgICAgaWYgKGlkID49IDApXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzW2lkXSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIGxldCBkaXNhYmxlZCA9IG51bGw7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgaWYgKCFmbGFnc1tpXSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSB0aGlzLmRpYWxlY3RzW3ZhbHVlc1tpXV0sIGlkOyAoaWQgPSB0aGlzLmRhdGFbaisrXSkgIT0gNjU1MzUgLyogU2VxLkVuZCAqLzspXG4gICAgICAgICAgICAgICAgICAgIChkaXNhYmxlZCB8fCAoZGlzYWJsZWQgPSBuZXcgVWludDhBcnJheSh0aGlzLm1heFRlcm0gKyAxKSkpW2lkXSA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRGlhbGVjdChkaWFsZWN0LCBmbGFncywgZGlzYWJsZWQpO1xuICAgIH1cbiAgICAvKipcbiAgICBVc2VkIGJ5IHRoZSBvdXRwdXQgb2YgdGhlIHBhcnNlciBnZW5lcmF0b3IuIE5vdCBhdmFpbGFibGUgdG9cbiAgICB1c2VyIGNvZGUuIEBoaWRlXG4gICAgKi9cbiAgICBzdGF0aWMgZGVzZXJpYWxpemUoc3BlYykge1xuICAgICAgICByZXR1cm4gbmV3IExSUGFyc2VyKHNwZWMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBhaXIoZGF0YSwgb2ZmKSB7IHJldHVybiBkYXRhW29mZl0gfCAoZGF0YVtvZmYgKyAxXSA8PCAxNik7IH1cbmZ1bmN0aW9uIGZpbmRGaW5pc2hlZChzdGFja3MpIHtcbiAgICBsZXQgYmVzdCA9IG51bGw7XG4gICAgZm9yIChsZXQgc3RhY2sgb2Ygc3RhY2tzKSB7XG4gICAgICAgIGxldCBzdG9wcGVkID0gc3RhY2sucC5zdG9wcGVkQXQ7XG4gICAgICAgIGlmICgoc3RhY2sucG9zID09IHN0YWNrLnAuc3RyZWFtLmVuZCB8fCBzdG9wcGVkICE9IG51bGwgJiYgc3RhY2sucG9zID4gc3RvcHBlZCkgJiZcbiAgICAgICAgICAgIHN0YWNrLnAucGFyc2VyLnN0YXRlRmxhZyhzdGFjay5zdGF0ZSwgMiAvKiBTdGF0ZUZsYWcuQWNjZXB0aW5nICovKSAmJlxuICAgICAgICAgICAgKCFiZXN0IHx8IGJlc3Quc2NvcmUgPCBzdGFjay5zY29yZSkpXG4gICAgICAgICAgICBiZXN0ID0gc3RhY2s7XG4gICAgfVxuICAgIHJldHVybiBiZXN0O1xufVxuZnVuY3Rpb24gZ2V0U3BlY2lhbGl6ZXIoc3BlYykge1xuICAgIGlmIChzcGVjLmV4dGVybmFsKSB7XG4gICAgICAgIGxldCBtYXNrID0gc3BlYy5leHRlbmQgPyAxIC8qIFNwZWNpYWxpemUuRXh0ZW5kICovIDogMCAvKiBTcGVjaWFsaXplLlNwZWNpYWxpemUgKi87XG4gICAgICAgIHJldHVybiAodmFsdWUsIHN0YWNrKSA9PiAoc3BlYy5leHRlcm5hbCh2YWx1ZSwgc3RhY2spIDw8IDEpIHwgbWFzaztcbiAgICB9XG4gICAgcmV0dXJuIHNwZWMuZ2V0O1xufVxuXG5leHBvcnQgeyBDb250ZXh0VHJhY2tlciwgRXh0ZXJuYWxUb2tlbml6ZXIsIElucHV0U3RyZWFtLCBMUlBhcnNlciwgTG9jYWxUb2tlbkdyb3VwLCBTdGFjayB9O1xuIl0sIm5hbWVzIjpbIlBhcnNlciIsIk5vZGVQcm9wIiwiTm9kZVNldCIsIk5vZGVUeXBlIiwiRGVmYXVsdEJ1ZmZlckxlbmd0aCIsIlRyZWUiLCJJdGVyTW9kZSIsIlN0YWNrIiwiY29uc3RydWN0b3IiLCJwIiwic3RhY2siLCJzdGF0ZSIsInJlZHVjZVBvcyIsInBvcyIsInNjb3JlIiwiYnVmZmVyIiwiYnVmZmVyQmFzZSIsImN1ckNvbnRleHQiLCJsb29rQWhlYWQiLCJwYXJlbnQiLCJ0b1N0cmluZyIsImZpbHRlciIsIl8iLCJpIiwiY29uY2F0Iiwic3RhcnQiLCJjeCIsInBhcnNlciIsImNvbnRleHQiLCJTdGFja0NvbnRleHQiLCJwdXNoU3RhdGUiLCJwdXNoIiwibGVuZ3RoIiwicmVkdWNlIiwiYWN0aW9uIiwiX2EiLCJkZXB0aCIsInR5cGUiLCJzZXRMb29rQWhlYWQiLCJkUHJlYyIsImR5bmFtaWNQcmVjZWRlbmNlIiwiZ2V0R290byIsIm1pblJlcGVhdFRlcm0iLCJzdG9yZU5vZGUiLCJyZWR1Y2VDb250ZXh0IiwiYmFzZSIsInJhbmdlcyIsImZyb20iLCJzaXplIiwibm9kZVNldCIsInR5cGVzIiwiaXNBbm9ueW1vdXMiLCJsYXN0QmlnUmVkdWN0aW9uU3RhcnQiLCJiaWdSZWR1Y3Rpb25Db3VudCIsImxhc3RCaWdSZWR1Y3Rpb25TaXplIiwiY291bnQiLCJzdGF0ZUZsYWciLCJiYXNlU3RhdGVJRCIsInBvcCIsInRlcm0iLCJlbmQiLCJpc1JlZHVjZSIsImN1ciIsInRvcCIsImluZGV4Iiwic2hpZnQiLCJuZXh0U3RhdGUiLCJtYXhOb2RlIiwic2hpZnRDb250ZXh0IiwiYXBwbHkiLCJuZXh0IiwibmV4dFN0YXJ0IiwibmV4dEVuZCIsInVzZU5vZGUiLCJ2YWx1ZSIsInJldXNlZCIsInVwZGF0ZUNvbnRleHQiLCJ0cmFja2VyIiwicmV1c2UiLCJzdHJlYW0iLCJyZXNldCIsInNwbGl0Iiwib2ZmIiwic2xpY2UiLCJyZWNvdmVyQnlEZWxldGUiLCJpc05vZGUiLCJjYW5TaGlmdCIsInNpbSIsIlNpbXVsYXRlZFN0YWNrIiwic3RhdGVTbG90IiwiaGFzQWN0aW9uIiwicmVjb3ZlckJ5SW5zZXJ0IiwibmV4dFN0YXRlcyIsImJlc3QiLCJzIiwic29tZSIsInYiLCJyZXN1bHQiLCJmb3JjZVJlZHVjZSIsInZhbGlkQWN0aW9uIiwidGFyZ2V0IiwiYmFja3VwIiwiZmluZEZvcmNlZFJlZHVjdGlvbiIsInNlZW4iLCJleHBsb3JlIiwiaW5jbHVkZXMiLCJhbGxBY3Rpb25zIiwickRlcHRoIiwiZm91bmQiLCJmb3JjZUFsbCIsImRlYWRFbmQiLCJkYXRhIiwicmVzdGFydCIsInNhbWVTdGF0ZSIsIm90aGVyIiwiZGlhbGVjdEVuYWJsZWQiLCJkaWFsZWN0SUQiLCJkaWFsZWN0IiwiZmxhZ3MiLCJlbWl0Q29udGV4dCIsImxhc3QiLCJoYXNoIiwiZW1pdExvb2tBaGVhZCIsIm5ld0N4IiwiY2xvc2UiLCJzdHJpY3QiLCJnb3RvIiwiU3RhY2tCdWZmZXJDdXJzb3IiLCJtYXliZU5leHQiLCJjcmVhdGUiLCJpZCIsImZvcmsiLCJkZWNvZGVBcnJheSIsImlucHV0IiwiVHlwZSIsIlVpbnQxNkFycmF5IiwiYXJyYXkiLCJvdXQiLCJjaGFyQ29kZUF0Iiwic3RvcCIsImRpZ2l0IiwiQ2FjaGVkVG9rZW4iLCJleHRlbmRlZCIsIm1hc2siLCJudWxsVG9rZW4iLCJJbnB1dFN0cmVhbSIsImNodW5rIiwiY2h1bmtPZmYiLCJjaHVuazIiLCJjaHVuazJQb3MiLCJ0b2tlbiIsInJhbmdlSW5kZXgiLCJjaHVua1BvcyIsInJhbmdlIiwidG8iLCJyZWFkTmV4dCIsInJlc29sdmVPZmZzZXQiLCJvZmZzZXQiLCJhc3NvYyIsImNsaXBQb3MiLCJNYXRoIiwibWF4IiwicGVlayIsImlkeCIsInJlc29sdmVkIiwiYWNjZXB0VG9rZW4iLCJlbmRPZmZzZXQiLCJSYW5nZUVycm9yIiwiYWNjZXB0VG9rZW5UbyIsImVuZFBvcyIsImdldENodW5rIiwibmV4dENodW5rIiwiYWR2YW5jZSIsIm4iLCJzZXREb25lIiwicmVhZCIsInIiLCJtaW4iLCJUb2tlbkdyb3VwIiwicmVhZFRva2VuIiwidG9rZW5QcmVjVGFibGUiLCJwcm90b3R5cGUiLCJjb250ZXh0dWFsIiwiZmFsbGJhY2siLCJleHRlbmQiLCJMb2NhbFRva2VuR3JvdXAiLCJwcmVjVGFibGUiLCJlbHNlVG9rZW4iLCJza2lwcGVkIiwiYXRFb2YiLCJuZXh0UG9zIiwiRXh0ZXJuYWxUb2tlbml6ZXIiLCJvcHRpb25zIiwiZ3JvdXAiLCJwcmVjT2Zmc2V0IiwiZ3JvdXBNYXNrIiwic2NhbiIsImFjY0VuZCIsImFsbG93cyIsIm92ZXJyaWRlcyIsImxvdyIsImhpZ2giLCJtaWQiLCJmaW5kT2Zmc2V0IiwicHJldiIsInRhYmxlRGF0YSIsInRhYmxlT2Zmc2V0IiwiaVByZXYiLCJ2ZXJib3NlIiwicHJvY2VzcyIsImVudiIsInRlc3QiLCJMT0ciLCJzdGFja0lEcyIsImN1dEF0IiwidHJlZSIsInNpZGUiLCJjdXJzb3IiLCJJbmNsdWRlQW5vbnltb3VzIiwibW92ZVRvIiwiY2hpbGRCZWZvcmUiLCJjaGlsZEFmdGVyIiwiaXNFcnJvciIsInByZXZTaWJsaW5nIiwibmV4dFNpYmxpbmciLCJGcmFnbWVudEN1cnNvciIsImZyYWdtZW50cyIsImZyYWdtZW50Iiwic2FmZUZyb20iLCJzYWZlVG8iLCJ0cmVlcyIsIm5leHRGcmFnbWVudCIsImZyIiwib3BlblN0YXJ0Iiwib3BlbkVuZCIsIm5vZGVBdCIsImNoaWxkcmVuIiwicG9zaXRpb25zIiwicHJvcCIsIlRva2VuQ2FjaGUiLCJ0b2tlbnMiLCJtYWluVG9rZW4iLCJhY3Rpb25zIiwidG9rZW5pemVycyIsIm1hcCIsImdldEFjdGlvbnMiLCJhY3Rpb25JbmRleCIsIm1haW4iLCJ0b2tlbml6ZXIiLCJ1cGRhdGVDYWNoZWRUb2tlbiIsInN0YXJ0SW5kZXgiLCJhZGRBY3Rpb25zIiwiZW9mVGVybSIsImdldE1haW5Ub2tlbiIsInNwZWNpYWxpemVkIiwic3BlY2lhbGl6ZXJzIiwicHV0QWN0aW9uIiwic2V0IiwicGFpciIsIlBhcnNlIiwicmVjb3ZlcmluZyIsIm5leHRTdGFja0lEIiwibWluU3RhY2tQb3MiLCJzdG9wcGVkQXQiLCJ0b3BUZXJtIiwic3RhY2tzIiwiYnVmZmVyTGVuZ3RoIiwicGFyc2VkUG9zIiwibmV3U3RhY2tzIiwic3RvcHBlZCIsInN0b3BwZWRUb2tlbnMiLCJhZHZhbmNlU3RhY2siLCJ0b2siLCJmaW5pc2hlZCIsImZpbmRGaW5pc2hlZCIsImNvbnNvbGUiLCJsb2ciLCJzdGFja0lEIiwic3RhY2tUb1RyZWUiLCJnZXROYW1lIiwiU3ludGF4RXJyb3IiLCJydW5SZWNvdmVyeSIsIm1heFJlbWFpbmluZyIsInNvcnQiLCJhIiwiYiIsIm91dGVyIiwiaiIsInNwbGljZSIsInN0b3BBdCIsInN0cmljdEN4IiwiY3hIYXNoIiwiY2FjaGVkIiwibWF0Y2giLCJjb250ZXh0SGFzaCIsImlubmVyIiwiZGVmYXVsdFJlZHVjZSIsImxvY2FsU3RhY2siLCJhZHZhbmNlRnVsbHkiLCJwdXNoU3RhY2tEZWR1cCIsInJlc3RhcnRlZCIsInRva2VuRW5kIiwiZG9uZSIsImZvcmNlIiwiZm9yY2VCYXNlIiwiaW5zZXJ0IiwiYnVpbGQiLCJ0b3BJRCIsIm1heEJ1ZmZlckxlbmd0aCIsIm1pblJlcGVhdFR5cGUiLCJXZWFrTWFwIiwiZ2V0IiwiU3RyaW5nIiwiZnJvbUNvZGVQb2ludCIsIkRpYWxlY3QiLCJzb3VyY2UiLCJkaXNhYmxlZCIsIngiLCJDb250ZXh0VHJhY2tlciIsInNwZWMiLCJMUlBhcnNlciIsIndyYXBwZXJzIiwidmVyc2lvbiIsIm5vZGVOYW1lcyIsInJlcGVhdE5vZGVDb3VudCIsInRvcFRlcm1zIiwiT2JqZWN0Iiwia2V5cyIsInRvcFJ1bGVzIiwibm9kZVByb3BzIiwic2V0UHJvcCIsIm5vZGVJRCIsImRlc2VyaWFsaXplIiwicHJvcFNwZWMiLCJuYW1lIiwiZGVmaW5lIiwidW5kZWZpbmVkIiwicHJvcHMiLCJpbmRleE9mIiwiZXJyb3IiLCJza2lwcGVkTm9kZXMiLCJwcm9wU291cmNlcyIsInRva2VuQXJyYXkiLCJ0b2tlbkRhdGEiLCJzcGVjaWFsaXplclNwZWNzIiwiZ2V0U3BlY2lhbGl6ZXIiLCJzdGF0ZXMiLCJVaW50MzJBcnJheSIsInN0YXRlRGF0YSIsIm1heFRlcm0iLCJkaWFsZWN0cyIsImR5bmFtaWNQcmVjZWRlbmNlcyIsInRva2VuUHJlYyIsInRlcm1OYW1lcyIsInBhcnNlRGlhbGVjdCIsImNyZWF0ZVBhcnNlIiwicGFyc2UiLCJ3IiwibG9vc2UiLCJ0YWJsZSIsImdyb3VwVGFnIiwidGVybWluYWwiLCJzbG90IiwiZmxhZyIsImRlZmx0IiwiY29uZmlndXJlIiwiY29uZmlnIiwiY29weSIsImFzc2lnbiIsImluZm8iLCJ0IiwiZmluZCIsImV4dGVybmFsIiwiY29udGV4dFRyYWNrZXIiLCJ3cmFwIiwiaGFzV3JhcHBlcnMiLCJ0b3BOb2RlIiwicHJlYyIsInZhbHVlcyIsInBhcnQiLCJVaW50OEFycmF5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/@lezer/lr/dist/index.js\n");

/***/ })

}]);