"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(globalThis["webpackChunkridge_codemirror"] = globalThis["webpackChunkridge_codemirror"] || []).push([["vendors-node_modules_codemirror_language_dist_index_js"],{

/***/ "../../node_modules/@codemirror/language/dist/index.js":
/*!*************************************************************!*\
  !*** ../../node_modules/@codemirror/language/dist/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DocInput: () => (/* binding */ DocInput),\n/* harmony export */   HighlightStyle: () => (/* binding */ HighlightStyle),\n/* harmony export */   IndentContext: () => (/* binding */ IndentContext),\n/* harmony export */   LRLanguage: () => (/* binding */ LRLanguage),\n/* harmony export */   Language: () => (/* binding */ Language),\n/* harmony export */   LanguageDescription: () => (/* binding */ LanguageDescription),\n/* harmony export */   LanguageSupport: () => (/* binding */ LanguageSupport),\n/* harmony export */   ParseContext: () => (/* binding */ ParseContext),\n/* harmony export */   StreamLanguage: () => (/* binding */ StreamLanguage),\n/* harmony export */   StringStream: () => (/* binding */ StringStream),\n/* harmony export */   TreeIndentContext: () => (/* binding */ TreeIndentContext),\n/* harmony export */   bidiIsolates: () => (/* binding */ bidiIsolates),\n/* harmony export */   bracketMatching: () => (/* binding */ bracketMatching),\n/* harmony export */   bracketMatchingHandle: () => (/* binding */ bracketMatchingHandle),\n/* harmony export */   codeFolding: () => (/* binding */ codeFolding),\n/* harmony export */   continuedIndent: () => (/* binding */ continuedIndent),\n/* harmony export */   defaultHighlightStyle: () => (/* binding */ defaultHighlightStyle),\n/* harmony export */   defineLanguageFacet: () => (/* binding */ defineLanguageFacet),\n/* harmony export */   delimitedIndent: () => (/* binding */ delimitedIndent),\n/* harmony export */   ensureSyntaxTree: () => (/* binding */ ensureSyntaxTree),\n/* harmony export */   flatIndent: () => (/* binding */ flatIndent),\n/* harmony export */   foldAll: () => (/* binding */ foldAll),\n/* harmony export */   foldCode: () => (/* binding */ foldCode),\n/* harmony export */   foldEffect: () => (/* binding */ foldEffect),\n/* harmony export */   foldGutter: () => (/* binding */ foldGutter),\n/* harmony export */   foldInside: () => (/* binding */ foldInside),\n/* harmony export */   foldKeymap: () => (/* binding */ foldKeymap),\n/* harmony export */   foldNodeProp: () => (/* binding */ foldNodeProp),\n/* harmony export */   foldService: () => (/* binding */ foldService),\n/* harmony export */   foldState: () => (/* binding */ foldState),\n/* harmony export */   foldable: () => (/* binding */ foldable),\n/* harmony export */   foldedRanges: () => (/* binding */ foldedRanges),\n/* harmony export */   forceParsing: () => (/* binding */ forceParsing),\n/* harmony export */   getIndentUnit: () => (/* binding */ getIndentUnit),\n/* harmony export */   getIndentation: () => (/* binding */ getIndentation),\n/* harmony export */   highlightingFor: () => (/* binding */ highlightingFor),\n/* harmony export */   indentNodeProp: () => (/* binding */ indentNodeProp),\n/* harmony export */   indentOnInput: () => (/* binding */ indentOnInput),\n/* harmony export */   indentRange: () => (/* binding */ indentRange),\n/* harmony export */   indentService: () => (/* binding */ indentService),\n/* harmony export */   indentString: () => (/* binding */ indentString),\n/* harmony export */   indentUnit: () => (/* binding */ indentUnit),\n/* harmony export */   language: () => (/* binding */ language),\n/* harmony export */   languageDataProp: () => (/* binding */ languageDataProp),\n/* harmony export */   matchBrackets: () => (/* binding */ matchBrackets),\n/* harmony export */   sublanguageProp: () => (/* binding */ sublanguageProp),\n/* harmony export */   syntaxHighlighting: () => (/* binding */ syntaxHighlighting),\n/* harmony export */   syntaxParserRunning: () => (/* binding */ syntaxParserRunning),\n/* harmony export */   syntaxTree: () => (/* binding */ syntaxTree),\n/* harmony export */   syntaxTreeAvailable: () => (/* binding */ syntaxTreeAvailable),\n/* harmony export */   toggleFold: () => (/* binding */ toggleFold),\n/* harmony export */   unfoldAll: () => (/* binding */ unfoldAll),\n/* harmony export */   unfoldCode: () => (/* binding */ unfoldCode),\n/* harmony export */   unfoldEffect: () => (/* binding */ unfoldEffect)\n/* harmony export */ });\n/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/common */ \"../../node_modules/@lezer/common/dist/index.js\");\n/* harmony import */ var _codemirror_state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @codemirror/state */ \"../../node_modules/@codemirror/state/dist/index.js\");\n/* harmony import */ var _codemirror_view__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @codemirror/view */ \"../../node_modules/@codemirror/view/dist/index.js\");\n/* harmony import */ var _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @lezer/highlight */ \"../../node_modules/@lezer/highlight/dist/index.js\");\n/* harmony import */ var style_mod__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! style-mod */ \"../../node_modules/style-mod/src/style-mod.js\");\n\n\n\n\n\nvar _a;\n/**\nNode prop stored in a parser's top syntax node to provide the\nfacet that stores language-specific data for that language.\n*/\nconst languageDataProp = /*@__PURE__*/new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();\n/**\nHelper function to define a facet (to be added to the top syntax\nnode(s) for a language via\n[`languageDataProp`](https://codemirror.net/6/docs/ref/#language.languageDataProp)), that will be\nused to associate language data with the language. You\nprobably only need this when subclassing\n[`Language`](https://codemirror.net/6/docs/ref/#language.Language).\n*/\nfunction defineLanguageFacet(baseData) {\n  return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n    combine: baseData ? values => values.concat(baseData) : undefined\n  });\n}\n/**\nSyntax node prop used to register sublanguages. Should be added to\nthe top level node type for the language.\n*/\nconst sublanguageProp = /*@__PURE__*/new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();\n/**\nA language object manages parsing and per-language\n[metadata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt). Parse data is\nmanaged as a [Lezer](https://lezer.codemirror.net) tree. The class\ncan be used directly, via the [`LRLanguage`](https://codemirror.net/6/docs/ref/#language.LRLanguage)\nsubclass for [Lezer](https://lezer.codemirror.net/) LR parsers, or\nvia the [`StreamLanguage`](https://codemirror.net/6/docs/ref/#language.StreamLanguage) subclass\nfor stream parsers.\n*/\nclass Language {\n  /**\n  Construct a language object. If you need to invoke this\n  directly, first define a data facet with\n  [`defineLanguageFacet`](https://codemirror.net/6/docs/ref/#language.defineLanguageFacet), and then\n  configure your parser to [attach](https://codemirror.net/6/docs/ref/#language.languageDataProp) it\n  to the language's outer syntax node.\n  */\n  constructor(\n  /**\n  The [language data](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt) facet\n  used for this language.\n  */\n  data, parser, extraExtensions = [],\n  /**\n  A language name.\n  */\n  name = \"\") {\n    this.data = data;\n    this.name = name;\n    // Kludge to define EditorState.tree as a debugging helper,\n    // without the EditorState package actually knowing about\n    // languages and lezer trees.\n    if (!_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState.prototype.hasOwnProperty(\"tree\")) Object.defineProperty(_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState.prototype, \"tree\", {\n      get() {\n        return syntaxTree(this);\n      }\n    });\n    this.parser = parser;\n    this.extension = [language.of(this), _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState.languageData.of((state, pos, side) => {\n      let top = topNodeAt(state, pos, side),\n        data = top.type.prop(languageDataProp);\n      if (!data) return [];\n      let base = state.facet(data),\n        sub = top.type.prop(sublanguageProp);\n      if (sub) {\n        let innerNode = top.resolve(pos - top.from, side);\n        for (let sublang of sub) if (sublang.test(innerNode, state)) {\n          let data = state.facet(sublang.facet);\n          return sublang.type == \"replace\" ? data : data.concat(base);\n        }\n      }\n      return base;\n    })].concat(extraExtensions);\n  }\n  /**\n  Query whether this language is active at the given position.\n  */\n  isActiveAt(state, pos, side = -1) {\n    return topNodeAt(state, pos, side).type.prop(languageDataProp) == this.data;\n  }\n  /**\n  Find the document regions that were parsed using this language.\n  The returned regions will _include_ any nested languages rooted\n  in this language, when those exist.\n  */\n  findRegions(state) {\n    let lang = state.facet(language);\n    if ((lang === null || lang === void 0 ? void 0 : lang.data) == this.data) return [{\n      from: 0,\n      to: state.doc.length\n    }];\n    if (!lang || !lang.allowsNesting) return [];\n    let result = [];\n    let explore = (tree, from) => {\n      if (tree.prop(languageDataProp) == this.data) {\n        result.push({\n          from,\n          to: from + tree.length\n        });\n        return;\n      }\n      let mount = tree.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.mounted);\n      if (mount) {\n        if (mount.tree.prop(languageDataProp) == this.data) {\n          if (mount.overlay) for (let r of mount.overlay) result.push({\n            from: r.from + from,\n            to: r.to + from\n          });else result.push({\n            from: from,\n            to: from + tree.length\n          });\n          return;\n        } else if (mount.overlay) {\n          let size = result.length;\n          explore(mount.tree, mount.overlay[0].from + from);\n          if (result.length > size) return;\n        }\n      }\n      for (let i = 0; i < tree.children.length; i++) {\n        let ch = tree.children[i];\n        if (ch instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree) explore(ch, tree.positions[i] + from);\n      }\n    };\n    explore(syntaxTree(state), 0);\n    return result;\n  }\n  /**\n  Indicates whether this language allows nested languages. The\n  default implementation returns true.\n  */\n  get allowsNesting() {\n    return true;\n  }\n}\n/**\n@internal\n*/\nLanguage.setState = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.define();\nfunction topNodeAt(state, pos, side) {\n  let topLang = state.facet(language),\n    tree = syntaxTree(state).topNode;\n  if (!topLang || topLang.allowsNesting) {\n    for (let node = tree; node; node = node.enter(pos, side, _lezer_common__WEBPACK_IMPORTED_MODULE_0__.IterMode.ExcludeBuffers)) if (node.type.isTop) tree = node;\n  }\n  return tree;\n}\n/**\nA subclass of [`Language`](https://codemirror.net/6/docs/ref/#language.Language) for use with Lezer\n[LR parsers](https://lezer.codemirror.net/docs/ref#lr.LRParser)\nparsers.\n*/\nclass LRLanguage extends Language {\n  constructor(data, parser, name) {\n    super(data, parser, [], name);\n    this.parser = parser;\n  }\n  /**\n  Define a language from a parser.\n  */\n  static define(spec) {\n    let data = defineLanguageFacet(spec.languageData);\n    return new LRLanguage(data, spec.parser.configure({\n      props: [languageDataProp.add(type => type.isTop ? data : undefined)]\n    }), spec.name);\n  }\n  /**\n  Create a new instance of this language with a reconfigured\n  version of its parser and optionally a new name.\n  */\n  configure(options, name) {\n    return new LRLanguage(this.data, this.parser.configure(options), name || this.name);\n  }\n  get allowsNesting() {\n    return this.parser.hasWrappers();\n  }\n}\n/**\nGet the syntax tree for a state, which is the current (possibly\nincomplete) parse tree of the active\n[language](https://codemirror.net/6/docs/ref/#language.Language), or the empty tree if there is no\nlanguage available.\n*/\nfunction syntaxTree(state) {\n  let field = state.field(Language.state, false);\n  return field ? field.tree : _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.empty;\n}\n/**\nTry to get a parse tree that spans at least up to `upto`. The\nmethod will do at most `timeout` milliseconds of work to parse\nup to that point if the tree isn't already available.\n*/\nfunction ensureSyntaxTree(state, upto, timeout = 50) {\n  var _a;\n  let parse = (_a = state.field(Language.state, false)) === null || _a === void 0 ? void 0 : _a.context;\n  if (!parse) return null;\n  let oldVieport = parse.viewport;\n  parse.updateViewport({\n    from: 0,\n    to: upto\n  });\n  let result = parse.isDone(upto) || parse.work(timeout, upto) ? parse.tree : null;\n  parse.updateViewport(oldVieport);\n  return result;\n}\n/**\nQueries whether there is a full syntax tree available up to the\ngiven document position. If there isn't, the background parse\nprocess _might_ still be working and update the tree further, but\nthere is no guarantee of that—the parser will [stop\nworking](https://codemirror.net/6/docs/ref/#language.syntaxParserRunning) when it has spent a\ncertain amount of time or has moved beyond the visible viewport.\nAlways returns false if no language has been enabled.\n*/\nfunction syntaxTreeAvailable(state, upto = state.doc.length) {\n  var _a;\n  return ((_a = state.field(Language.state, false)) === null || _a === void 0 ? void 0 : _a.context.isDone(upto)) || false;\n}\n/**\nMove parsing forward, and update the editor state afterwards to\nreflect the new tree. Will work for at most `timeout`\nmilliseconds. Returns true if the parser managed get to the given\nposition in that time.\n*/\nfunction forceParsing(view, upto = view.viewport.to, timeout = 100) {\n  let success = ensureSyntaxTree(view.state, upto, timeout);\n  if (success != syntaxTree(view.state)) view.dispatch({});\n  return !!success;\n}\n/**\nTells you whether the language parser is planning to do more\nparsing work (in a `requestIdleCallback` pseudo-thread) or has\nstopped running, either because it parsed the entire document,\nbecause it spent too much time and was cut off, or because there\nis no language parser enabled.\n*/\nfunction syntaxParserRunning(view) {\n  var _a;\n  return ((_a = view.plugin(parseWorker)) === null || _a === void 0 ? void 0 : _a.isWorking()) || false;\n}\n/**\nLezer-style\n[`Input`](https://lezer.codemirror.net/docs/ref#common.Input)\nobject for a [`Text`](https://codemirror.net/6/docs/ref/#state.Text) object.\n*/\nclass DocInput {\n  /**\n  Create an input object for the given document.\n  */\n  constructor(doc) {\n    this.doc = doc;\n    this.cursorPos = 0;\n    this.string = \"\";\n    this.cursor = doc.iter();\n  }\n  get length() {\n    return this.doc.length;\n  }\n  syncTo(pos) {\n    this.string = this.cursor.next(pos - this.cursorPos).value;\n    this.cursorPos = pos + this.string.length;\n    return this.cursorPos - this.string.length;\n  }\n  chunk(pos) {\n    this.syncTo(pos);\n    return this.string;\n  }\n  get lineChunks() {\n    return true;\n  }\n  read(from, to) {\n    let stringStart = this.cursorPos - this.string.length;\n    if (from < stringStart || to >= this.cursorPos) return this.doc.sliceString(from, to);else return this.string.slice(from - stringStart, to - stringStart);\n  }\n}\nlet currentContext = null;\n/**\nA parse context provided to parsers working on the editor content.\n*/\nclass ParseContext {\n  constructor(parser,\n  /**\n  The current editor state.\n  */\n  state,\n  /**\n  Tree fragments that can be reused by incremental re-parses.\n  */\n  fragments = [],\n  /**\n  @internal\n  */\n  tree,\n  /**\n  @internal\n  */\n  treeLen,\n  /**\n  The current editor viewport (or some overapproximation\n  thereof). Intended to be used for opportunistically avoiding\n  work (in which case\n  [`skipUntilInView`](https://codemirror.net/6/docs/ref/#language.ParseContext.skipUntilInView)\n  should be called to make sure the parser is restarted when the\n  skipped region becomes visible).\n  */\n  viewport,\n  /**\n  @internal\n  */\n  skipped,\n  /**\n  This is where skipping parsers can register a promise that,\n  when resolved, will schedule a new parse. It is cleared when\n  the parse worker picks up the promise. @internal\n  */\n  scheduleOn) {\n    this.parser = parser;\n    this.state = state;\n    this.fragments = fragments;\n    this.tree = tree;\n    this.treeLen = treeLen;\n    this.viewport = viewport;\n    this.skipped = skipped;\n    this.scheduleOn = scheduleOn;\n    this.parse = null;\n    /**\n    @internal\n    */\n    this.tempSkipped = [];\n  }\n  /**\n  @internal\n  */\n  static create(parser, state, viewport) {\n    return new ParseContext(parser, state, [], _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.empty, 0, viewport, [], null);\n  }\n  startParse() {\n    return this.parser.startParse(new DocInput(this.state.doc), this.fragments);\n  }\n  /**\n  @internal\n  */\n  work(until, upto) {\n    if (upto != null && upto >= this.state.doc.length) upto = undefined;\n    if (this.tree != _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.empty && this.isDone(upto !== null && upto !== void 0 ? upto : this.state.doc.length)) {\n      this.takeTree();\n      return true;\n    }\n    return this.withContext(() => {\n      var _a;\n      if (typeof until == \"number\") {\n        let endTime = Date.now() + until;\n        until = () => Date.now() > endTime;\n      }\n      if (!this.parse) this.parse = this.startParse();\n      if (upto != null && (this.parse.stoppedAt == null || this.parse.stoppedAt > upto) && upto < this.state.doc.length) this.parse.stopAt(upto);\n      for (;;) {\n        let done = this.parse.advance();\n        if (done) {\n          this.fragments = this.withoutTempSkipped(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.TreeFragment.addTree(done, this.fragments, this.parse.stoppedAt != null));\n          this.treeLen = (_a = this.parse.stoppedAt) !== null && _a !== void 0 ? _a : this.state.doc.length;\n          this.tree = done;\n          this.parse = null;\n          if (this.treeLen < (upto !== null && upto !== void 0 ? upto : this.state.doc.length)) this.parse = this.startParse();else return true;\n        }\n        if (until()) return false;\n      }\n    });\n  }\n  /**\n  @internal\n  */\n  takeTree() {\n    let pos, tree;\n    if (this.parse && (pos = this.parse.parsedPos) >= this.treeLen) {\n      if (this.parse.stoppedAt == null || this.parse.stoppedAt > pos) this.parse.stopAt(pos);\n      this.withContext(() => {\n        while (!(tree = this.parse.advance())) {}\n      });\n      this.treeLen = pos;\n      this.tree = tree;\n      this.fragments = this.withoutTempSkipped(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.TreeFragment.addTree(this.tree, this.fragments, true));\n      this.parse = null;\n    }\n  }\n  withContext(f) {\n    let prev = currentContext;\n    currentContext = this;\n    try {\n      return f();\n    } finally {\n      currentContext = prev;\n    }\n  }\n  withoutTempSkipped(fragments) {\n    for (let r; r = this.tempSkipped.pop();) fragments = cutFragments(fragments, r.from, r.to);\n    return fragments;\n  }\n  /**\n  @internal\n  */\n  changes(changes, newState) {\n    let {\n      fragments,\n      tree,\n      treeLen,\n      viewport,\n      skipped\n    } = this;\n    this.takeTree();\n    if (!changes.empty) {\n      let ranges = [];\n      changes.iterChangedRanges((fromA, toA, fromB, toB) => ranges.push({\n        fromA,\n        toA,\n        fromB,\n        toB\n      }));\n      fragments = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.TreeFragment.applyChanges(fragments, ranges);\n      tree = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.empty;\n      treeLen = 0;\n      viewport = {\n        from: changes.mapPos(viewport.from, -1),\n        to: changes.mapPos(viewport.to, 1)\n      };\n      if (this.skipped.length) {\n        skipped = [];\n        for (let r of this.skipped) {\n          let from = changes.mapPos(r.from, 1),\n            to = changes.mapPos(r.to, -1);\n          if (from < to) skipped.push({\n            from,\n            to\n          });\n        }\n      }\n    }\n    return new ParseContext(this.parser, newState, fragments, tree, treeLen, viewport, skipped, this.scheduleOn);\n  }\n  /**\n  @internal\n  */\n  updateViewport(viewport) {\n    if (this.viewport.from == viewport.from && this.viewport.to == viewport.to) return false;\n    this.viewport = viewport;\n    let startLen = this.skipped.length;\n    for (let i = 0; i < this.skipped.length; i++) {\n      let {\n        from,\n        to\n      } = this.skipped[i];\n      if (from < viewport.to && to > viewport.from) {\n        this.fragments = cutFragments(this.fragments, from, to);\n        this.skipped.splice(i--, 1);\n      }\n    }\n    if (this.skipped.length >= startLen) return false;\n    this.reset();\n    return true;\n  }\n  /**\n  @internal\n  */\n  reset() {\n    if (this.parse) {\n      this.takeTree();\n      this.parse = null;\n    }\n  }\n  /**\n  Notify the parse scheduler that the given region was skipped\n  because it wasn't in view, and the parse should be restarted\n  when it comes into view.\n  */\n  skipUntilInView(from, to) {\n    this.skipped.push({\n      from,\n      to\n    });\n  }\n  /**\n  Returns a parser intended to be used as placeholder when\n  asynchronously loading a nested parser. It'll skip its input and\n  mark it as not-really-parsed, so that the next update will parse\n  it again.\n  \n  When `until` is given, a reparse will be scheduled when that\n  promise resolves.\n  */\n  static getSkippingParser(until) {\n    return new class extends _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Parser {\n      createParse(input, fragments, ranges) {\n        let from = ranges[0].from,\n          to = ranges[ranges.length - 1].to;\n        let parser = {\n          parsedPos: from,\n          advance() {\n            let cx = currentContext;\n            if (cx) {\n              for (let r of ranges) cx.tempSkipped.push(r);\n              if (until) cx.scheduleOn = cx.scheduleOn ? Promise.all([cx.scheduleOn, until]) : until;\n            }\n            this.parsedPos = to;\n            return new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.none, [], [], to - from);\n          },\n          stoppedAt: null,\n          stopAt() {}\n        };\n        return parser;\n      }\n    }();\n  }\n  /**\n  @internal\n  */\n  isDone(upto) {\n    upto = Math.min(upto, this.state.doc.length);\n    let frags = this.fragments;\n    return this.treeLen >= upto && frags.length && frags[0].from == 0 && frags[0].to >= upto;\n  }\n  /**\n  Get the context for the current parse, or `null` if no editor\n  parse is in progress.\n  */\n  static get() {\n    return currentContext;\n  }\n}\nfunction cutFragments(fragments, from, to) {\n  return _lezer_common__WEBPACK_IMPORTED_MODULE_0__.TreeFragment.applyChanges(fragments, [{\n    fromA: from,\n    toA: to,\n    fromB: from,\n    toB: to\n  }]);\n}\nclass LanguageState {\n  constructor(\n  // A mutable parse state that is used to preserve work done during\n  // the lifetime of a state when moving to the next state.\n  context) {\n    this.context = context;\n    this.tree = context.tree;\n  }\n  apply(tr) {\n    if (!tr.docChanged && this.tree == this.context.tree) return this;\n    let newCx = this.context.changes(tr.changes, tr.state);\n    // If the previous parse wasn't done, go forward only up to its\n    // end position or the end of the viewport, to avoid slowing down\n    // state updates with parse work beyond the viewport.\n    let upto = this.context.treeLen == tr.startState.doc.length ? undefined : Math.max(tr.changes.mapPos(this.context.treeLen), newCx.viewport.to);\n    if (!newCx.work(20 /* Work.Apply */, upto)) newCx.takeTree();\n    return new LanguageState(newCx);\n  }\n  static init(state) {\n    let vpTo = Math.min(3000 /* Work.InitViewport */, state.doc.length);\n    let parseState = ParseContext.create(state.facet(language).parser, state, {\n      from: 0,\n      to: vpTo\n    });\n    if (!parseState.work(20 /* Work.Apply */, vpTo)) parseState.takeTree();\n    return new LanguageState(parseState);\n  }\n}\nLanguage.state = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateField.define({\n  create: LanguageState.init,\n  update(value, tr) {\n    for (let e of tr.effects) if (e.is(Language.setState)) return e.value;\n    if (tr.startState.facet(language) != tr.state.facet(language)) return LanguageState.init(tr.state);\n    return value.apply(tr);\n  }\n});\nlet requestIdle = callback => {\n  let timeout = setTimeout(() => callback(), 500 /* Work.MaxPause */);\n  return () => clearTimeout(timeout);\n};\nif (typeof requestIdleCallback != \"undefined\") requestIdle = callback => {\n  let idle = -1,\n    timeout = setTimeout(() => {\n      idle = requestIdleCallback(callback, {\n        timeout: 500 /* Work.MaxPause */ - 100 /* Work.MinPause */\n      });\n    }, 100 /* Work.MinPause */);\n  return () => idle < 0 ? clearTimeout(timeout) : cancelIdleCallback(idle);\n};\nconst isInputPending = typeof navigator != \"undefined\" && ((_a = navigator.scheduling) === null || _a === void 0 ? void 0 : _a.isInputPending) ? () => navigator.scheduling.isInputPending() : null;\nconst parseWorker = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.ViewPlugin.fromClass(class ParseWorker {\n  constructor(view) {\n    this.view = view;\n    this.working = null;\n    this.workScheduled = 0;\n    // End of the current time chunk\n    this.chunkEnd = -1;\n    // Milliseconds of budget left for this chunk\n    this.chunkBudget = -1;\n    this.work = this.work.bind(this);\n    this.scheduleWork();\n  }\n  update(update) {\n    let cx = this.view.state.field(Language.state).context;\n    if (cx.updateViewport(update.view.viewport) || this.view.viewport.to > cx.treeLen) this.scheduleWork();\n    if (update.docChanged || update.selectionSet) {\n      if (this.view.hasFocus) this.chunkBudget += 50 /* Work.ChangeBonus */;\n      this.scheduleWork();\n    }\n    this.checkAsyncSchedule(cx);\n  }\n  scheduleWork() {\n    if (this.working) return;\n    let {\n        state\n      } = this.view,\n      field = state.field(Language.state);\n    if (field.tree != field.context.tree || !field.context.isDone(state.doc.length)) this.working = requestIdle(this.work);\n  }\n  work(deadline) {\n    this.working = null;\n    let now = Date.now();\n    if (this.chunkEnd < now && (this.chunkEnd < 0 || this.view.hasFocus)) {\n      // Start a new chunk\n      this.chunkEnd = now + 30000 /* Work.ChunkTime */;\n      this.chunkBudget = 3000 /* Work.ChunkBudget */;\n    }\n    if (this.chunkBudget <= 0) return; // No more budget\n    let {\n        state,\n        viewport: {\n          to: vpTo\n        }\n      } = this.view,\n      field = state.field(Language.state);\n    if (field.tree == field.context.tree && field.context.isDone(vpTo + 100000 /* Work.MaxParseAhead */)) return;\n    let endTime = Date.now() + Math.min(this.chunkBudget, 100 /* Work.Slice */, deadline && !isInputPending ? Math.max(25 /* Work.MinSlice */, deadline.timeRemaining() - 5) : 1e9);\n    let viewportFirst = field.context.treeLen < vpTo && state.doc.length > vpTo + 1000;\n    let done = field.context.work(() => {\n      return isInputPending && isInputPending() || Date.now() > endTime;\n    }, vpTo + (viewportFirst ? 0 : 100000 /* Work.MaxParseAhead */));\n    this.chunkBudget -= Date.now() - now;\n    if (done || this.chunkBudget <= 0) {\n      field.context.takeTree();\n      this.view.dispatch({\n        effects: Language.setState.of(new LanguageState(field.context))\n      });\n    }\n    if (this.chunkBudget > 0 && !(done && !viewportFirst)) this.scheduleWork();\n    this.checkAsyncSchedule(field.context);\n  }\n  checkAsyncSchedule(cx) {\n    if (cx.scheduleOn) {\n      this.workScheduled++;\n      cx.scheduleOn.then(() => this.scheduleWork()).catch(err => (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.logException)(this.view.state, err)).then(() => this.workScheduled--);\n      cx.scheduleOn = null;\n    }\n  }\n  destroy() {\n    if (this.working) this.working();\n  }\n  isWorking() {\n    return !!(this.working || this.workScheduled > 0);\n  }\n}, {\n  eventHandlers: {\n    focus() {\n      this.scheduleWork();\n    }\n  }\n});\n/**\nThe facet used to associate a language with an editor state. Used\nby `Language` object's `extension` property (so you don't need to\nmanually wrap your languages in this). Can be used to access the\ncurrent language on a state.\n*/\nconst language = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n  combine(languages) {\n    return languages.length ? languages[0] : null;\n  },\n  enables: language => [Language.state, parseWorker, _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.contentAttributes.compute([language], state => {\n    let lang = state.facet(language);\n    return lang && lang.name ? {\n      \"data-language\": lang.name\n    } : {};\n  })]\n});\n/**\nThis class bundles a [language](https://codemirror.net/6/docs/ref/#language.Language) with an\noptional set of supporting extensions. Language packages are\nencouraged to export a function that optionally takes a\nconfiguration object and returns a `LanguageSupport` instance, as\nthe main way for client code to use the package.\n*/\nclass LanguageSupport {\n  /**\n  Create a language support object.\n  */\n  constructor(\n  /**\n  The language object.\n  */\n  language,\n  /**\n  An optional set of supporting extensions. When nesting a\n  language in another language, the outer language is encouraged\n  to include the supporting extensions for its inner languages\n  in its own set of support extensions.\n  */\n  support = []) {\n    this.language = language;\n    this.support = support;\n    this.extension = [language, support];\n  }\n}\n/**\nLanguage descriptions are used to store metadata about languages\nand to dynamically load them. Their main role is finding the\nappropriate language for a filename or dynamically loading nested\nparsers.\n*/\nclass LanguageDescription {\n  constructor(\n  /**\n  The name of this language.\n  */\n  name,\n  /**\n  Alternative names for the mode (lowercased, includes `this.name`).\n  */\n  alias,\n  /**\n  File extensions associated with this language.\n  */\n  extensions,\n  /**\n  Optional filename pattern that should be associated with this\n  language.\n  */\n  filename, loadFunc,\n  /**\n  If the language has been loaded, this will hold its value.\n  */\n  support = undefined) {\n    this.name = name;\n    this.alias = alias;\n    this.extensions = extensions;\n    this.filename = filename;\n    this.loadFunc = loadFunc;\n    this.support = support;\n    this.loading = null;\n  }\n  /**\n  Start loading the the language. Will return a promise that\n  resolves to a [`LanguageSupport`](https://codemirror.net/6/docs/ref/#language.LanguageSupport)\n  object when the language successfully loads.\n  */\n  load() {\n    return this.loading || (this.loading = this.loadFunc().then(support => this.support = support, err => {\n      this.loading = null;\n      throw err;\n    }));\n  }\n  /**\n  Create a language description.\n  */\n  static of(spec) {\n    let {\n      load,\n      support\n    } = spec;\n    if (!load) {\n      if (!support) throw new RangeError(\"Must pass either 'load' or 'support' to LanguageDescription.of\");\n      load = () => Promise.resolve(support);\n    }\n    return new LanguageDescription(spec.name, (spec.alias || []).concat(spec.name).map(s => s.toLowerCase()), spec.extensions || [], spec.filename, load, support);\n  }\n  /**\n  Look for a language in the given array of descriptions that\n  matches the filename. Will first match\n  [`filename`](https://codemirror.net/6/docs/ref/#language.LanguageDescription.filename) patterns,\n  and then [extensions](https://codemirror.net/6/docs/ref/#language.LanguageDescription.extensions),\n  and return the first language that matches.\n  */\n  static matchFilename(descs, filename) {\n    for (let d of descs) if (d.filename && d.filename.test(filename)) return d;\n    let ext = /\\.([^.]+)$/.exec(filename);\n    if (ext) for (let d of descs) if (d.extensions.indexOf(ext[1]) > -1) return d;\n    return null;\n  }\n  /**\n  Look for a language whose name or alias matches the the given\n  name (case-insensitively). If `fuzzy` is true, and no direct\n  matchs is found, this'll also search for a language whose name\n  or alias occurs in the string (for names shorter than three\n  characters, only when surrounded by non-word characters).\n  */\n  static matchLanguageName(descs, name, fuzzy = true) {\n    name = name.toLowerCase();\n    for (let d of descs) if (d.alias.some(a => a == name)) return d;\n    if (fuzzy) for (let d of descs) for (let a of d.alias) {\n      let found = name.indexOf(a);\n      if (found > -1 && (a.length > 2 || !/\\w/.test(name[found - 1]) && !/\\w/.test(name[found + a.length]))) return d;\n    }\n    return null;\n  }\n}\n\n/**\nFacet that defines a way to provide a function that computes the\nappropriate indentation depth, as a column number (see\n[`indentString`](https://codemirror.net/6/docs/ref/#language.indentString)), at the start of a given\nline. A return value of `null` indicates no indentation can be\ndetermined, and the line should inherit the indentation of the one\nabove it. A return value of `undefined` defers to the next indent\nservice.\n*/\nconst indentService = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\n/**\nFacet for overriding the unit by which indentation happens. Should\nbe a string consisting either entirely of the same whitespace\ncharacter. When not set, this defaults to 2 spaces.\n*/\nconst indentUnit = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n  combine: values => {\n    if (!values.length) return \"  \";\n    let unit = values[0];\n    if (!unit || /\\S/.test(unit) || Array.from(unit).some(e => e != unit[0])) throw new Error(\"Invalid indent unit: \" + JSON.stringify(values[0]));\n    return unit;\n  }\n});\n/**\nReturn the _column width_ of an indent unit in the state.\nDetermined by the [`indentUnit`](https://codemirror.net/6/docs/ref/#language.indentUnit)\nfacet, and [`tabSize`](https://codemirror.net/6/docs/ref/#state.EditorState^tabSize) when that\ncontains tabs.\n*/\nfunction getIndentUnit(state) {\n  let unit = state.facet(indentUnit);\n  return unit.charCodeAt(0) == 9 ? state.tabSize * unit.length : unit.length;\n}\n/**\nCreate an indentation string that covers columns 0 to `cols`.\nWill use tabs for as much of the columns as possible when the\n[`indentUnit`](https://codemirror.net/6/docs/ref/#language.indentUnit) facet contains\ntabs.\n*/\nfunction indentString(state, cols) {\n  let result = \"\",\n    ts = state.tabSize,\n    ch = state.facet(indentUnit)[0];\n  if (ch == \"\\t\") {\n    while (cols >= ts) {\n      result += \"\\t\";\n      cols -= ts;\n    }\n    ch = \" \";\n  }\n  for (let i = 0; i < cols; i++) result += ch;\n  return result;\n}\n/**\nGet the indentation, as a column number, at the given position.\nWill first consult any [indent services](https://codemirror.net/6/docs/ref/#language.indentService)\nthat are registered, and if none of those return an indentation,\nthis will check the syntax tree for the [indent node\nprop](https://codemirror.net/6/docs/ref/#language.indentNodeProp) and use that if found. Returns a\nnumber when an indentation could be determined, and null\notherwise.\n*/\nfunction getIndentation(context, pos) {\n  if (context instanceof _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState) context = new IndentContext(context);\n  for (let service of context.state.facet(indentService)) {\n    let result = service(context, pos);\n    if (result !== undefined) return result;\n  }\n  let tree = syntaxTree(context.state);\n  return tree.length >= pos ? syntaxIndentation(context, tree, pos) : null;\n}\n/**\nCreate a change set that auto-indents all lines touched by the\ngiven document range.\n*/\nfunction indentRange(state, from, to) {\n  let updated = Object.create(null);\n  let context = new IndentContext(state, {\n    overrideIndentation: start => {\n      var _a;\n      return (_a = updated[start]) !== null && _a !== void 0 ? _a : -1;\n    }\n  });\n  let changes = [];\n  for (let pos = from; pos <= to;) {\n    let line = state.doc.lineAt(pos);\n    pos = line.to + 1;\n    let indent = getIndentation(context, line.from);\n    if (indent == null) continue;\n    if (!/\\S/.test(line.text)) indent = 0;\n    let cur = /^\\s*/.exec(line.text)[0];\n    let norm = indentString(state, indent);\n    if (cur != norm) {\n      updated[line.from] = indent;\n      changes.push({\n        from: line.from,\n        to: line.from + cur.length,\n        insert: norm\n      });\n    }\n  }\n  return state.changes(changes);\n}\n/**\nIndentation contexts are used when calling [indentation\nservices](https://codemirror.net/6/docs/ref/#language.indentService). They provide helper utilities\nuseful in indentation logic, and can selectively override the\nindentation reported for some lines.\n*/\nclass IndentContext {\n  /**\n  Create an indent context.\n  */\n  constructor(\n  /**\n  The editor state.\n  */\n  state,\n  /**\n  @internal\n  */\n  options = {}) {\n    this.state = state;\n    this.options = options;\n    this.unit = getIndentUnit(state);\n  }\n  /**\n  Get a description of the line at the given position, taking\n  [simulated line\n  breaks](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)\n  into account. If there is such a break at `pos`, the `bias`\n  argument determines whether the part of the line line before or\n  after the break is used.\n  */\n  lineAt(pos, bias = 1) {\n    let line = this.state.doc.lineAt(pos);\n    let {\n      simulateBreak,\n      simulateDoubleBreak\n    } = this.options;\n    if (simulateBreak != null && simulateBreak >= line.from && simulateBreak <= line.to) {\n      if (simulateDoubleBreak && simulateBreak == pos) return {\n        text: \"\",\n        from: pos\n      };else if (bias < 0 ? simulateBreak < pos : simulateBreak <= pos) return {\n        text: line.text.slice(simulateBreak - line.from),\n        from: simulateBreak\n      };else return {\n        text: line.text.slice(0, simulateBreak - line.from),\n        from: line.from\n      };\n    }\n    return line;\n  }\n  /**\n  Get the text directly after `pos`, either the entire line\n  or the next 100 characters, whichever is shorter.\n  */\n  textAfterPos(pos, bias = 1) {\n    if (this.options.simulateDoubleBreak && pos == this.options.simulateBreak) return \"\";\n    let {\n      text,\n      from\n    } = this.lineAt(pos, bias);\n    return text.slice(pos - from, Math.min(text.length, pos + 100 - from));\n  }\n  /**\n  Find the column for the given position.\n  */\n  column(pos, bias = 1) {\n    let {\n      text,\n      from\n    } = this.lineAt(pos, bias);\n    let result = this.countColumn(text, pos - from);\n    let override = this.options.overrideIndentation ? this.options.overrideIndentation(from) : -1;\n    if (override > -1) result += override - this.countColumn(text, text.search(/\\S|$/));\n    return result;\n  }\n  /**\n  Find the column position (taking tabs into account) of the given\n  position in the given string.\n  */\n  countColumn(line, pos = line.length) {\n    return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.countColumn)(line, this.state.tabSize, pos);\n  }\n  /**\n  Find the indentation column of the line at the given point.\n  */\n  lineIndent(pos, bias = 1) {\n    let {\n      text,\n      from\n    } = this.lineAt(pos, bias);\n    let override = this.options.overrideIndentation;\n    if (override) {\n      let overriden = override(from);\n      if (overriden > -1) return overriden;\n    }\n    return this.countColumn(text, text.search(/\\S|$/));\n  }\n  /**\n  Returns the [simulated line\n  break](https://codemirror.net/6/docs/ref/#language.IndentContext.constructor^options.simulateBreak)\n  for this context, if any.\n  */\n  get simulatedBreak() {\n    return this.options.simulateBreak || null;\n  }\n}\n/**\nA syntax tree node prop used to associate indentation strategies\nwith node types. Such a strategy is a function from an indentation\ncontext to a column number (see also\n[`indentString`](https://codemirror.net/6/docs/ref/#language.indentString)) or null, where null\nindicates that no definitive indentation can be determined.\n*/\nconst indentNodeProp = /*@__PURE__*/new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();\n// Compute the indentation for a given position from the syntax tree.\nfunction syntaxIndentation(cx, ast, pos) {\n  let stack = ast.resolveStack(pos);\n  let inner = stack.node.enterUnfinishedNodesBefore(pos);\n  if (inner != stack.node) {\n    let add = [];\n    for (let cur = inner; cur != stack.node; cur = cur.parent) add.push(cur);\n    for (let i = add.length - 1; i >= 0; i--) stack = {\n      node: add[i],\n      next: stack\n    };\n  }\n  return indentFor(stack, cx, pos);\n}\nfunction indentFor(stack, cx, pos) {\n  for (let cur = stack; cur; cur = cur.next) {\n    let strategy = indentStrategy(cur.node);\n    if (strategy) return strategy(TreeIndentContext.create(cx, pos, cur));\n  }\n  return 0;\n}\nfunction ignoreClosed(cx) {\n  return cx.pos == cx.options.simulateBreak && cx.options.simulateDoubleBreak;\n}\nfunction indentStrategy(tree) {\n  let strategy = tree.type.prop(indentNodeProp);\n  if (strategy) return strategy;\n  let first = tree.firstChild,\n    close;\n  if (first && (close = first.type.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.closedBy))) {\n    let last = tree.lastChild,\n      closed = last && close.indexOf(last.name) > -1;\n    return cx => delimitedStrategy(cx, true, 1, undefined, closed && !ignoreClosed(cx) ? last.from : undefined);\n  }\n  return tree.parent == null ? topIndent : null;\n}\nfunction topIndent() {\n  return 0;\n}\n/**\nObjects of this type provide context information and helper\nmethods to indentation functions registered on syntax nodes.\n*/\nclass TreeIndentContext extends IndentContext {\n  constructor(base,\n  /**\n  The position at which indentation is being computed.\n  */\n  pos,\n  /**\n  @internal\n  */\n  context) {\n    super(base.state, base.options);\n    this.base = base;\n    this.pos = pos;\n    this.context = context;\n  }\n  /**\n  The syntax tree node to which the indentation strategy\n  applies.\n  */\n  get node() {\n    return this.context.node;\n  }\n  /**\n  @internal\n  */\n  static create(base, pos, context) {\n    return new TreeIndentContext(base, pos, context);\n  }\n  /**\n  Get the text directly after `this.pos`, either the entire line\n  or the next 100 characters, whichever is shorter.\n  */\n  get textAfter() {\n    return this.textAfterPos(this.pos);\n  }\n  /**\n  Get the indentation at the reference line for `this.node`, which\n  is the line on which it starts, unless there is a node that is\n  _not_ a parent of this node covering the start of that line. If\n  so, the line at the start of that node is tried, again skipping\n  on if it is covered by another such node.\n  */\n  get baseIndent() {\n    return this.baseIndentFor(this.node);\n  }\n  /**\n  Get the indentation for the reference line of the given node\n  (see [`baseIndent`](https://codemirror.net/6/docs/ref/#language.TreeIndentContext.baseIndent)).\n  */\n  baseIndentFor(node) {\n    let line = this.state.doc.lineAt(node.from);\n    // Skip line starts that are covered by a sibling (or cousin, etc)\n    for (;;) {\n      let atBreak = node.resolve(line.from);\n      while (atBreak.parent && atBreak.parent.from == atBreak.from) atBreak = atBreak.parent;\n      if (isParent(atBreak, node)) break;\n      line = this.state.doc.lineAt(atBreak.from);\n    }\n    return this.lineIndent(line.from);\n  }\n  /**\n  Continue looking for indentations in the node's parent nodes,\n  and return the result of that.\n  */\n  continue() {\n    return indentFor(this.context.next, this.base, this.pos);\n  }\n}\nfunction isParent(parent, of) {\n  for (let cur = of; cur; cur = cur.parent) if (parent == cur) return true;\n  return false;\n}\n// Check whether a delimited node is aligned (meaning there are\n// non-skipped nodes on the same line as the opening delimiter). And\n// if so, return the opening token.\nfunction bracketedAligned(context) {\n  let tree = context.node;\n  let openToken = tree.childAfter(tree.from),\n    last = tree.lastChild;\n  if (!openToken) return null;\n  let sim = context.options.simulateBreak;\n  let openLine = context.state.doc.lineAt(openToken.from);\n  let lineEnd = sim == null || sim <= openLine.from ? openLine.to : Math.min(openLine.to, sim);\n  for (let pos = openToken.to;;) {\n    let next = tree.childAfter(pos);\n    if (!next || next == last) return null;\n    if (!next.type.isSkipped) return next.from < lineEnd ? openToken : null;\n    pos = next.to;\n  }\n}\n/**\nAn indentation strategy for delimited (usually bracketed) nodes.\nWill, by default, indent one unit more than the parent's base\nindent unless the line starts with a closing token. When `align`\nis true and there are non-skipped nodes on the node's opening\nline, the content of the node will be aligned with the end of the\nopening node, like this:\n\n    foo(bar,\n        baz)\n*/\nfunction delimitedIndent({\n  closing,\n  align = true,\n  units = 1\n}) {\n  return context => delimitedStrategy(context, align, units, closing);\n}\nfunction delimitedStrategy(context, align, units, closing, closedAt) {\n  let after = context.textAfter,\n    space = after.match(/^\\s*/)[0].length;\n  let closed = closing && after.slice(space, space + closing.length) == closing || closedAt == context.pos + space;\n  let aligned = align ? bracketedAligned(context) : null;\n  if (aligned) return closed ? context.column(aligned.from) : context.column(aligned.to);\n  return context.baseIndent + (closed ? 0 : context.unit * units);\n}\n/**\nAn indentation strategy that aligns a node's content to its base\nindentation.\n*/\nconst flatIndent = context => context.baseIndent;\n/**\nCreates an indentation strategy that, by default, indents\ncontinued lines one unit more than the node's base indentation.\nYou can provide `except` to prevent indentation of lines that\nmatch a pattern (for example `/^else\\b/` in `if`/`else`\nconstructs), and you can change the amount of units used with the\n`units` option.\n*/\nfunction continuedIndent({\n  except,\n  units = 1\n} = {}) {\n  return context => {\n    let matchExcept = except && except.test(context.textAfter);\n    return context.baseIndent + (matchExcept ? 0 : units * context.unit);\n  };\n}\nconst DontIndentBeyond = 200;\n/**\nEnables reindentation on input. When a language defines an\n`indentOnInput` field in its [language\ndata](https://codemirror.net/6/docs/ref/#state.EditorState.languageDataAt), which must hold a regular\nexpression, the line at the cursor will be reindented whenever new\ntext is typed and the input from the start of the line up to the\ncursor matches that regexp.\n\nTo avoid unneccesary reindents, it is recommended to start the\nregexp with `^` (usually followed by `\\s*`), and end it with `$`.\nFor example, `/^\\s*\\}$/` will reindent when a closing brace is\nadded at the start of a line.\n*/\nfunction indentOnInput() {\n  return _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.EditorState.transactionFilter.of(tr => {\n    if (!tr.docChanged || !tr.isUserEvent(\"input.type\") && !tr.isUserEvent(\"input.complete\")) return tr;\n    let rules = tr.startState.languageDataAt(\"indentOnInput\", tr.startState.selection.main.head);\n    if (!rules.length) return tr;\n    let doc = tr.newDoc,\n      {\n        head\n      } = tr.newSelection.main,\n      line = doc.lineAt(head);\n    if (head > line.from + DontIndentBeyond) return tr;\n    let lineStart = doc.sliceString(line.from, head);\n    if (!rules.some(r => r.test(lineStart))) return tr;\n    let {\n        state\n      } = tr,\n      last = -1,\n      changes = [];\n    for (let {\n      head\n    } of state.selection.ranges) {\n      let line = state.doc.lineAt(head);\n      if (line.from == last) continue;\n      last = line.from;\n      let indent = getIndentation(state, line.from);\n      if (indent == null) continue;\n      let cur = /^\\s*/.exec(line.text)[0];\n      let norm = indentString(state, indent);\n      if (cur != norm) changes.push({\n        from: line.from,\n        to: line.from + cur.length,\n        insert: norm\n      });\n    }\n    return changes.length ? [tr, {\n      changes,\n      sequential: true\n    }] : tr;\n  });\n}\n\n/**\nA facet that registers a code folding service. When called with\nthe extent of a line, such a function should return a foldable\nrange that starts on that line (but continues beyond it), if one\ncan be found.\n*/\nconst foldService = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\n/**\nThis node prop is used to associate folding information with\nsyntax node types. Given a syntax node, it should check whether\nthat tree is foldable and return the range that can be collapsed\nwhen it is.\n*/\nconst foldNodeProp = /*@__PURE__*/new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();\n/**\n[Fold](https://codemirror.net/6/docs/ref/#language.foldNodeProp) function that folds everything but\nthe first and the last child of a syntax node. Useful for nodes\nthat start and end with delimiters.\n*/\nfunction foldInside(node) {\n  let first = node.firstChild,\n    last = node.lastChild;\n  return first && first.to < last.from ? {\n    from: first.to,\n    to: last.type.isError ? node.to : last.from\n  } : null;\n}\nfunction syntaxFolding(state, start, end) {\n  let tree = syntaxTree(state);\n  if (tree.length < end) return null;\n  let stack = tree.resolveStack(end, 1);\n  let found = null;\n  for (let iter = stack; iter; iter = iter.next) {\n    let cur = iter.node;\n    if (cur.to <= end || cur.from > end) continue;\n    if (found && cur.from < start) break;\n    let prop = cur.type.prop(foldNodeProp);\n    if (prop && (cur.to < tree.length - 50 || tree.length == state.doc.length || !isUnfinished(cur))) {\n      let value = prop(cur, state);\n      if (value && value.from <= end && value.from >= start && value.to > end) found = value;\n    }\n  }\n  return found;\n}\nfunction isUnfinished(node) {\n  let ch = node.lastChild;\n  return ch && ch.to == node.to && ch.type.isError;\n}\n/**\nCheck whether the given line is foldable. First asks any fold\nservices registered through\n[`foldService`](https://codemirror.net/6/docs/ref/#language.foldService), and if none of them return\na result, tries to query the [fold node\nprop](https://codemirror.net/6/docs/ref/#language.foldNodeProp) of syntax nodes that cover the end\nof the line.\n*/\nfunction foldable(state, lineStart, lineEnd) {\n  for (let service of state.facet(foldService)) {\n    let result = service(state, lineStart, lineEnd);\n    if (result) return result;\n  }\n  return syntaxFolding(state, lineStart, lineEnd);\n}\nfunction mapRange(range, mapping) {\n  let from = mapping.mapPos(range.from, 1),\n    to = mapping.mapPos(range.to, -1);\n  return from >= to ? undefined : {\n    from,\n    to\n  };\n}\n/**\nState effect that can be attached to a transaction to fold the\ngiven range. (You probably only need this in exceptional\ncircumstances—usually you'll just want to let\n[`foldCode`](https://codemirror.net/6/docs/ref/#language.foldCode) and the [fold\ngutter](https://codemirror.net/6/docs/ref/#language.foldGutter) create the transactions.)\n*/\nconst foldEffect = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.define({\n  map: mapRange\n});\n/**\nState effect that unfolds the given range (if it was folded).\n*/\nconst unfoldEffect = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.define({\n  map: mapRange\n});\nfunction selectedLines(view) {\n  let lines = [];\n  for (let {\n    head\n  } of view.state.selection.ranges) {\n    if (lines.some(l => l.from <= head && l.to >= head)) continue;\n    lines.push(view.lineBlockAt(head));\n  }\n  return lines;\n}\n/**\nThe state field that stores the folded ranges (as a [decoration\nset](https://codemirror.net/6/docs/ref/#view.DecorationSet)). Can be passed to\n[`EditorState.toJSON`](https://codemirror.net/6/docs/ref/#state.EditorState.toJSON) and\n[`fromJSON`](https://codemirror.net/6/docs/ref/#state.EditorState^fromJSON) to serialize the fold\nstate.\n*/\nconst foldState = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateField.define({\n  create() {\n    return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.none;\n  },\n  update(folded, tr) {\n    folded = folded.map(tr.changes);\n    for (let e of tr.effects) {\n      if (e.is(foldEffect) && !foldExists(folded, e.value.from, e.value.to)) {\n        let {\n          preparePlaceholder\n        } = tr.state.facet(foldConfig);\n        let widget = !preparePlaceholder ? foldWidget : _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.replace({\n          widget: new PreparedFoldWidget(preparePlaceholder(tr.state, e.value))\n        });\n        folded = folded.update({\n          add: [widget.range(e.value.from, e.value.to)]\n        });\n      } else if (e.is(unfoldEffect)) {\n        folded = folded.update({\n          filter: (from, to) => e.value.from != from || e.value.to != to,\n          filterFrom: e.value.from,\n          filterTo: e.value.to\n        });\n      }\n    }\n    // Clear folded ranges that cover the selection head\n    if (tr.selection) {\n      let onSelection = false,\n        {\n          head\n        } = tr.selection.main;\n      folded.between(head, head, (a, b) => {\n        if (a < head && b > head) onSelection = true;\n      });\n      if (onSelection) folded = folded.update({\n        filterFrom: head,\n        filterTo: head,\n        filter: (a, b) => b <= head || a >= head\n      });\n    }\n    return folded;\n  },\n  provide: f => _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.decorations.from(f),\n  toJSON(folded, state) {\n    let ranges = [];\n    folded.between(0, state.doc.length, (from, to) => {\n      ranges.push(from, to);\n    });\n    return ranges;\n  },\n  fromJSON(value) {\n    if (!Array.isArray(value) || value.length % 2) throw new RangeError(\"Invalid JSON for fold state\");\n    let ranges = [];\n    for (let i = 0; i < value.length;) {\n      let from = value[i++],\n        to = value[i++];\n      if (typeof from != \"number\" || typeof to != \"number\") throw new RangeError(\"Invalid JSON for fold state\");\n      ranges.push(foldWidget.range(from, to));\n    }\n    return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.set(ranges, true);\n  }\n});\n/**\nGet a [range set](https://codemirror.net/6/docs/ref/#state.RangeSet) containing the folded ranges\nin the given state.\n*/\nfunction foldedRanges(state) {\n  return state.field(foldState, false) || _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.empty;\n}\nfunction findFold(state, from, to) {\n  var _a;\n  let found = null;\n  (_a = state.field(foldState, false)) === null || _a === void 0 ? void 0 : _a.between(from, to, (from, to) => {\n    if (!found || found.from > from) found = {\n      from,\n      to\n    };\n  });\n  return found;\n}\nfunction foldExists(folded, from, to) {\n  let found = false;\n  folded.between(from, from, (a, b) => {\n    if (a == from && b == to) found = true;\n  });\n  return found;\n}\nfunction maybeEnable(state, other) {\n  return state.field(foldState, false) ? other : other.concat(_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateEffect.appendConfig.of(codeFolding()));\n}\n/**\nFold the lines that are selected, if possible.\n*/\nconst foldCode = view => {\n  for (let line of selectedLines(view)) {\n    let range = foldable(view.state, line.from, line.to);\n    if (range) {\n      view.dispatch({\n        effects: maybeEnable(view.state, [foldEffect.of(range), announceFold(view, range)])\n      });\n      return true;\n    }\n  }\n  return false;\n};\n/**\nUnfold folded ranges on selected lines.\n*/\nconst unfoldCode = view => {\n  if (!view.state.field(foldState, false)) return false;\n  let effects = [];\n  for (let line of selectedLines(view)) {\n    let folded = findFold(view.state, line.from, line.to);\n    if (folded) effects.push(unfoldEffect.of(folded), announceFold(view, folded, false));\n  }\n  if (effects.length) view.dispatch({\n    effects\n  });\n  return effects.length > 0;\n};\nfunction announceFold(view, range, fold = true) {\n  let lineFrom = view.state.doc.lineAt(range.from).number,\n    lineTo = view.state.doc.lineAt(range.to).number;\n  return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.announce.of(`${view.state.phrase(fold ? \"Folded lines\" : \"Unfolded lines\")} ${lineFrom} ${view.state.phrase(\"to\")} ${lineTo}.`);\n}\n/**\nFold all top-level foldable ranges. Note that, in most cases,\nfolding information will depend on the [syntax\ntree](https://codemirror.net/6/docs/ref/#language.syntaxTree), and folding everything may not work\nreliably when the document hasn't been fully parsed (either\nbecause the editor state was only just initialized, or because the\ndocument is so big that the parser decided not to parse it\nentirely).\n*/\nconst foldAll = view => {\n  let {\n      state\n    } = view,\n    effects = [];\n  for (let pos = 0; pos < state.doc.length;) {\n    let line = view.lineBlockAt(pos),\n      range = foldable(state, line.from, line.to);\n    if (range) effects.push(foldEffect.of(range));\n    pos = (range ? view.lineBlockAt(range.to) : line).to + 1;\n  }\n  if (effects.length) view.dispatch({\n    effects: maybeEnable(view.state, effects)\n  });\n  return !!effects.length;\n};\n/**\nUnfold all folded code.\n*/\nconst unfoldAll = view => {\n  let field = view.state.field(foldState, false);\n  if (!field || !field.size) return false;\n  let effects = [];\n  field.between(0, view.state.doc.length, (from, to) => {\n    effects.push(unfoldEffect.of({\n      from,\n      to\n    }));\n  });\n  view.dispatch({\n    effects\n  });\n  return true;\n};\n// Find the foldable region containing the given line, if one exists\nfunction foldableContainer(view, lineBlock) {\n  // Look backwards through line blocks until we find a foldable region that\n  // intersects with the line\n  for (let line = lineBlock;;) {\n    let foldableRegion = foldable(view.state, line.from, line.to);\n    if (foldableRegion && foldableRegion.to > lineBlock.from) return foldableRegion;\n    if (!line.from) return null;\n    line = view.lineBlockAt(line.from - 1);\n  }\n}\n/**\nToggle folding at cursors. Unfolds if there is an existing fold\nstarting in that line, tries to find a foldable range around it\notherwise.\n*/\nconst toggleFold = view => {\n  let effects = [];\n  for (let line of selectedLines(view)) {\n    let folded = findFold(view.state, line.from, line.to);\n    if (folded) {\n      effects.push(unfoldEffect.of(folded), announceFold(view, folded, false));\n    } else {\n      let foldRange = foldableContainer(view, line);\n      if (foldRange) effects.push(foldEffect.of(foldRange), announceFold(view, foldRange));\n    }\n  }\n  if (effects.length > 0) view.dispatch({\n    effects: maybeEnable(view.state, effects)\n  });\n  return !!effects.length;\n};\n/**\nDefault fold-related key bindings.\n\n - Ctrl-Shift-[ (Cmd-Alt-[ on macOS): [`foldCode`](https://codemirror.net/6/docs/ref/#language.foldCode).\n - Ctrl-Shift-] (Cmd-Alt-] on macOS): [`unfoldCode`](https://codemirror.net/6/docs/ref/#language.unfoldCode).\n - Ctrl-Alt-[: [`foldAll`](https://codemirror.net/6/docs/ref/#language.foldAll).\n - Ctrl-Alt-]: [`unfoldAll`](https://codemirror.net/6/docs/ref/#language.unfoldAll).\n*/\nconst foldKeymap = [{\n  key: \"Ctrl-Shift-[\",\n  mac: \"Cmd-Alt-[\",\n  run: foldCode\n}, {\n  key: \"Ctrl-Shift-]\",\n  mac: \"Cmd-Alt-]\",\n  run: unfoldCode\n}, {\n  key: \"Ctrl-Alt-[\",\n  run: foldAll\n}, {\n  key: \"Ctrl-Alt-]\",\n  run: unfoldAll\n}];\nconst defaultConfig = {\n  placeholderDOM: null,\n  preparePlaceholder: null,\n  placeholderText: \"…\"\n};\nconst foldConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n  combine(values) {\n    return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.combineConfig)(values, defaultConfig);\n  }\n});\n/**\nCreate an extension that configures code folding.\n*/\nfunction codeFolding(config) {\n  let result = [foldState, baseTheme$1];\n  if (config) result.push(foldConfig.of(config));\n  return result;\n}\nfunction widgetToDOM(view, prepared) {\n  let {\n      state\n    } = view,\n    conf = state.facet(foldConfig);\n  let onclick = event => {\n    let line = view.lineBlockAt(view.posAtDOM(event.target));\n    let folded = findFold(view.state, line.from, line.to);\n    if (folded) view.dispatch({\n      effects: unfoldEffect.of(folded)\n    });\n    event.preventDefault();\n  };\n  if (conf.placeholderDOM) return conf.placeholderDOM(view, onclick, prepared);\n  let element = document.createElement(\"span\");\n  element.textContent = conf.placeholderText;\n  element.setAttribute(\"aria-label\", state.phrase(\"folded code\"));\n  element.title = state.phrase(\"unfold\");\n  element.className = \"cm-foldPlaceholder\";\n  element.onclick = onclick;\n  return element;\n}\nconst foldWidget = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.replace({\n  widget: /*@__PURE__*/new class extends _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.WidgetType {\n    toDOM(view) {\n      return widgetToDOM(view, null);\n    }\n  }()\n});\nclass PreparedFoldWidget extends _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.WidgetType {\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n  eq(other) {\n    return this.value == other.value;\n  }\n  toDOM(view) {\n    return widgetToDOM(view, this.value);\n  }\n}\nconst foldGutterDefaults = {\n  openText: \"⌄\",\n  closedText: \"›\",\n  markerDOM: null,\n  domEventHandlers: {},\n  foldingChanged: () => false\n};\nclass FoldMarker extends _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.GutterMarker {\n  constructor(config, open) {\n    super();\n    this.config = config;\n    this.open = open;\n  }\n  eq(other) {\n    return this.config == other.config && this.open == other.open;\n  }\n  toDOM(view) {\n    if (this.config.markerDOM) return this.config.markerDOM(this.open);\n    let span = document.createElement(\"span\");\n    span.textContent = this.open ? this.config.openText : this.config.closedText;\n    span.title = view.state.phrase(this.open ? \"Fold line\" : \"Unfold line\");\n    return span;\n  }\n}\n/**\nCreate an extension that registers a fold gutter, which shows a\nfold status indicator before foldable lines (which can be clicked\nto fold or unfold the line).\n*/\nfunction foldGutter(config = {}) {\n  let fullConfig = Object.assign(Object.assign({}, foldGutterDefaults), config);\n  let canFold = new FoldMarker(fullConfig, true),\n    canUnfold = new FoldMarker(fullConfig, false);\n  let markers = _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.ViewPlugin.fromClass(class {\n    constructor(view) {\n      this.from = view.viewport.from;\n      this.markers = this.buildMarkers(view);\n    }\n    update(update) {\n      if (update.docChanged || update.viewportChanged || update.startState.facet(language) != update.state.facet(language) || update.startState.field(foldState, false) != update.state.field(foldState, false) || syntaxTree(update.startState) != syntaxTree(update.state) || fullConfig.foldingChanged(update)) this.markers = this.buildMarkers(update.view);\n    }\n    buildMarkers(view) {\n      let builder = new _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSetBuilder();\n      for (let line of view.viewportLineBlocks) {\n        let mark = findFold(view.state, line.from, line.to) ? canUnfold : foldable(view.state, line.from, line.to) ? canFold : null;\n        if (mark) builder.add(line.from, line.from, mark);\n      }\n      return builder.finish();\n    }\n  });\n  let {\n    domEventHandlers\n  } = fullConfig;\n  return [markers, (0,_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.gutter)({\n    class: \"cm-foldGutter\",\n    markers(view) {\n      var _a;\n      return ((_a = view.plugin(markers)) === null || _a === void 0 ? void 0 : _a.markers) || _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSet.empty;\n    },\n    initialSpacer() {\n      return new FoldMarker(fullConfig, false);\n    },\n    domEventHandlers: Object.assign(Object.assign({}, domEventHandlers), {\n      click: (view, line, event) => {\n        if (domEventHandlers.click && domEventHandlers.click(view, line, event)) return true;\n        let folded = findFold(view.state, line.from, line.to);\n        if (folded) {\n          view.dispatch({\n            effects: unfoldEffect.of(folded)\n          });\n          return true;\n        }\n        let range = foldable(view.state, line.from, line.to);\n        if (range) {\n          view.dispatch({\n            effects: foldEffect.of(range)\n          });\n          return true;\n        }\n        return false;\n      }\n    })\n  }), codeFolding()];\n}\nconst baseTheme$1 = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.baseTheme({\n  \".cm-foldPlaceholder\": {\n    backgroundColor: \"#eee\",\n    border: \"1px solid #ddd\",\n    color: \"#888\",\n    borderRadius: \".2em\",\n    margin: \"0 1px\",\n    padding: \"0 1px\",\n    cursor: \"pointer\"\n  },\n  \".cm-foldGutter span\": {\n    padding: \"0 1px\",\n    cursor: \"pointer\"\n  }\n});\n\n/**\nA highlight style associates CSS styles with higlighting\n[tags](https://lezer.codemirror.net/docs/ref#highlight.Tag).\n*/\nclass HighlightStyle {\n  constructor(\n  /**\n  The tag styles used to create this highlight style.\n  */\n  specs, options) {\n    this.specs = specs;\n    let modSpec;\n    function def(spec) {\n      let cls = style_mod__WEBPACK_IMPORTED_MODULE_2__.StyleModule.newName();\n      (modSpec || (modSpec = Object.create(null)))[\".\" + cls] = spec;\n      return cls;\n    }\n    const all = typeof options.all == \"string\" ? options.all : options.all ? def(options.all) : undefined;\n    const scopeOpt = options.scope;\n    this.scope = scopeOpt instanceof Language ? type => type.prop(languageDataProp) == scopeOpt.data : scopeOpt ? type => type == scopeOpt : undefined;\n    this.style = (0,_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tagHighlighter)(specs.map(style => ({\n      tag: style.tag,\n      class: style.class || def(Object.assign({}, style, {\n        tag: null\n      }))\n    })), {\n      all\n    }).style;\n    this.module = modSpec ? new style_mod__WEBPACK_IMPORTED_MODULE_2__.StyleModule(modSpec) : null;\n    this.themeType = options.themeType;\n  }\n  /**\n  Create a highlighter style that associates the given styles to\n  the given tags. The specs must be objects that hold a style tag\n  or array of tags in their `tag` property, and either a single\n  `class` property providing a static CSS class (for highlighter\n  that rely on external styling), or a\n  [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style\n  set of CSS properties (which define the styling for those tags).\n  \n  The CSS rules created for a highlighter will be emitted in the\n  order of the spec's properties. That means that for elements that\n  have multiple tags associated with them, styles defined further\n  down in the list will have a higher CSS precedence than styles\n  defined earlier.\n  */\n  static define(specs, options) {\n    return new HighlightStyle(specs, options || {});\n  }\n}\nconst highlighterFacet = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define();\nconst fallbackHighlighter = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n  combine(values) {\n    return values.length ? [values[0]] : null;\n  }\n});\nfunction getHighlighters(state) {\n  let main = state.facet(highlighterFacet);\n  return main.length ? main : state.facet(fallbackHighlighter);\n}\n/**\nWrap a highlighter in an editor extension that uses it to apply\nsyntax highlighting to the editor content.\n\nWhen multiple (non-fallback) styles are provided, the styling\napplied is the union of the classes they emit.\n*/\nfunction syntaxHighlighting(highlighter, options) {\n  let ext = [treeHighlighter],\n    themeType;\n  if (highlighter instanceof HighlightStyle) {\n    if (highlighter.module) ext.push(_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.styleModule.of(highlighter.module));\n    themeType = highlighter.themeType;\n  }\n  if (options === null || options === void 0 ? void 0 : options.fallback) ext.push(fallbackHighlighter.of(highlighter));else if (themeType) ext.push(highlighterFacet.computeN([_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.darkTheme], state => {\n    return state.facet(_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.darkTheme) == (themeType == \"dark\") ? [highlighter] : [];\n  }));else ext.push(highlighterFacet.of(highlighter));\n  return ext;\n}\n/**\nReturns the CSS classes (if any) that the highlighters active in\nthe state would assign to the given style\n[tags](https://lezer.codemirror.net/docs/ref#highlight.Tag) and\n(optional) language\n[scope](https://codemirror.net/6/docs/ref/#language.HighlightStyle^define^options.scope).\n*/\nfunction highlightingFor(state, tags, scope) {\n  let highlighters = getHighlighters(state);\n  let result = null;\n  if (highlighters) for (let highlighter of highlighters) {\n    if (!highlighter.scope || scope && highlighter.scope(scope)) {\n      let cls = highlighter.style(tags);\n      if (cls) result = result ? result + \" \" + cls : cls;\n    }\n  }\n  return result;\n}\nclass TreeHighlighter {\n  constructor(view) {\n    this.markCache = Object.create(null);\n    this.tree = syntaxTree(view.state);\n    this.decorations = this.buildDeco(view, getHighlighters(view.state));\n    this.decoratedTo = view.viewport.to;\n  }\n  update(update) {\n    let tree = syntaxTree(update.state),\n      highlighters = getHighlighters(update.state);\n    let styleChange = highlighters != getHighlighters(update.startState);\n    let {\n        viewport\n      } = update.view,\n      decoratedToMapped = update.changes.mapPos(this.decoratedTo, 1);\n    if (tree.length < viewport.to && !styleChange && tree.type == this.tree.type && decoratedToMapped >= viewport.to) {\n      this.decorations = this.decorations.map(update.changes);\n      this.decoratedTo = decoratedToMapped;\n    } else if (tree != this.tree || update.viewportChanged || styleChange) {\n      this.tree = tree;\n      this.decorations = this.buildDeco(update.view, highlighters);\n      this.decoratedTo = viewport.to;\n    }\n  }\n  buildDeco(view, highlighters) {\n    if (!highlighters || !this.tree.length) return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.none;\n    let builder = new _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSetBuilder();\n    for (let {\n      from,\n      to\n    } of view.visibleRanges) {\n      (0,_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.highlightTree)(this.tree, highlighters, (from, to, style) => {\n        builder.add(from, to, this.markCache[style] || (this.markCache[style] = _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.mark({\n          class: style\n        })));\n      }, from, to);\n    }\n    return builder.finish();\n  }\n}\nconst treeHighlighter = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Prec.high( /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.ViewPlugin.fromClass(TreeHighlighter, {\n  decorations: v => v.decorations\n}));\n/**\nA default highlight style (works well with light themes).\n*/\nconst defaultHighlightStyle = /*@__PURE__*/HighlightStyle.define([{\n  tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.meta,\n  color: \"#404740\"\n}, {\n  tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.link,\n  textDecoration: \"underline\"\n}, {\n  tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.heading,\n  textDecoration: \"underline\",\n  fontWeight: \"bold\"\n}, {\n  tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.emphasis,\n  fontStyle: \"italic\"\n}, {\n  tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.strong,\n  fontWeight: \"bold\"\n}, {\n  tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.strikethrough,\n  textDecoration: \"line-through\"\n}, {\n  tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.keyword,\n  color: \"#708\"\n}, {\n  tag: [_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.atom, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.bool, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.url, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.contentSeparator, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.labelName],\n  color: \"#219\"\n}, {\n  tag: [_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.literal, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.inserted],\n  color: \"#164\"\n}, {\n  tag: [_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.string, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.deleted],\n  color: \"#a11\"\n}, {\n  tag: [_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.regexp, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.escape, /*@__PURE__*/_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.string)],\n  color: \"#e40\"\n}, {\n  tag: /*@__PURE__*/_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName),\n  color: \"#00f\"\n}, {\n  tag: /*@__PURE__*/_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.local(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName),\n  color: \"#30a\"\n}, {\n  tag: [_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.typeName, _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.namespace],\n  color: \"#085\"\n}, {\n  tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.className,\n  color: \"#167\"\n}, {\n  tag: [/*@__PURE__*/_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.special(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.variableName), _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.macroName],\n  color: \"#256\"\n}, {\n  tag: /*@__PURE__*/_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.definition(_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.propertyName),\n  color: \"#00c\"\n}, {\n  tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.comment,\n  color: \"#940\"\n}, {\n  tag: _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags.invalid,\n  color: \"#f00\"\n}]);\nconst baseTheme = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.baseTheme({\n  \"&.cm-focused .cm-matchingBracket\": {\n    backgroundColor: \"#328c8252\"\n  },\n  \"&.cm-focused .cm-nonmatchingBracket\": {\n    backgroundColor: \"#bb555544\"\n  }\n});\nconst DefaultScanDist = 10000,\n  DefaultBrackets = \"()[]{}\";\nconst bracketMatchingConfig = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n  combine(configs) {\n    return (0,_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.combineConfig)(configs, {\n      afterCursor: true,\n      brackets: DefaultBrackets,\n      maxScanDistance: DefaultScanDist,\n      renderMatch: defaultRenderMatch\n    });\n  }\n});\nconst matchingMark = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.mark({\n    class: \"cm-matchingBracket\"\n  }),\n  nonmatchingMark = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.mark({\n    class: \"cm-nonmatchingBracket\"\n  });\nfunction defaultRenderMatch(match) {\n  let decorations = [];\n  let mark = match.matched ? matchingMark : nonmatchingMark;\n  decorations.push(mark.range(match.start.from, match.start.to));\n  if (match.end) decorations.push(mark.range(match.end.from, match.end.to));\n  return decorations;\n}\nconst bracketMatchingState = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.StateField.define({\n  create() {\n    return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.none;\n  },\n  update(deco, tr) {\n    if (!tr.docChanged && !tr.selection) return deco;\n    let decorations = [];\n    let config = tr.state.facet(bracketMatchingConfig);\n    for (let range of tr.state.selection.ranges) {\n      if (!range.empty) continue;\n      let match = matchBrackets(tr.state, range.head, -1, config) || range.head > 0 && matchBrackets(tr.state, range.head - 1, 1, config) || config.afterCursor && (matchBrackets(tr.state, range.head, 1, config) || range.head < tr.state.doc.length && matchBrackets(tr.state, range.head + 1, -1, config));\n      if (match) decorations = decorations.concat(config.renderMatch(match, tr.state));\n    }\n    return _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.set(decorations, true);\n  },\n  provide: f => _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.decorations.from(f)\n});\nconst bracketMatchingUnique = [bracketMatchingState, baseTheme];\n/**\nCreate an extension that enables bracket matching. Whenever the\ncursor is next to a bracket, that bracket and the one it matches\nare highlighted. Or, when no matching bracket is found, another\nhighlighting style is used to indicate this.\n*/\nfunction bracketMatching(config = {}) {\n  return [bracketMatchingConfig.of(config), bracketMatchingUnique];\n}\n/**\nWhen larger syntax nodes, such as HTML tags, are marked as\nopening/closing, it can be a bit messy to treat the whole node as\na matchable bracket. This node prop allows you to define, for such\na node, a ‘handle’—the part of the node that is highlighted, and\nthat the cursor must be on to activate highlighting in the first\nplace.\n*/\nconst bracketMatchingHandle = /*@__PURE__*/new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();\nfunction matchingNodes(node, dir, brackets) {\n  let byProp = node.prop(dir < 0 ? _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.openedBy : _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.closedBy);\n  if (byProp) return byProp;\n  if (node.name.length == 1) {\n    let index = brackets.indexOf(node.name);\n    if (index > -1 && index % 2 == (dir < 0 ? 1 : 0)) return [brackets[index + dir]];\n  }\n  return null;\n}\nfunction findHandle(node) {\n  let hasHandle = node.type.prop(bracketMatchingHandle);\n  return hasHandle ? hasHandle(node.node) : node;\n}\n/**\nFind the matching bracket for the token at `pos`, scanning\ndirection `dir`. Only the `brackets` and `maxScanDistance`\nproperties are used from `config`, if given. Returns null if no\nbracket was found at `pos`, or a match result otherwise.\n*/\nfunction matchBrackets(state, pos, dir, config = {}) {\n  let maxScanDistance = config.maxScanDistance || DefaultScanDist,\n    brackets = config.brackets || DefaultBrackets;\n  let tree = syntaxTree(state),\n    node = tree.resolveInner(pos, dir);\n  for (let cur = node; cur; cur = cur.parent) {\n    let matches = matchingNodes(cur.type, dir, brackets);\n    if (matches && cur.from < cur.to) {\n      let handle = findHandle(cur);\n      if (handle && (dir > 0 ? pos >= handle.from && pos < handle.to : pos > handle.from && pos <= handle.to)) return matchMarkedBrackets(state, pos, dir, cur, handle, matches, brackets);\n    }\n  }\n  return matchPlainBrackets(state, pos, dir, tree, node.type, maxScanDistance, brackets);\n}\nfunction matchMarkedBrackets(_state, _pos, dir, token, handle, matching, brackets) {\n  let parent = token.parent,\n    firstToken = {\n      from: handle.from,\n      to: handle.to\n    };\n  let depth = 0,\n    cursor = parent === null || parent === void 0 ? void 0 : parent.cursor();\n  if (cursor && (dir < 0 ? cursor.childBefore(token.from) : cursor.childAfter(token.to))) do {\n    if (dir < 0 ? cursor.to <= token.from : cursor.from >= token.to) {\n      if (depth == 0 && matching.indexOf(cursor.type.name) > -1 && cursor.from < cursor.to) {\n        let endHandle = findHandle(cursor);\n        return {\n          start: firstToken,\n          end: endHandle ? {\n            from: endHandle.from,\n            to: endHandle.to\n          } : undefined,\n          matched: true\n        };\n      } else if (matchingNodes(cursor.type, dir, brackets)) {\n        depth++;\n      } else if (matchingNodes(cursor.type, -dir, brackets)) {\n        if (depth == 0) {\n          let endHandle = findHandle(cursor);\n          return {\n            start: firstToken,\n            end: endHandle && endHandle.from < endHandle.to ? {\n              from: endHandle.from,\n              to: endHandle.to\n            } : undefined,\n            matched: false\n          };\n        }\n        depth--;\n      }\n    }\n  } while (dir < 0 ? cursor.prevSibling() : cursor.nextSibling());\n  return {\n    start: firstToken,\n    matched: false\n  };\n}\nfunction matchPlainBrackets(state, pos, dir, tree, tokenType, maxScanDistance, brackets) {\n  let startCh = dir < 0 ? state.sliceDoc(pos - 1, pos) : state.sliceDoc(pos, pos + 1);\n  let bracket = brackets.indexOf(startCh);\n  if (bracket < 0 || bracket % 2 == 0 != dir > 0) return null;\n  let startToken = {\n    from: dir < 0 ? pos - 1 : pos,\n    to: dir > 0 ? pos + 1 : pos\n  };\n  let iter = state.doc.iterRange(pos, dir > 0 ? state.doc.length : 0),\n    depth = 0;\n  for (let distance = 0; !iter.next().done && distance <= maxScanDistance;) {\n    let text = iter.value;\n    if (dir < 0) distance += text.length;\n    let basePos = pos + distance * dir;\n    for (let pos = dir > 0 ? 0 : text.length - 1, end = dir > 0 ? text.length : -1; pos != end; pos += dir) {\n      let found = brackets.indexOf(text[pos]);\n      if (found < 0 || tree.resolveInner(basePos + pos, 1).type != tokenType) continue;\n      if (found % 2 == 0 == dir > 0) {\n        depth++;\n      } else if (depth == 1) {\n        // Closing\n        return {\n          start: startToken,\n          end: {\n            from: basePos + pos,\n            to: basePos + pos + 1\n          },\n          matched: found >> 1 == bracket >> 1\n        };\n      } else {\n        depth--;\n      }\n    }\n    if (dir > 0) distance += text.length;\n  }\n  return iter.done ? {\n    start: startToken,\n    matched: false\n  } : null;\n}\n\n// Counts the column offset in a string, taking tabs into account.\n// Used mostly to find indentation.\nfunction countCol(string, end, tabSize, startIndex = 0, startValue = 0) {\n  if (end == null) {\n    end = string.search(/[^\\s\\u00a0]/);\n    if (end == -1) end = string.length;\n  }\n  let n = startValue;\n  for (let i = startIndex; i < end; i++) {\n    if (string.charCodeAt(i) == 9) n += tabSize - n % tabSize;else n++;\n  }\n  return n;\n}\n/**\nEncapsulates a single line of input. Given to stream syntax code,\nwhich uses it to tokenize the content.\n*/\nclass StringStream {\n  /**\n  Create a stream.\n  */\n  constructor(\n  /**\n  The line.\n  */\n  string, tabSize,\n  /**\n  The current indent unit size.\n  */\n  indentUnit, overrideIndent) {\n    this.string = string;\n    this.tabSize = tabSize;\n    this.indentUnit = indentUnit;\n    this.overrideIndent = overrideIndent;\n    /**\n    The current position on the line.\n    */\n    this.pos = 0;\n    /**\n    The start position of the current token.\n    */\n    this.start = 0;\n    this.lastColumnPos = 0;\n    this.lastColumnValue = 0;\n  }\n  /**\n  True if we are at the end of the line.\n  */\n  eol() {\n    return this.pos >= this.string.length;\n  }\n  /**\n  True if we are at the start of the line.\n  */\n  sol() {\n    return this.pos == 0;\n  }\n  /**\n  Get the next code unit after the current position, or undefined\n  if we're at the end of the line.\n  */\n  peek() {\n    return this.string.charAt(this.pos) || undefined;\n  }\n  /**\n  Read the next code unit and advance `this.pos`.\n  */\n  next() {\n    if (this.pos < this.string.length) return this.string.charAt(this.pos++);\n  }\n  /**\n  Match the next character against the given string, regular\n  expression, or predicate. Consume and return it if it matches.\n  */\n  eat(match) {\n    let ch = this.string.charAt(this.pos);\n    let ok;\n    if (typeof match == \"string\") ok = ch == match;else ok = ch && (match instanceof RegExp ? match.test(ch) : match(ch));\n    if (ok) {\n      ++this.pos;\n      return ch;\n    }\n  }\n  /**\n  Continue matching characters that match the given string,\n  regular expression, or predicate function. Return true if any\n  characters were consumed.\n  */\n  eatWhile(match) {\n    let start = this.pos;\n    while (this.eat(match)) {}\n    return this.pos > start;\n  }\n  /**\n  Consume whitespace ahead of `this.pos`. Return true if any was\n  found.\n  */\n  eatSpace() {\n    let start = this.pos;\n    while (/[\\s\\u00a0]/.test(this.string.charAt(this.pos))) ++this.pos;\n    return this.pos > start;\n  }\n  /**\n  Move to the end of the line.\n  */\n  skipToEnd() {\n    this.pos = this.string.length;\n  }\n  /**\n  Move to directly before the given character, if found on the\n  current line.\n  */\n  skipTo(ch) {\n    let found = this.string.indexOf(ch, this.pos);\n    if (found > -1) {\n      this.pos = found;\n      return true;\n    }\n  }\n  /**\n  Move back `n` characters.\n  */\n  backUp(n) {\n    this.pos -= n;\n  }\n  /**\n  Get the column position at `this.pos`.\n  */\n  column() {\n    if (this.lastColumnPos < this.start) {\n      this.lastColumnValue = countCol(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);\n      this.lastColumnPos = this.start;\n    }\n    return this.lastColumnValue;\n  }\n  /**\n  Get the indentation column of the current line.\n  */\n  indentation() {\n    var _a;\n    return (_a = this.overrideIndent) !== null && _a !== void 0 ? _a : countCol(this.string, null, this.tabSize);\n  }\n  /**\n  Match the input against the given string or regular expression\n  (which should start with a `^`). Return true or the regexp match\n  if it matches.\n  \n  Unless `consume` is set to `false`, this will move `this.pos`\n  past the matched text.\n  \n  When matching a string `caseInsensitive` can be set to true to\n  make the match case-insensitive.\n  */\n  match(pattern, consume, caseInsensitive) {\n    if (typeof pattern == \"string\") {\n      let cased = str => caseInsensitive ? str.toLowerCase() : str;\n      let substr = this.string.substr(this.pos, pattern.length);\n      if (cased(substr) == cased(pattern)) {\n        if (consume !== false) this.pos += pattern.length;\n        return true;\n      } else return null;\n    } else {\n      let match = this.string.slice(this.pos).match(pattern);\n      if (match && match.index > 0) return null;\n      if (match && consume !== false) this.pos += match[0].length;\n      return match;\n    }\n  }\n  /**\n  Get the current token.\n  */\n  current() {\n    return this.string.slice(this.start, this.pos);\n  }\n}\nfunction fullParser(spec) {\n  return {\n    name: spec.name || \"\",\n    token: spec.token,\n    blankLine: spec.blankLine || (() => {}),\n    startState: spec.startState || (() => true),\n    copyState: spec.copyState || defaultCopyState,\n    indent: spec.indent || (() => null),\n    languageData: spec.languageData || {},\n    tokenTable: spec.tokenTable || noTokens\n  };\n}\nfunction defaultCopyState(state) {\n  if (typeof state != \"object\") return state;\n  let newState = {};\n  for (let prop in state) {\n    let val = state[prop];\n    newState[prop] = val instanceof Array ? val.slice() : val;\n  }\n  return newState;\n}\nconst IndentedFrom = /*@__PURE__*/new WeakMap();\n/**\nA [language](https://codemirror.net/6/docs/ref/#language.Language) class based on a CodeMirror\n5-style [streaming parser](https://codemirror.net/6/docs/ref/#language.StreamParser).\n*/\nclass StreamLanguage extends Language {\n  constructor(parser) {\n    let data = defineLanguageFacet(parser.languageData);\n    let p = fullParser(parser),\n      self;\n    let impl = new class extends _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Parser {\n      createParse(input, fragments, ranges) {\n        return new Parse(self, input, fragments, ranges);\n      }\n    }();\n    super(data, impl, [indentService.of((cx, pos) => this.getIndent(cx, pos))], parser.name);\n    this.topNode = docID(data);\n    self = this;\n    this.streamParser = p;\n    this.stateAfter = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp({\n      perNode: true\n    });\n    this.tokenTable = parser.tokenTable ? new TokenTable(p.tokenTable) : defaultTokenTable;\n  }\n  /**\n  Define a stream language.\n  */\n  static define(spec) {\n    return new StreamLanguage(spec);\n  }\n  getIndent(cx, pos) {\n    let tree = syntaxTree(cx.state),\n      at = tree.resolve(pos);\n    while (at && at.type != this.topNode) at = at.parent;\n    if (!at) return null;\n    let from = undefined;\n    let {\n      overrideIndentation\n    } = cx.options;\n    if (overrideIndentation) {\n      from = IndentedFrom.get(cx.state);\n      if (from != null && from < pos - 1e4) from = undefined;\n    }\n    let start = findState(this, tree, 0, at.from, from !== null && from !== void 0 ? from : pos),\n      statePos,\n      state;\n    if (start) {\n      state = start.state;\n      statePos = start.pos + 1;\n    } else {\n      state = this.streamParser.startState(cx.unit);\n      statePos = 0;\n    }\n    if (pos - statePos > 10000 /* C.MaxIndentScanDist */) return null;\n    while (statePos < pos) {\n      let line = cx.state.doc.lineAt(statePos),\n        end = Math.min(pos, line.to);\n      if (line.length) {\n        let indentation = overrideIndentation ? overrideIndentation(line.from) : -1;\n        let stream = new StringStream(line.text, cx.state.tabSize, cx.unit, indentation < 0 ? undefined : indentation);\n        while (stream.pos < end - line.from) readToken(this.streamParser.token, stream, state);\n      } else {\n        this.streamParser.blankLine(state, cx.unit);\n      }\n      if (end == pos) break;\n      statePos = line.to + 1;\n    }\n    let line = cx.lineAt(pos);\n    if (overrideIndentation && from == null) IndentedFrom.set(cx.state, line.from);\n    return this.streamParser.indent(state, /^\\s*(.*)/.exec(line.text)[1], cx);\n  }\n  get allowsNesting() {\n    return false;\n  }\n}\nfunction findState(lang, tree, off, startPos, before) {\n  let state = off >= startPos && off + tree.length <= before && tree.prop(lang.stateAfter);\n  if (state) return {\n    state: lang.streamParser.copyState(state),\n    pos: off + tree.length\n  };\n  for (let i = tree.children.length - 1; i >= 0; i--) {\n    let child = tree.children[i],\n      pos = off + tree.positions[i];\n    let found = child instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree && pos < before && findState(lang, child, pos, startPos, before);\n    if (found) return found;\n  }\n  return null;\n}\nfunction cutTree(lang, tree, from, to, inside) {\n  if (inside && from <= 0 && to >= tree.length) return tree;\n  if (!inside && tree.type == lang.topNode) inside = true;\n  for (let i = tree.children.length - 1; i >= 0; i--) {\n    let pos = tree.positions[i],\n      child = tree.children[i],\n      inner;\n    if (pos < to && child instanceof _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree) {\n      if (!(inner = cutTree(lang, child, from - pos, to - pos, inside))) break;\n      return !inside ? inner : new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree(tree.type, tree.children.slice(0, i).concat(inner), tree.positions.slice(0, i + 1), pos + inner.length);\n    }\n  }\n  return null;\n}\nfunction findStartInFragments(lang, fragments, startPos, editorState) {\n  for (let f of fragments) {\n    let from = f.from + (f.openStart ? 25 : 0),\n      to = f.to - (f.openEnd ? 25 : 0);\n    let found = from <= startPos && to > startPos && findState(lang, f.tree, 0 - f.offset, startPos, to),\n      tree;\n    if (found && (tree = cutTree(lang, f.tree, startPos + f.offset, found.pos + f.offset, false))) return {\n      state: found.state,\n      tree\n    };\n  }\n  return {\n    state: lang.streamParser.startState(editorState ? getIndentUnit(editorState) : 4),\n    tree: _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.empty\n  };\n}\nclass Parse {\n  constructor(lang, input, fragments, ranges) {\n    this.lang = lang;\n    this.input = input;\n    this.fragments = fragments;\n    this.ranges = ranges;\n    this.stoppedAt = null;\n    this.chunks = [];\n    this.chunkPos = [];\n    this.chunk = [];\n    this.chunkReused = undefined;\n    this.rangeIndex = 0;\n    this.to = ranges[ranges.length - 1].to;\n    let context = ParseContext.get(),\n      from = ranges[0].from;\n    let {\n      state,\n      tree\n    } = findStartInFragments(lang, fragments, from, context === null || context === void 0 ? void 0 : context.state);\n    this.state = state;\n    this.parsedPos = this.chunkStart = from + tree.length;\n    for (let i = 0; i < tree.children.length; i++) {\n      this.chunks.push(tree.children[i]);\n      this.chunkPos.push(tree.positions[i]);\n    }\n    if (context && this.parsedPos < context.viewport.from - 100000 /* C.MaxDistanceBeforeViewport */) {\n      this.state = this.lang.streamParser.startState(getIndentUnit(context.state));\n      context.skipUntilInView(this.parsedPos, context.viewport.from);\n      this.parsedPos = context.viewport.from;\n    }\n    this.moveRangeIndex();\n  }\n  advance() {\n    let context = ParseContext.get();\n    let parseEnd = this.stoppedAt == null ? this.to : Math.min(this.to, this.stoppedAt);\n    let end = Math.min(parseEnd, this.chunkStart + 2048 /* C.ChunkSize */);\n    if (context) end = Math.min(end, context.viewport.to);\n    while (this.parsedPos < end) this.parseLine(context);\n    if (this.chunkStart < this.parsedPos) this.finishChunk();\n    if (this.parsedPos >= parseEnd) return this.finish();\n    if (context && this.parsedPos >= context.viewport.to) {\n      context.skipUntilInView(this.parsedPos, parseEnd);\n      return this.finish();\n    }\n    return null;\n  }\n  stopAt(pos) {\n    this.stoppedAt = pos;\n  }\n  lineAfter(pos) {\n    let chunk = this.input.chunk(pos);\n    if (!this.input.lineChunks) {\n      let eol = chunk.indexOf(\"\\n\");\n      if (eol > -1) chunk = chunk.slice(0, eol);\n    } else if (chunk == \"\\n\") {\n      chunk = \"\";\n    }\n    return pos + chunk.length <= this.to ? chunk : chunk.slice(0, this.to - pos);\n  }\n  nextLine() {\n    let from = this.parsedPos,\n      line = this.lineAfter(from),\n      end = from + line.length;\n    for (let index = this.rangeIndex;;) {\n      let rangeEnd = this.ranges[index].to;\n      if (rangeEnd >= end) break;\n      line = line.slice(0, rangeEnd - (end - line.length));\n      index++;\n      if (index == this.ranges.length) break;\n      let rangeStart = this.ranges[index].from;\n      let after = this.lineAfter(rangeStart);\n      line += after;\n      end = rangeStart + after.length;\n    }\n    return {\n      line,\n      end\n    };\n  }\n  skipGapsTo(pos, offset, side) {\n    for (;;) {\n      let end = this.ranges[this.rangeIndex].to,\n        offPos = pos + offset;\n      if (side > 0 ? end > offPos : end >= offPos) break;\n      let start = this.ranges[++this.rangeIndex].from;\n      offset += start - end;\n    }\n    return offset;\n  }\n  moveRangeIndex() {\n    while (this.ranges[this.rangeIndex].to < this.parsedPos) this.rangeIndex++;\n  }\n  emitToken(id, from, to, size, offset) {\n    if (this.ranges.length > 1) {\n      offset = this.skipGapsTo(from, offset, 1);\n      from += offset;\n      let len0 = this.chunk.length;\n      offset = this.skipGapsTo(to, offset, -1);\n      to += offset;\n      size += this.chunk.length - len0;\n    }\n    this.chunk.push(id, from, to, size);\n    return offset;\n  }\n  parseLine(context) {\n    let {\n        line,\n        end\n      } = this.nextLine(),\n      offset = 0,\n      {\n        streamParser\n      } = this.lang;\n    let stream = new StringStream(line, context ? context.state.tabSize : 4, context ? getIndentUnit(context.state) : 2);\n    if (stream.eol()) {\n      streamParser.blankLine(this.state, stream.indentUnit);\n    } else {\n      while (!stream.eol()) {\n        let token = readToken(streamParser.token, stream, this.state);\n        if (token) offset = this.emitToken(this.lang.tokenTable.resolve(token), this.parsedPos + stream.start, this.parsedPos + stream.pos, 4, offset);\n        if (stream.start > 10000 /* C.MaxLineLength */) break;\n      }\n    }\n    this.parsedPos = end;\n    this.moveRangeIndex();\n    if (this.parsedPos < this.to) this.parsedPos++;\n  }\n  finishChunk() {\n    let tree = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree.build({\n      buffer: this.chunk,\n      start: this.chunkStart,\n      length: this.parsedPos - this.chunkStart,\n      nodeSet,\n      topID: 0,\n      maxBufferLength: 2048 /* C.ChunkSize */,\n      reused: this.chunkReused\n    });\n    tree = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree(tree.type, tree.children, tree.positions, tree.length, [[this.lang.stateAfter, this.lang.streamParser.copyState(this.state)]]);\n    this.chunks.push(tree);\n    this.chunkPos.push(this.chunkStart - this.ranges[0].from);\n    this.chunk = [];\n    this.chunkReused = undefined;\n    this.chunkStart = this.parsedPos;\n  }\n  finish() {\n    return new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.Tree(this.lang.topNode, this.chunks, this.chunkPos, this.parsedPos - this.ranges[0].from).balance();\n  }\n}\nfunction readToken(token, stream, state) {\n  stream.start = stream.pos;\n  for (let i = 0; i < 10; i++) {\n    let result = token(stream, state);\n    if (stream.pos > stream.start) return result;\n  }\n  throw new Error(\"Stream parser failed to advance stream.\");\n}\nconst noTokens = /*@__PURE__*/Object.create(null);\nconst typeArray = [_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.none];\nconst nodeSet = /*@__PURE__*/new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeSet(typeArray);\nconst warned = [];\n// Cache of node types by name and tags\nconst byTag = /*@__PURE__*/Object.create(null);\nconst defaultTable = /*@__PURE__*/Object.create(null);\nfor (let [legacyName, name] of [[\"variable\", \"variableName\"], [\"variable-2\", \"variableName.special\"], [\"string-2\", \"string.special\"], [\"def\", \"variableName.definition\"], [\"tag\", \"tagName\"], [\"attribute\", \"attributeName\"], [\"type\", \"typeName\"], [\"builtin\", \"variableName.standard\"], [\"qualifier\", \"modifier\"], [\"error\", \"invalid\"], [\"header\", \"heading\"], [\"property\", \"propertyName\"]]) defaultTable[legacyName] = /*@__PURE__*/createTokenType(noTokens, name);\nclass TokenTable {\n  constructor(extra) {\n    this.extra = extra;\n    this.table = Object.assign(Object.create(null), defaultTable);\n  }\n  resolve(tag) {\n    return !tag ? 0 : this.table[tag] || (this.table[tag] = createTokenType(this.extra, tag));\n  }\n}\nconst defaultTokenTable = /*@__PURE__*/new TokenTable(noTokens);\nfunction warnForPart(part, msg) {\n  if (warned.indexOf(part) > -1) return;\n  warned.push(part);\n  console.warn(msg);\n}\nfunction createTokenType(extra, tagStr) {\n  let tags$1 = [];\n  for (let name of tagStr.split(\" \")) {\n    let found = [];\n    for (let part of name.split(\".\")) {\n      let value = extra[part] || _lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.tags[part];\n      if (!value) {\n        warnForPart(part, `Unknown highlighting tag ${part}`);\n      } else if (typeof value == \"function\") {\n        if (!found.length) warnForPart(part, `Modifier ${part} used at start of tag`);else found = found.map(value);\n      } else {\n        if (found.length) warnForPart(part, `Tag ${part} used as modifier`);else found = Array.isArray(value) ? value : [value];\n      }\n    }\n    for (let tag of found) tags$1.push(tag);\n  }\n  if (!tags$1.length) return 0;\n  let name = tagStr.replace(/ /g, \"_\"),\n    key = name + \" \" + tags$1.map(t => t.id);\n  let known = byTag[key];\n  if (known) return known.id;\n  let type = byTag[key] = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.define({\n    id: typeArray.length,\n    name,\n    props: [(0,_lezer_highlight__WEBPACK_IMPORTED_MODULE_1__.styleTags)({\n      [name]: tags$1\n    })]\n  });\n  typeArray.push(type);\n  return type.id;\n}\nfunction docID(data) {\n  let type = _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeType.define({\n    id: typeArray.length,\n    name: \"Document\",\n    props: [languageDataProp.add(() => data)],\n    top: true\n  });\n  typeArray.push(type);\n  return type;\n}\nfunction buildForLine(line) {\n  return line.length <= 4096 && /[\\u0590-\\u05f4\\u0600-\\u06ff\\u0700-\\u08ac\\ufb50-\\ufdff]/.test(line);\n}\nfunction textHasRTL(text) {\n  for (let i = text.iter(); !i.next().done;) if (buildForLine(i.value)) return true;\n  return false;\n}\nfunction changeAddsRTL(change) {\n  let added = false;\n  change.iterChanges((fA, tA, fB, tB, ins) => {\n    if (!added && textHasRTL(ins)) added = true;\n  });\n  return added;\n}\nconst alwaysIsolate = /*@__PURE__*/_codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Facet.define({\n  combine: values => values.some(x => x)\n});\n/**\nMake sure nodes\n[marked](https://lezer.codemirror.net/docs/ref/#common.NodeProp^isolate)\nas isolating for bidirectional text are rendered in a way that\nisolates them from the surrounding text.\n*/\nfunction bidiIsolates(options = {}) {\n  let extensions = [isolateMarks];\n  if (options.alwaysIsolate) extensions.push(alwaysIsolate.of(true));\n  return extensions;\n}\nconst isolateMarks = /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.ViewPlugin.fromClass(class {\n  constructor(view) {\n    this.always = view.state.facet(alwaysIsolate) || view.textDirection != _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Direction.LTR || view.state.facet(_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.perLineTextDirection);\n    this.hasRTL = !this.always && textHasRTL(view.state.doc);\n    this.tree = syntaxTree(view.state);\n    this.decorations = this.always || this.hasRTL ? buildDeco(view, this.tree, this.always) : _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.none;\n  }\n  update(update) {\n    let always = update.state.facet(alwaysIsolate) || update.view.textDirection != _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Direction.LTR || update.state.facet(_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.perLineTextDirection);\n    if (!always && !this.hasRTL && changeAddsRTL(update.changes)) this.hasRTL = true;\n    if (!always && !this.hasRTL) return;\n    let tree = syntaxTree(update.state);\n    if (always != this.always || tree != this.tree || update.docChanged || update.viewportChanged) {\n      this.tree = tree;\n      this.always = always;\n      this.decorations = buildDeco(update.view, tree, always);\n    }\n  }\n}, {\n  provide: plugin => {\n    function access(view) {\n      var _a, _b;\n      return (_b = (_a = view.plugin(plugin)) === null || _a === void 0 ? void 0 : _a.decorations) !== null && _b !== void 0 ? _b : _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.none;\n    }\n    return [_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.outerDecorations.of(access), _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.Prec.lowest(_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.EditorView.bidiIsolatedRanges.of(access))];\n  }\n});\nfunction buildDeco(view, tree, always) {\n  let deco = new _codemirror_state__WEBPACK_IMPORTED_MODULE_3__.RangeSetBuilder();\n  let ranges = view.visibleRanges;\n  if (!always) ranges = clipRTLLines(ranges, view.state.doc);\n  for (let {\n    from,\n    to\n  } of ranges) {\n    tree.iterate({\n      enter: node => {\n        let iso = node.type.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.isolate);\n        if (iso) deco.add(node.from, node.to, marks[iso]);\n      },\n      from,\n      to\n    });\n  }\n  return deco.finish();\n}\nfunction clipRTLLines(ranges, doc) {\n  let cur = doc.iter(),\n    pos = 0,\n    result = [],\n    last = null;\n  for (let {\n    from,\n    to\n  } of ranges) {\n    if (last && last.to > from) {\n      from = last.to;\n      if (from >= to) continue;\n    }\n    if (pos + cur.value.length < from) {\n      cur.next(from - (pos + cur.value.length));\n      pos = from;\n    }\n    for (;;) {\n      let start = pos,\n        end = pos + cur.value.length;\n      if (!cur.lineBreak && buildForLine(cur.value)) {\n        if (last && last.to > start - 10) last.to = Math.min(to, end);else result.push(last = {\n          from: start,\n          to: Math.min(to, end)\n        });\n      }\n      if (end >= to) break;\n      pos = end;\n      cur.next();\n    }\n  }\n  return result;\n}\nconst marks = {\n  rtl: /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.mark({\n    class: \"cm-iso\",\n    inclusive: true,\n    attributes: {\n      dir: \"rtl\"\n    },\n    bidiIsolate: _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Direction.RTL\n  }),\n  ltr: /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.mark({\n    class: \"cm-iso\",\n    inclusive: true,\n    attributes: {\n      dir: \"ltr\"\n    },\n    bidiIsolate: _codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Direction.LTR\n  }),\n  auto: /*@__PURE__*/_codemirror_view__WEBPACK_IMPORTED_MODULE_4__.Decoration.mark({\n    class: \"cm-iso\",\n    inclusive: true,\n    attributes: {\n      dir: \"auto\"\n    },\n    bidiIsolate: null\n  })\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0Bjb2RlbWlycm9yL2xhbmd1YWdlL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBa0c7QUFDMkM7QUFDWjtBQUMvQztBQUMxQztBQUV4QyxJQUFJNkIsRUFBRTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTUMsZ0JBQWdCLEdBQUcsYUFBYSxJQUFJOUIsbURBQVEsQ0FBQyxDQUFDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTK0IsbUJBQW1CQSxDQUFDQyxRQUFRLEVBQUU7RUFDbkMsT0FBT3ZCLG9EQUFLLENBQUN3QixNQUFNLENBQUM7SUFDaEJDLE9BQU8sRUFBRUYsUUFBUSxHQUFHRyxNQUFNLElBQUlBLE1BQU0sQ0FBQ0MsTUFBTSxDQUFDSixRQUFRLENBQUMsR0FBR0s7RUFDNUQsQ0FBQyxDQUFDO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU1DLGVBQWUsR0FBRyxhQUFhLElBQUl0QyxtREFBUSxDQUFDLENBQUM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTXVDLFFBQVEsQ0FBQztFQUNYO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0VBQ0lDLFdBQVdBO0VBQ1g7QUFDSjtBQUNBO0FBQ0E7RUFDSUMsSUFBSSxFQUFFQyxNQUFNLEVBQUVDLGVBQWUsR0FBRyxFQUFFO0VBQ2xDO0FBQ0o7QUFDQTtFQUNJQyxJQUFJLEdBQUcsRUFBRSxFQUFFO0lBQ1AsSUFBSSxDQUFDSCxJQUFJLEdBQUdBLElBQUk7SUFDaEIsSUFBSSxDQUFDRyxJQUFJLEdBQUdBLElBQUk7SUFDaEI7SUFDQTtJQUNBO0lBQ0EsSUFBSSxDQUFDbEMsMERBQVcsQ0FBQ21DLFNBQVMsQ0FBQ0MsY0FBYyxDQUFD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SyxDQUFDO0FBQzNILENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yaWRnZS1jb2RlbWlycm9yLy4uLy4uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9sYW5ndWFnZS9kaXN0L2luZGV4LmpzPzVhOWQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTm9kZVByb3AsIEl0ZXJNb2RlLCBUcmVlLCBUcmVlRnJhZ21lbnQsIFBhcnNlciwgTm9kZVR5cGUsIE5vZGVTZXQgfSBmcm9tICdAbGV6ZXIvY29tbW9uJztcbmltcG9ydCB7IFN0YXRlRWZmZWN0LCBTdGF0ZUZpZWxkLCBGYWNldCwgRWRpdG9yU3RhdGUsIGNvdW50Q29sdW1uLCBjb21iaW5lQ29uZmlnLCBSYW5nZVNldCwgUmFuZ2VTZXRCdWlsZGVyLCBQcmVjIH0gZnJvbSAnQGNvZGVtaXJyb3Ivc3RhdGUnO1xuaW1wb3J0IHsgVmlld1BsdWdpbiwgbG9nRXhjZXB0aW9uLCBFZGl0b3JWaWV3LCBEZWNvcmF0aW9uLCBXaWRnZXRUeXBlLCBndXR0ZXIsIEd1dHRlck1hcmtlciwgRGlyZWN0aW9uIH0gZnJvbSAnQGNvZGVtaXJyb3Ivdmlldyc7XG5pbXBvcnQgeyB0YWdzLCB0YWdIaWdobGlnaHRlciwgaGlnaGxpZ2h0VHJlZSwgc3R5bGVUYWdzIH0gZnJvbSAnQGxlemVyL2hpZ2hsaWdodCc7XG5pbXBvcnQgeyBTdHlsZU1vZHVsZSB9IGZyb20gJ3N0eWxlLW1vZCc7XG5cbnZhciBfYTtcbi8qKlxuTm9kZSBwcm9wIHN0b3JlZCBpbiBhIHBhcnNlcidzIHRvcCBzeW50YXggbm9kZSB0byBwcm92aWRlIHRoZVxuZmFjZXQgdGhhdCBzdG9yZXMgbGFuZ3VhZ2Utc3BlY2lmaWMgZGF0YSBmb3IgdGhhdCBsYW5ndWFnZS5cbiovXG5jb25zdCBsYW5ndWFnZURhdGFQcm9wID0gLypAX19QVVJFX18qL25ldyBOb2RlUHJvcCgpO1xuLyoqXG5IZWxwZXIgZnVuY3Rpb24gdG8gZGVmaW5lIGEgZmFjZXQgKHRvIGJlIGFkZGVkIHRvIHRoZSB0b3Agc3ludGF4XG5ub2RlKHMpIGZvciBhIGxhbmd1YWdlIHZpYVxuW2BsYW5ndWFnZURhdGFQcm9wYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5sYW5ndWFnZURhdGFQcm9wKSksIHRoYXQgd2lsbCBiZVxudXNlZCB0byBhc3NvY2lhdGUgbGFuZ3VhZ2UgZGF0YSB3aXRoIHRoZSBsYW5ndWFnZS4gWW91XG5wcm9iYWJseSBvbmx5IG5lZWQgdGhpcyB3aGVuIHN1YmNsYXNzaW5nXG5bYExhbmd1YWdlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5MYW5ndWFnZSkuXG4qL1xuZnVuY3Rpb24gZGVmaW5lTGFuZ3VhZ2VGYWNldChiYXNlRGF0YSkge1xuICAgIHJldHVybiBGYWNldC5kZWZpbmUoe1xuICAgICAgICBjb21iaW5lOiBiYXNlRGF0YSA/IHZhbHVlcyA9PiB2YWx1ZXMuY29uY2F0KGJhc2VEYXRhKSA6IHVuZGVmaW5lZFxuICAgIH0pO1xufVxuLyoqXG5TeW50YXggbm9kZSBwcm9wIHVzZWQgdG8gcmVnaXN0ZXIgc3VibGFuZ3VhZ2VzLiBTaG91bGQgYmUgYWRkZWQgdG9cbnRoZSB0b3AgbGV2ZWwgbm9kZSB0eXBlIGZvciB0aGUgbGFuZ3VhZ2UuXG4qL1xuY29uc3Qgc3VibGFuZ3VhZ2VQcm9wID0gLypAX19QVVJFX18qL25ldyBOb2RlUHJvcCgpO1xuLyoqXG5BIGxhbmd1YWdlIG9iamVjdCBtYW5hZ2VzIHBhcnNpbmcgYW5kIHBlci1sYW5ndWFnZVxuW21ldGFkYXRhXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmxhbmd1YWdlRGF0YUF0KS4gUGFyc2UgZGF0YSBpc1xubWFuYWdlZCBhcyBhIFtMZXplcl0oaHR0cHM6Ly9sZXplci5jb2RlbWlycm9yLm5ldCkgdHJlZS4gVGhlIGNsYXNzXG5jYW4gYmUgdXNlZCBkaXJlY3RseSwgdmlhIHRoZSBbYExSTGFuZ3VhZ2VgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLkxSTGFuZ3VhZ2UpXG5zdWJjbGFzcyBmb3IgW0xlemVyXShodHRwczovL2xlemVyLmNvZGVtaXJyb3IubmV0LykgTFIgcGFyc2Vycywgb3JcbnZpYSB0aGUgW2BTdHJlYW1MYW5ndWFnZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuU3RyZWFtTGFuZ3VhZ2UpIHN1YmNsYXNzXG5mb3Igc3RyZWFtIHBhcnNlcnMuXG4qL1xuY2xhc3MgTGFuZ3VhZ2Uge1xuICAgIC8qKlxuICAgIENvbnN0cnVjdCBhIGxhbmd1YWdlIG9iamVjdC4gSWYgeW91IG5lZWQgdG8gaW52b2tlIHRoaXNcbiAgICBkaXJlY3RseSwgZmlyc3QgZGVmaW5lIGEgZGF0YSBmYWNldCB3aXRoXG4gICAgW2BkZWZpbmVMYW5ndWFnZUZhY2V0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5kZWZpbmVMYW5ndWFnZUZhY2V0KSwgYW5kIHRoZW5cbiAgICBjb25maWd1cmUgeW91ciBwYXJzZXIgdG8gW2F0dGFjaF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5sYW5ndWFnZURhdGFQcm9wKSBpdFxuICAgIHRvIHRoZSBsYW5ndWFnZSdzIG91dGVyIHN5bnRheCBub2RlLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIFtsYW5ndWFnZSBkYXRhXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLkVkaXRvclN0YXRlLmxhbmd1YWdlRGF0YUF0KSBmYWNldFxuICAgIHVzZWQgZm9yIHRoaXMgbGFuZ3VhZ2UuXG4gICAgKi9cbiAgICBkYXRhLCBwYXJzZXIsIGV4dHJhRXh0ZW5zaW9ucyA9IFtdLCBcbiAgICAvKipcbiAgICBBIGxhbmd1YWdlIG5hbWUuXG4gICAgKi9cbiAgICBuYW1lID0gXCJcIikge1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICAvLyBLbHVkZ2UgdG8gZGVmaW5lIEVkaXRvclN0YXRlLnRyZWUgYXMgYSBkZWJ1Z2dpbmcgaGVscGVyLFxuICAgICAgICAvLyB3aXRob3V0IHRoZSBFZGl0b3JTdGF0ZSBwYWNrYWdlIGFjdHVhbGx5IGtub3dpbmcgYWJvdXRcbiAgICAgICAgLy8gbGFuZ3VhZ2VzIGFuZCBsZXplciB0cmVlcy5cbiAgICAgICAgaWYgKCFFZGl0b3JTdGF0ZS5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoXCJ0cmVlXCIpKVxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEVkaXRvclN0YXRlLnByb3RvdHlwZSwgXCJ0cmVlXCIsIHsgZ2V0KCkgeyByZXR1cm4gc3ludGF4VHJlZSh0aGlzKTsgfSB9KTtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgICAgIHRoaXMuZXh0ZW5zaW9uID0gW1xuICAgICAgICAgICAgbGFuZ3VhZ2Uub2YodGhpcyksXG4gICAgICAgICAgICBFZGl0b3JTdGF0ZS5sYW5ndWFnZURhdGEub2YoKHN0YXRlLCBwb3MsIHNpZGUpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgdG9wID0gdG9wTm9kZUF0KHN0YXRlLCBwb3MsIHNpZGUpLCBkYXRhID0gdG9wLnR5cGUucHJvcChsYW5ndWFnZURhdGFQcm9wKTtcbiAgICAgICAgICAgICAgICBpZiAoIWRhdGEpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgICAgICBsZXQgYmFzZSA9IHN0YXRlLmZhY2V0KGRhdGEpLCBzdWIgPSB0b3AudHlwZS5wcm9wKHN1Ymxhbmd1YWdlUHJvcCk7XG4gICAgICAgICAgICAgICAgaWYgKHN1Yikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgaW5uZXJOb2RlID0gdG9wLnJlc29sdmUocG9zIC0gdG9wLmZyb20sIHNpZGUpO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBzdWJsYW5nIG9mIHN1YilcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdWJsYW5nLnRlc3QoaW5uZXJOb2RlLCBzdGF0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZGF0YSA9IHN0YXRlLmZhY2V0KHN1YmxhbmcuZmFjZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWJsYW5nLnR5cGUgPT0gXCJyZXBsYWNlXCIgPyBkYXRhIDogZGF0YS5jb25jYXQoYmFzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBiYXNlO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgXS5jb25jYXQoZXh0cmFFeHRlbnNpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgUXVlcnkgd2hldGhlciB0aGlzIGxhbmd1YWdlIGlzIGFjdGl2ZSBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gICAgKi9cbiAgICBpc0FjdGl2ZUF0KHN0YXRlLCBwb3MsIHNpZGUgPSAtMSkge1xuICAgICAgICByZXR1cm4gdG9wTm9kZUF0KHN0YXRlLCBwb3MsIHNpZGUpLnR5cGUucHJvcChsYW5ndWFnZURhdGFQcm9wKSA9PSB0aGlzLmRhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGRvY3VtZW50IHJlZ2lvbnMgdGhhdCB3ZXJlIHBhcnNlZCB1c2luZyB0aGlzIGxhbmd1YWdlLlxuICAgIFRoZSByZXR1cm5lZCByZWdpb25zIHdpbGwgX2luY2x1ZGVfIGFueSBuZXN0ZWQgbGFuZ3VhZ2VzIHJvb3RlZFxuICAgIGluIHRoaXMgbGFuZ3VhZ2UsIHdoZW4gdGhvc2UgZXhpc3QuXG4gICAgKi9cbiAgICBmaW5kUmVnaW9ucyhzdGF0ZSkge1xuICAgICAgICBsZXQgbGFuZyA9IHN0YXRlLmZhY2V0KGxhbmd1YWdlKTtcbiAgICAgICAgaWYgKChsYW5nID09PSBudWxsIHx8IGxhbmcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxhbmcuZGF0YSkgPT0gdGhpcy5kYXRhKVxuICAgICAgICAgICAgcmV0dXJuIFt7IGZyb206IDAsIHRvOiBzdGF0ZS5kb2MubGVuZ3RoIH1dO1xuICAgICAgICBpZiAoIWxhbmcgfHwgIWxhbmcuYWxsb3dzTmVzdGluZylcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBsZXQgZXhwbG9yZSA9ICh0cmVlLCBmcm9tKSA9PiB7XG4gICAgICAgICAgICBpZiAodHJlZS5wcm9wKGxhbmd1YWdlRGF0YVByb3ApID09IHRoaXMuZGF0YSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHsgZnJvbSwgdG86IGZyb20gKyB0cmVlLmxlbmd0aCB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgbW91bnQgPSB0cmVlLnByb3AoTm9kZVByb3AubW91bnRlZCk7XG4gICAgICAgICAgICBpZiAobW91bnQpIHtcbiAgICAgICAgICAgICAgICBpZiAobW91bnQudHJlZS5wcm9wKGxhbmd1YWdlRGF0YVByb3ApID09IHRoaXMuZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobW91bnQub3ZlcmxheSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHIgb2YgbW91bnQub3ZlcmxheSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7IGZyb206IHIuZnJvbSArIGZyb20sIHRvOiByLnRvICsgZnJvbSB9KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goeyBmcm9tOiBmcm9tLCB0bzogZnJvbSArIHRyZWUubGVuZ3RoIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1vdW50Lm92ZXJsYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNpemUgPSByZXN1bHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBleHBsb3JlKG1vdW50LnRyZWUsIG1vdW50Lm92ZXJsYXlbMF0uZnJvbSArIGZyb20pO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IHNpemUpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmVlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNoID0gdHJlZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBpZiAoY2ggaW5zdGFuY2VvZiBUcmVlKVxuICAgICAgICAgICAgICAgICAgICBleHBsb3JlKGNoLCB0cmVlLnBvc2l0aW9uc1tpXSArIGZyb20pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBleHBsb3JlKHN5bnRheFRyZWUoc3RhdGUpLCAwKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBsYW5ndWFnZSBhbGxvd3MgbmVzdGVkIGxhbmd1YWdlcy4gVGhlXG4gICAgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiByZXR1cm5zIHRydWUuXG4gICAgKi9cbiAgICBnZXQgYWxsb3dzTmVzdGluZygpIHsgcmV0dXJuIHRydWU7IH1cbn1cbi8qKlxuQGludGVybmFsXG4qL1xuTGFuZ3VhZ2Uuc2V0U3RhdGUgPSAvKkBfX1BVUkVfXyovU3RhdGVFZmZlY3QuZGVmaW5lKCk7XG5mdW5jdGlvbiB0b3BOb2RlQXQoc3RhdGUsIHBvcywgc2lkZSkge1xuICAgIGxldCB0b3BMYW5nID0gc3RhdGUuZmFjZXQobGFuZ3VhZ2UpLCB0cmVlID0gc3ludGF4VHJlZShzdGF0ZSkudG9wTm9kZTtcbiAgICBpZiAoIXRvcExhbmcgfHwgdG9wTGFuZy5hbGxvd3NOZXN0aW5nKSB7XG4gICAgICAgIGZvciAobGV0IG5vZGUgPSB0cmVlOyBub2RlOyBub2RlID0gbm9kZS5lbnRlcihwb3MsIHNpZGUsIEl0ZXJNb2RlLkV4Y2x1ZGVCdWZmZXJzKSlcbiAgICAgICAgICAgIGlmIChub2RlLnR5cGUuaXNUb3ApXG4gICAgICAgICAgICAgICAgdHJlZSA9IG5vZGU7XG4gICAgfVxuICAgIHJldHVybiB0cmVlO1xufVxuLyoqXG5BIHN1YmNsYXNzIG9mIFtgTGFuZ3VhZ2VgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLkxhbmd1YWdlKSBmb3IgdXNlIHdpdGggTGV6ZXJcbltMUiBwYXJzZXJzXShodHRwczovL2xlemVyLmNvZGVtaXJyb3IubmV0L2RvY3MvcmVmI2xyLkxSUGFyc2VyKVxucGFyc2Vycy5cbiovXG5jbGFzcyBMUkxhbmd1YWdlIGV4dGVuZHMgTGFuZ3VhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKGRhdGEsIHBhcnNlciwgbmFtZSkge1xuICAgICAgICBzdXBlcihkYXRhLCBwYXJzZXIsIFtdLCBuYW1lKTtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgfVxuICAgIC8qKlxuICAgIERlZmluZSBhIGxhbmd1YWdlIGZyb20gYSBwYXJzZXIuXG4gICAgKi9cbiAgICBzdGF0aWMgZGVmaW5lKHNwZWMpIHtcbiAgICAgICAgbGV0IGRhdGEgPSBkZWZpbmVMYW5ndWFnZUZhY2V0KHNwZWMubGFuZ3VhZ2VEYXRhKTtcbiAgICAgICAgcmV0dXJuIG5ldyBMUkxhbmd1YWdlKGRhdGEsIHNwZWMucGFyc2VyLmNvbmZpZ3VyZSh7XG4gICAgICAgICAgICBwcm9wczogW2xhbmd1YWdlRGF0YVByb3AuYWRkKHR5cGUgPT4gdHlwZS5pc1RvcCA/IGRhdGEgOiB1bmRlZmluZWQpXVxuICAgICAgICB9KSwgc3BlYy5uYW1lKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIHRoaXMgbGFuZ3VhZ2Ugd2l0aCBhIHJlY29uZmlndXJlZFxuICAgIHZlcnNpb24gb2YgaXRzIHBhcnNlciBhbmQgb3B0aW9uYWxseSBhIG5ldyBuYW1lLlxuICAgICovXG4gICAgY29uZmlndXJlKG9wdGlvbnMsIG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBMUkxhbmd1YWdlKHRoaXMuZGF0YSwgdGhpcy5wYXJzZXIuY29uZmlndXJlKG9wdGlvbnMpLCBuYW1lIHx8IHRoaXMubmFtZSk7XG4gICAgfVxuICAgIGdldCBhbGxvd3NOZXN0aW5nKCkgeyByZXR1cm4gdGhpcy5wYXJzZXIuaGFzV3JhcHBlcnMoKTsgfVxufVxuLyoqXG5HZXQgdGhlIHN5bnRheCB0cmVlIGZvciBhIHN0YXRlLCB3aGljaCBpcyB0aGUgY3VycmVudCAocG9zc2libHlcbmluY29tcGxldGUpIHBhcnNlIHRyZWUgb2YgdGhlIGFjdGl2ZVxuW2xhbmd1YWdlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLkxhbmd1YWdlKSwgb3IgdGhlIGVtcHR5IHRyZWUgaWYgdGhlcmUgaXMgbm9cbmxhbmd1YWdlIGF2YWlsYWJsZS5cbiovXG5mdW5jdGlvbiBzeW50YXhUcmVlKHN0YXRlKSB7XG4gICAgbGV0IGZpZWxkID0gc3RhdGUuZmllbGQoTGFuZ3VhZ2Uuc3RhdGUsIGZhbHNlKTtcbiAgICByZXR1cm4gZmllbGQgPyBmaWVsZC50cmVlIDogVHJlZS5lbXB0eTtcbn1cbi8qKlxuVHJ5IHRvIGdldCBhIHBhcnNlIHRyZWUgdGhhdCBzcGFucyBhdCBsZWFzdCB1cCB0byBgdXB0b2AuIFRoZVxubWV0aG9kIHdpbGwgZG8gYXQgbW9zdCBgdGltZW91dGAgbWlsbGlzZWNvbmRzIG9mIHdvcmsgdG8gcGFyc2VcbnVwIHRvIHRoYXQgcG9pbnQgaWYgdGhlIHRyZWUgaXNuJ3QgYWxyZWFkeSBhdmFpbGFibGUuXG4qL1xuZnVuY3Rpb24gZW5zdXJlU3ludGF4VHJlZShzdGF0ZSwgdXB0bywgdGltZW91dCA9IDUwKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBwYXJzZSA9IChfYSA9IHN0YXRlLmZpZWxkKExhbmd1YWdlLnN0YXRlLCBmYWxzZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb250ZXh0O1xuICAgIGlmICghcGFyc2UpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBvbGRWaWVwb3J0ID0gcGFyc2Uudmlld3BvcnQ7XG4gICAgcGFyc2UudXBkYXRlVmlld3BvcnQoeyBmcm9tOiAwLCB0bzogdXB0byB9KTtcbiAgICBsZXQgcmVzdWx0ID0gcGFyc2UuaXNEb25lKHVwdG8pIHx8IHBhcnNlLndvcmsodGltZW91dCwgdXB0bykgPyBwYXJzZS50cmVlIDogbnVsbDtcbiAgICBwYXJzZS51cGRhdGVWaWV3cG9ydChvbGRWaWVwb3J0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG5RdWVyaWVzIHdoZXRoZXIgdGhlcmUgaXMgYSBmdWxsIHN5bnRheCB0cmVlIGF2YWlsYWJsZSB1cCB0byB0aGVcbmdpdmVuIGRvY3VtZW50IHBvc2l0aW9uLiBJZiB0aGVyZSBpc24ndCwgdGhlIGJhY2tncm91bmQgcGFyc2VcbnByb2Nlc3MgX21pZ2h0XyBzdGlsbCBiZSB3b3JraW5nIGFuZCB1cGRhdGUgdGhlIHRyZWUgZnVydGhlciwgYnV0XG50aGVyZSBpcyBubyBndWFyYW50ZWUgb2YgdGhhdOKAlHRoZSBwYXJzZXIgd2lsbCBbc3RvcFxud29ya2luZ10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5zeW50YXhQYXJzZXJSdW5uaW5nKSB3aGVuIGl0IGhhcyBzcGVudCBhXG5jZXJ0YWluIGFtb3VudCBvZiB0aW1lIG9yIGhhcyBtb3ZlZCBiZXlvbmQgdGhlIHZpc2libGUgdmlld3BvcnQuXG5BbHdheXMgcmV0dXJucyBmYWxzZSBpZiBubyBsYW5ndWFnZSBoYXMgYmVlbiBlbmFibGVkLlxuKi9cbmZ1bmN0aW9uIHN5bnRheFRyZWVBdmFpbGFibGUoc3RhdGUsIHVwdG8gPSBzdGF0ZS5kb2MubGVuZ3RoKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoKF9hID0gc3RhdGUuZmllbGQoTGFuZ3VhZ2Uuc3RhdGUsIGZhbHNlKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbnRleHQuaXNEb25lKHVwdG8pKSB8fCBmYWxzZTtcbn1cbi8qKlxuTW92ZSBwYXJzaW5nIGZvcndhcmQsIGFuZCB1cGRhdGUgdGhlIGVkaXRvciBzdGF0ZSBhZnRlcndhcmRzIHRvXG5yZWZsZWN0IHRoZSBuZXcgdHJlZS4gV2lsbCB3b3JrIGZvciBhdCBtb3N0IGB0aW1lb3V0YFxubWlsbGlzZWNvbmRzLiBSZXR1cm5zIHRydWUgaWYgdGhlIHBhcnNlciBtYW5hZ2VkIGdldCB0byB0aGUgZ2l2ZW5cbnBvc2l0aW9uIGluIHRoYXQgdGltZS5cbiovXG5mdW5jdGlvbiBmb3JjZVBhcnNpbmcodmlldywgdXB0byA9IHZpZXcudmlld3BvcnQudG8sIHRpbWVvdXQgPSAxMDApIHtcbiAgICBsZXQgc3VjY2VzcyA9IGVuc3VyZVN5bnRheFRyZWUodmlldy5zdGF0ZSwgdXB0bywgdGltZW91dCk7XG4gICAgaWYgKHN1Y2Nlc3MgIT0gc3ludGF4VHJlZSh2aWV3LnN0YXRlKSlcbiAgICAgICAgdmlldy5kaXNwYXRjaCh7fSk7XG4gICAgcmV0dXJuICEhc3VjY2Vzcztcbn1cbi8qKlxuVGVsbHMgeW91IHdoZXRoZXIgdGhlIGxhbmd1YWdlIHBhcnNlciBpcyBwbGFubmluZyB0byBkbyBtb3JlXG5wYXJzaW5nIHdvcmsgKGluIGEgYHJlcXVlc3RJZGxlQ2FsbGJhY2tgIHBzZXVkby10aHJlYWQpIG9yIGhhc1xuc3RvcHBlZCBydW5uaW5nLCBlaXRoZXIgYmVjYXVzZSBpdCBwYXJzZWQgdGhlIGVudGlyZSBkb2N1bWVudCxcbmJlY2F1c2UgaXQgc3BlbnQgdG9vIG11Y2ggdGltZSBhbmQgd2FzIGN1dCBvZmYsIG9yIGJlY2F1c2UgdGhlcmVcbmlzIG5vIGxhbmd1YWdlIHBhcnNlciBlbmFibGVkLlxuKi9cbmZ1bmN0aW9uIHN5bnRheFBhcnNlclJ1bm5pbmcodmlldykge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKChfYSA9IHZpZXcucGx1Z2luKHBhcnNlV29ya2VyKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzV29ya2luZygpKSB8fCBmYWxzZTtcbn1cbi8qKlxuTGV6ZXItc3R5bGVcbltgSW5wdXRgXShodHRwczovL2xlemVyLmNvZGVtaXJyb3IubmV0L2RvY3MvcmVmI2NvbW1vbi5JbnB1dClcbm9iamVjdCBmb3IgYSBbYFRleHRgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlRleHQpIG9iamVjdC5cbiovXG5jbGFzcyBEb2NJbnB1dCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGFuIGlucHV0IG9iamVjdCBmb3IgdGhlIGdpdmVuIGRvY3VtZW50LlxuICAgICovXG4gICAgY29uc3RydWN0b3IoZG9jKSB7XG4gICAgICAgIHRoaXMuZG9jID0gZG9jO1xuICAgICAgICB0aGlzLmN1cnNvclBvcyA9IDA7XG4gICAgICAgIHRoaXMuc3RyaW5nID0gXCJcIjtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSBkb2MuaXRlcigpO1xuICAgIH1cbiAgICBnZXQgbGVuZ3RoKCkgeyByZXR1cm4gdGhpcy5kb2MubGVuZ3RoOyB9XG4gICAgc3luY1RvKHBvcykge1xuICAgICAgICB0aGlzLnN0cmluZyA9IHRoaXMuY3Vyc29yLm5leHQocG9zIC0gdGhpcy5jdXJzb3JQb3MpLnZhbHVlO1xuICAgICAgICB0aGlzLmN1cnNvclBvcyA9IHBvcyArIHRoaXMuc3RyaW5nLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3Vyc29yUG9zIC0gdGhpcy5zdHJpbmcubGVuZ3RoO1xuICAgIH1cbiAgICBjaHVuayhwb3MpIHtcbiAgICAgICAgdGhpcy5zeW5jVG8ocG9zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RyaW5nO1xuICAgIH1cbiAgICBnZXQgbGluZUNodW5rcygpIHsgcmV0dXJuIHRydWU7IH1cbiAgICByZWFkKGZyb20sIHRvKSB7XG4gICAgICAgIGxldCBzdHJpbmdTdGFydCA9IHRoaXMuY3Vyc29yUG9zIC0gdGhpcy5zdHJpbmcubGVuZ3RoO1xuICAgICAgICBpZiAoZnJvbSA8IHN0cmluZ1N0YXJ0IHx8IHRvID49IHRoaXMuY3Vyc29yUG9zKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG9jLnNsaWNlU3RyaW5nKGZyb20sIHRvKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKGZyb20gLSBzdHJpbmdTdGFydCwgdG8gLSBzdHJpbmdTdGFydCk7XG4gICAgfVxufVxubGV0IGN1cnJlbnRDb250ZXh0ID0gbnVsbDtcbi8qKlxuQSBwYXJzZSBjb250ZXh0IHByb3ZpZGVkIHRvIHBhcnNlcnMgd29ya2luZyBvbiB0aGUgZWRpdG9yIGNvbnRlbnQuXG4qL1xuY2xhc3MgUGFyc2VDb250ZXh0IHtcbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIsIFxuICAgIC8qKlxuICAgIFRoZSBjdXJyZW50IGVkaXRvciBzdGF0ZS5cbiAgICAqL1xuICAgIHN0YXRlLCBcbiAgICAvKipcbiAgICBUcmVlIGZyYWdtZW50cyB0aGF0IGNhbiBiZSByZXVzZWQgYnkgaW5jcmVtZW50YWwgcmUtcGFyc2VzLlxuICAgICovXG4gICAgZnJhZ21lbnRzID0gW10sIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdHJlZSwgXG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0cmVlTGVuLCBcbiAgICAvKipcbiAgICBUaGUgY3VycmVudCBlZGl0b3Igdmlld3BvcnQgKG9yIHNvbWUgb3ZlcmFwcHJveGltYXRpb25cbiAgICB0aGVyZW9mKS4gSW50ZW5kZWQgdG8gYmUgdXNlZCBmb3Igb3Bwb3J0dW5pc3RpY2FsbHkgYXZvaWRpbmdcbiAgICB3b3JrIChpbiB3aGljaCBjYXNlXG4gICAgW2Bza2lwVW50aWxJblZpZXdgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLlBhcnNlQ29udGV4dC5za2lwVW50aWxJblZpZXcpXG4gICAgc2hvdWxkIGJlIGNhbGxlZCB0byBtYWtlIHN1cmUgdGhlIHBhcnNlciBpcyByZXN0YXJ0ZWQgd2hlbiB0aGVcbiAgICBza2lwcGVkIHJlZ2lvbiBiZWNvbWVzIHZpc2libGUpLlxuICAgICovXG4gICAgdmlld3BvcnQsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgc2tpcHBlZCwgXG4gICAgLyoqXG4gICAgVGhpcyBpcyB3aGVyZSBza2lwcGluZyBwYXJzZXJzIGNhbiByZWdpc3RlciBhIHByb21pc2UgdGhhdCxcbiAgICB3aGVuIHJlc29sdmVkLCB3aWxsIHNjaGVkdWxlIGEgbmV3IHBhcnNlLiBJdCBpcyBjbGVhcmVkIHdoZW5cbiAgICB0aGUgcGFyc2Ugd29ya2VyIHBpY2tzIHVwIHRoZSBwcm9taXNlLiBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHNjaGVkdWxlT24pIHtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy5mcmFnbWVudHMgPSBmcmFnbWVudHM7XG4gICAgICAgIHRoaXMudHJlZSA9IHRyZWU7XG4gICAgICAgIHRoaXMudHJlZUxlbiA9IHRyZWVMZW47XG4gICAgICAgIHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydDtcbiAgICAgICAgdGhpcy5za2lwcGVkID0gc2tpcHBlZDtcbiAgICAgICAgdGhpcy5zY2hlZHVsZU9uID0gc2NoZWR1bGVPbjtcbiAgICAgICAgdGhpcy5wYXJzZSA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy50ZW1wU2tpcHBlZCA9IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGUocGFyc2VyLCBzdGF0ZSwgdmlld3BvcnQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQYXJzZUNvbnRleHQocGFyc2VyLCBzdGF0ZSwgW10sIFRyZWUuZW1wdHksIDAsIHZpZXdwb3J0LCBbXSwgbnVsbCk7XG4gICAgfVxuICAgIHN0YXJ0UGFyc2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlci5zdGFydFBhcnNlKG5ldyBEb2NJbnB1dCh0aGlzLnN0YXRlLmRvYyksIHRoaXMuZnJhZ21lbnRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB3b3JrKHVudGlsLCB1cHRvKSB7XG4gICAgICAgIGlmICh1cHRvICE9IG51bGwgJiYgdXB0byA+PSB0aGlzLnN0YXRlLmRvYy5sZW5ndGgpXG4gICAgICAgICAgICB1cHRvID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAodGhpcy50cmVlICE9IFRyZWUuZW1wdHkgJiYgdGhpcy5pc0RvbmUodXB0byAhPT0gbnVsbCAmJiB1cHRvICE9PSB2b2lkIDAgPyB1cHRvIDogdGhpcy5zdGF0ZS5kb2MubGVuZ3RoKSkge1xuICAgICAgICAgICAgdGhpcy50YWtlVHJlZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMud2l0aENvbnRleHQoKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB1bnRpbCA9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgbGV0IGVuZFRpbWUgPSBEYXRlLm5vdygpICsgdW50aWw7XG4gICAgICAgICAgICAgICAgdW50aWwgPSAoKSA9PiBEYXRlLm5vdygpID4gZW5kVGltZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5wYXJzZSlcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlID0gdGhpcy5zdGFydFBhcnNlKCk7XG4gICAgICAgICAgICBpZiAodXB0byAhPSBudWxsICYmICh0aGlzLnBhcnNlLnN0b3BwZWRBdCA9PSBudWxsIHx8IHRoaXMucGFyc2Uuc3RvcHBlZEF0ID4gdXB0bykgJiZcbiAgICAgICAgICAgICAgICB1cHRvIDwgdGhpcy5zdGF0ZS5kb2MubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRoaXMucGFyc2Uuc3RvcEF0KHVwdG8pO1xuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIGxldCBkb25lID0gdGhpcy5wYXJzZS5hZHZhbmNlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mcmFnbWVudHMgPSB0aGlzLndpdGhvdXRUZW1wU2tpcHBlZChUcmVlRnJhZ21lbnQuYWRkVHJlZShkb25lLCB0aGlzLmZyYWdtZW50cywgdGhpcy5wYXJzZS5zdG9wcGVkQXQgIT0gbnVsbCkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyZWVMZW4gPSAoX2EgPSB0aGlzLnBhcnNlLnN0b3BwZWRBdCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGhpcy5zdGF0ZS5kb2MubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyZWUgPSBkb25lO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudHJlZUxlbiA8ICh1cHRvICE9PSBudWxsICYmIHVwdG8gIT09IHZvaWQgMCA/IHVwdG8gOiB0aGlzLnN0YXRlLmRvYy5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJzZSA9IHRoaXMuc3RhcnRQYXJzZSgpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHVudGlsKCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdGFrZVRyZWUoKSB7XG4gICAgICAgIGxldCBwb3MsIHRyZWU7XG4gICAgICAgIGlmICh0aGlzLnBhcnNlICYmIChwb3MgPSB0aGlzLnBhcnNlLnBhcnNlZFBvcykgPj0gdGhpcy50cmVlTGVuKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJzZS5zdG9wcGVkQXQgPT0gbnVsbCB8fCB0aGlzLnBhcnNlLnN0b3BwZWRBdCA+IHBvcylcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlLnN0b3BBdChwb3MpO1xuICAgICAgICAgICAgdGhpcy53aXRoQ29udGV4dCgoKSA9PiB7IHdoaWxlICghKHRyZWUgPSB0aGlzLnBhcnNlLmFkdmFuY2UoKSkpIHsgfSB9KTtcbiAgICAgICAgICAgIHRoaXMudHJlZUxlbiA9IHBvcztcbiAgICAgICAgICAgIHRoaXMudHJlZSA9IHRyZWU7XG4gICAgICAgICAgICB0aGlzLmZyYWdtZW50cyA9IHRoaXMud2l0aG91dFRlbXBTa2lwcGVkKFRyZWVGcmFnbWVudC5hZGRUcmVlKHRoaXMudHJlZSwgdGhpcy5mcmFnbWVudHMsIHRydWUpKTtcbiAgICAgICAgICAgIHRoaXMucGFyc2UgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdpdGhDb250ZXh0KGYpIHtcbiAgICAgICAgbGV0IHByZXYgPSBjdXJyZW50Q29udGV4dDtcbiAgICAgICAgY3VycmVudENvbnRleHQgPSB0aGlzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGYoKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGN1cnJlbnRDb250ZXh0ID0gcHJldjtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3aXRob3V0VGVtcFNraXBwZWQoZnJhZ21lbnRzKSB7XG4gICAgICAgIGZvciAobGV0IHI7IHIgPSB0aGlzLnRlbXBTa2lwcGVkLnBvcCgpOylcbiAgICAgICAgICAgIGZyYWdtZW50cyA9IGN1dEZyYWdtZW50cyhmcmFnbWVudHMsIHIuZnJvbSwgci50byk7XG4gICAgICAgIHJldHVybiBmcmFnbWVudHM7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY2hhbmdlcyhjaGFuZ2VzLCBuZXdTdGF0ZSkge1xuICAgICAgICBsZXQgeyBmcmFnbWVudHMsIHRyZWUsIHRyZWVMZW4sIHZpZXdwb3J0LCBza2lwcGVkIH0gPSB0aGlzO1xuICAgICAgICB0aGlzLnRha2VUcmVlKCk7XG4gICAgICAgIGlmICghY2hhbmdlcy5lbXB0eSkge1xuICAgICAgICAgICAgbGV0IHJhbmdlcyA9IFtdO1xuICAgICAgICAgICAgY2hhbmdlcy5pdGVyQ2hhbmdlZFJhbmdlcygoZnJvbUEsIHRvQSwgZnJvbUIsIHRvQikgPT4gcmFuZ2VzLnB1c2goeyBmcm9tQSwgdG9BLCBmcm9tQiwgdG9CIH0pKTtcbiAgICAgICAgICAgIGZyYWdtZW50cyA9IFRyZWVGcmFnbWVudC5hcHBseUNoYW5nZXMoZnJhZ21lbnRzLCByYW5nZXMpO1xuICAgICAgICAgICAgdHJlZSA9IFRyZWUuZW1wdHk7XG4gICAgICAgICAgICB0cmVlTGVuID0gMDtcbiAgICAgICAgICAgIHZpZXdwb3J0ID0geyBmcm9tOiBjaGFuZ2VzLm1hcFBvcyh2aWV3cG9ydC5mcm9tLCAtMSksIHRvOiBjaGFuZ2VzLm1hcFBvcyh2aWV3cG9ydC50bywgMSkgfTtcbiAgICAgICAgICAgIGlmICh0aGlzLnNraXBwZWQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgc2tpcHBlZCA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHIgb2YgdGhpcy5za2lwcGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBmcm9tID0gY2hhbmdlcy5tYXBQb3Moci5mcm9tLCAxKSwgdG8gPSBjaGFuZ2VzLm1hcFBvcyhyLnRvLCAtMSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmcm9tIDwgdG8pXG4gICAgICAgICAgICAgICAgICAgICAgICBza2lwcGVkLnB1c2goeyBmcm9tLCB0byB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQYXJzZUNvbnRleHQodGhpcy5wYXJzZXIsIG5ld1N0YXRlLCBmcmFnbWVudHMsIHRyZWUsIHRyZWVMZW4sIHZpZXdwb3J0LCBza2lwcGVkLCB0aGlzLnNjaGVkdWxlT24pO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHVwZGF0ZVZpZXdwb3J0KHZpZXdwb3J0KSB7XG4gICAgICAgIGlmICh0aGlzLnZpZXdwb3J0LmZyb20gPT0gdmlld3BvcnQuZnJvbSAmJiB0aGlzLnZpZXdwb3J0LnRvID09IHZpZXdwb3J0LnRvKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgICAgIGxldCBzdGFydExlbiA9IHRoaXMuc2tpcHBlZC5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5za2lwcGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgeyBmcm9tLCB0byB9ID0gdGhpcy5za2lwcGVkW2ldO1xuICAgICAgICAgICAgaWYgKGZyb20gPCB2aWV3cG9ydC50byAmJiB0byA+IHZpZXdwb3J0LmZyb20pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZyYWdtZW50cyA9IGN1dEZyYWdtZW50cyh0aGlzLmZyYWdtZW50cywgZnJvbSwgdG8pO1xuICAgICAgICAgICAgICAgIHRoaXMuc2tpcHBlZC5zcGxpY2UoaS0tLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5za2lwcGVkLmxlbmd0aCA+PSBzdGFydExlbilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5yZXNldCgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICByZXNldCgpIHtcbiAgICAgICAgaWYgKHRoaXMucGFyc2UpIHtcbiAgICAgICAgICAgIHRoaXMudGFrZVRyZWUoKTtcbiAgICAgICAgICAgIHRoaXMucGFyc2UgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIE5vdGlmeSB0aGUgcGFyc2Ugc2NoZWR1bGVyIHRoYXQgdGhlIGdpdmVuIHJlZ2lvbiB3YXMgc2tpcHBlZFxuICAgIGJlY2F1c2UgaXQgd2Fzbid0IGluIHZpZXcsIGFuZCB0aGUgcGFyc2Ugc2hvdWxkIGJlIHJlc3RhcnRlZFxuICAgIHdoZW4gaXQgY29tZXMgaW50byB2aWV3LlxuICAgICovXG4gICAgc2tpcFVudGlsSW5WaWV3KGZyb20sIHRvKSB7XG4gICAgICAgIHRoaXMuc2tpcHBlZC5wdXNoKHsgZnJvbSwgdG8gfSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHVybnMgYSBwYXJzZXIgaW50ZW5kZWQgdG8gYmUgdXNlZCBhcyBwbGFjZWhvbGRlciB3aGVuXG4gICAgYXN5bmNocm9ub3VzbHkgbG9hZGluZyBhIG5lc3RlZCBwYXJzZXIuIEl0J2xsIHNraXAgaXRzIGlucHV0IGFuZFxuICAgIG1hcmsgaXQgYXMgbm90LXJlYWxseS1wYXJzZWQsIHNvIHRoYXQgdGhlIG5leHQgdXBkYXRlIHdpbGwgcGFyc2VcbiAgICBpdCBhZ2Fpbi5cbiAgICBcbiAgICBXaGVuIGB1bnRpbGAgaXMgZ2l2ZW4sIGEgcmVwYXJzZSB3aWxsIGJlIHNjaGVkdWxlZCB3aGVuIHRoYXRcbiAgICBwcm9taXNlIHJlc29sdmVzLlxuICAgICovXG4gICAgc3RhdGljIGdldFNraXBwaW5nUGFyc2VyKHVudGlsKSB7XG4gICAgICAgIHJldHVybiBuZXcgY2xhc3MgZXh0ZW5kcyBQYXJzZXIge1xuICAgICAgICAgICAgY3JlYXRlUGFyc2UoaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZyb20gPSByYW5nZXNbMF0uZnJvbSwgdG8gPSByYW5nZXNbcmFuZ2VzLmxlbmd0aCAtIDFdLnRvO1xuICAgICAgICAgICAgICAgIGxldCBwYXJzZXIgPSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnNlZFBvczogZnJvbSxcbiAgICAgICAgICAgICAgICAgICAgYWR2YW5jZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjeCA9IGN1cnJlbnRDb250ZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgciBvZiByYW5nZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN4LnRlbXBTa2lwcGVkLnB1c2gocik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHVudGlsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjeC5zY2hlZHVsZU9uID0gY3guc2NoZWR1bGVPbiA/IFByb21pc2UuYWxsKFtjeC5zY2hlZHVsZU9uLCB1bnRpbF0pIDogdW50aWw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcnNlZFBvcyA9IHRvO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBUcmVlKE5vZGVUeXBlLm5vbmUsIFtdLCBbXSwgdG8gLSBmcm9tKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc3RvcHBlZEF0OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBzdG9wQXQoKSB7IH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgaXNEb25lKHVwdG8pIHtcbiAgICAgICAgdXB0byA9IE1hdGgubWluKHVwdG8sIHRoaXMuc3RhdGUuZG9jLmxlbmd0aCk7XG4gICAgICAgIGxldCBmcmFncyA9IHRoaXMuZnJhZ21lbnRzO1xuICAgICAgICByZXR1cm4gdGhpcy50cmVlTGVuID49IHVwdG8gJiYgZnJhZ3MubGVuZ3RoICYmIGZyYWdzWzBdLmZyb20gPT0gMCAmJiBmcmFnc1swXS50byA+PSB1cHRvO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGNvbnRleHQgZm9yIHRoZSBjdXJyZW50IHBhcnNlLCBvciBgbnVsbGAgaWYgbm8gZWRpdG9yXG4gICAgcGFyc2UgaXMgaW4gcHJvZ3Jlc3MuXG4gICAgKi9cbiAgICBzdGF0aWMgZ2V0KCkgeyByZXR1cm4gY3VycmVudENvbnRleHQ7IH1cbn1cbmZ1bmN0aW9uIGN1dEZyYWdtZW50cyhmcmFnbWVudHMsIGZyb20sIHRvKSB7XG4gICAgcmV0dXJuIFRyZWVGcmFnbWVudC5hcHBseUNoYW5nZXMoZnJhZ21lbnRzLCBbeyBmcm9tQTogZnJvbSwgdG9BOiB0bywgZnJvbUI6IGZyb20sIHRvQjogdG8gfV0pO1xufVxuY2xhc3MgTGFuZ3VhZ2VTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLy8gQSBtdXRhYmxlIHBhcnNlIHN0YXRlIHRoYXQgaXMgdXNlZCB0byBwcmVzZXJ2ZSB3b3JrIGRvbmUgZHVyaW5nXG4gICAgLy8gdGhlIGxpZmV0aW1lIG9mIGEgc3RhdGUgd2hlbiBtb3ZpbmcgdG8gdGhlIG5leHQgc3RhdGUuXG4gICAgY29udGV4dCkge1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLnRyZWUgPSBjb250ZXh0LnRyZWU7XG4gICAgfVxuICAgIGFwcGx5KHRyKSB7XG4gICAgICAgIGlmICghdHIuZG9jQ2hhbmdlZCAmJiB0aGlzLnRyZWUgPT0gdGhpcy5jb250ZXh0LnRyZWUpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgbGV0IG5ld0N4ID0gdGhpcy5jb250ZXh0LmNoYW5nZXModHIuY2hhbmdlcywgdHIuc3RhdGUpO1xuICAgICAgICAvLyBJZiB0aGUgcHJldmlvdXMgcGFyc2Ugd2Fzbid0IGRvbmUsIGdvIGZvcndhcmQgb25seSB1cCB0byBpdHNcbiAgICAgICAgLy8gZW5kIHBvc2l0aW9uIG9yIHRoZSBlbmQgb2YgdGhlIHZpZXdwb3J0LCB0byBhdm9pZCBzbG93aW5nIGRvd25cbiAgICAgICAgLy8gc3RhdGUgdXBkYXRlcyB3aXRoIHBhcnNlIHdvcmsgYmV5b25kIHRoZSB2aWV3cG9ydC5cbiAgICAgICAgbGV0IHVwdG8gPSB0aGlzLmNvbnRleHQudHJlZUxlbiA9PSB0ci5zdGFydFN0YXRlLmRvYy5sZW5ndGggPyB1bmRlZmluZWRcbiAgICAgICAgICAgIDogTWF0aC5tYXgodHIuY2hhbmdlcy5tYXBQb3ModGhpcy5jb250ZXh0LnRyZWVMZW4pLCBuZXdDeC52aWV3cG9ydC50byk7XG4gICAgICAgIGlmICghbmV3Q3gud29yaygyMCAvKiBXb3JrLkFwcGx5ICovLCB1cHRvKSlcbiAgICAgICAgICAgIG5ld0N4LnRha2VUcmVlKCk7XG4gICAgICAgIHJldHVybiBuZXcgTGFuZ3VhZ2VTdGF0ZShuZXdDeCk7XG4gICAgfVxuICAgIHN0YXRpYyBpbml0KHN0YXRlKSB7XG4gICAgICAgIGxldCB2cFRvID0gTWF0aC5taW4oMzAwMCAvKiBXb3JrLkluaXRWaWV3cG9ydCAqLywgc3RhdGUuZG9jLmxlbmd0aCk7XG4gICAgICAgIGxldCBwYXJzZVN0YXRlID0gUGFyc2VDb250ZXh0LmNyZWF0ZShzdGF0ZS5mYWNldChsYW5ndWFnZSkucGFyc2VyLCBzdGF0ZSwgeyBmcm9tOiAwLCB0bzogdnBUbyB9KTtcbiAgICAgICAgaWYgKCFwYXJzZVN0YXRlLndvcmsoMjAgLyogV29yay5BcHBseSAqLywgdnBUbykpXG4gICAgICAgICAgICBwYXJzZVN0YXRlLnRha2VUcmVlKCk7XG4gICAgICAgIHJldHVybiBuZXcgTGFuZ3VhZ2VTdGF0ZShwYXJzZVN0YXRlKTtcbiAgICB9XG59XG5MYW5ndWFnZS5zdGF0ZSA9IC8qQF9fUFVSRV9fKi9TdGF0ZUZpZWxkLmRlZmluZSh7XG4gICAgY3JlYXRlOiBMYW5ndWFnZVN0YXRlLmluaXQsXG4gICAgdXBkYXRlKHZhbHVlLCB0cikge1xuICAgICAgICBmb3IgKGxldCBlIG9mIHRyLmVmZmVjdHMpXG4gICAgICAgICAgICBpZiAoZS5pcyhMYW5ndWFnZS5zZXRTdGF0ZSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGUudmFsdWU7XG4gICAgICAgIGlmICh0ci5zdGFydFN0YXRlLmZhY2V0KGxhbmd1YWdlKSAhPSB0ci5zdGF0ZS5mYWNldChsYW5ndWFnZSkpXG4gICAgICAgICAgICByZXR1cm4gTGFuZ3VhZ2VTdGF0ZS5pbml0KHRyLnN0YXRlKTtcbiAgICAgICAgcmV0dXJuIHZhbHVlLmFwcGx5KHRyKTtcbiAgICB9XG59KTtcbmxldCByZXF1ZXN0SWRsZSA9IChjYWxsYmFjaykgPT4ge1xuICAgIGxldCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiBjYWxsYmFjaygpLCA1MDAgLyogV29yay5NYXhQYXVzZSAqLyk7XG4gICAgcmV0dXJuICgpID0+IGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn07XG5pZiAodHlwZW9mIHJlcXVlc3RJZGxlQ2FsbGJhY2sgIT0gXCJ1bmRlZmluZWRcIilcbiAgICByZXF1ZXN0SWRsZSA9IChjYWxsYmFjaykgPT4ge1xuICAgICAgICBsZXQgaWRsZSA9IC0xLCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZGxlID0gcmVxdWVzdElkbGVDYWxsYmFjayhjYWxsYmFjaywgeyB0aW1lb3V0OiA1MDAgLyogV29yay5NYXhQYXVzZSAqLyAtIDEwMCAvKiBXb3JrLk1pblBhdXNlICovIH0pO1xuICAgICAgICB9LCAxMDAgLyogV29yay5NaW5QYXVzZSAqLyk7XG4gICAgICAgIHJldHVybiAoKSA9PiBpZGxlIDwgMCA/IGNsZWFyVGltZW91dCh0aW1lb3V0KSA6IGNhbmNlbElkbGVDYWxsYmFjayhpZGxlKTtcbiAgICB9O1xuY29uc3QgaXNJbnB1dFBlbmRpbmcgPSB0eXBlb2YgbmF2aWdhdG9yICE9IFwidW5kZWZpbmVkXCIgJiYgKChfYSA9IG5hdmlnYXRvci5zY2hlZHVsaW5nKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNJbnB1dFBlbmRpbmcpXG4gICAgPyAoKSA9PiBuYXZpZ2F0b3Iuc2NoZWR1bGluZy5pc0lucHV0UGVuZGluZygpIDogbnVsbDtcbmNvbnN0IHBhcnNlV29ya2VyID0gLypAX19QVVJFX18qL1ZpZXdQbHVnaW4uZnJvbUNsYXNzKGNsYXNzIFBhcnNlV29ya2VyIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgICAgIHRoaXMud29ya2luZyA9IG51bGw7XG4gICAgICAgIHRoaXMud29ya1NjaGVkdWxlZCA9IDA7XG4gICAgICAgIC8vIEVuZCBvZiB0aGUgY3VycmVudCB0aW1lIGNodW5rXG4gICAgICAgIHRoaXMuY2h1bmtFbmQgPSAtMTtcbiAgICAgICAgLy8gTWlsbGlzZWNvbmRzIG9mIGJ1ZGdldCBsZWZ0IGZvciB0aGlzIGNodW5rXG4gICAgICAgIHRoaXMuY2h1bmtCdWRnZXQgPSAtMTtcbiAgICAgICAgdGhpcy53b3JrID0gdGhpcy53b3JrLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc2NoZWR1bGVXb3JrKCk7XG4gICAgfVxuICAgIHVwZGF0ZSh1cGRhdGUpIHtcbiAgICAgICAgbGV0IGN4ID0gdGhpcy52aWV3LnN0YXRlLmZpZWxkKExhbmd1YWdlLnN0YXRlKS5jb250ZXh0O1xuICAgICAgICBpZiAoY3gudXBkYXRlVmlld3BvcnQodXBkYXRlLnZpZXcudmlld3BvcnQpIHx8IHRoaXMudmlldy52aWV3cG9ydC50byA+IGN4LnRyZWVMZW4pXG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlV29yaygpO1xuICAgICAgICBpZiAodXBkYXRlLmRvY0NoYW5nZWQgfHwgdXBkYXRlLnNlbGVjdGlvblNldCkge1xuICAgICAgICAgICAgaWYgKHRoaXMudmlldy5oYXNGb2N1cylcbiAgICAgICAgICAgICAgICB0aGlzLmNodW5rQnVkZ2V0ICs9IDUwIC8qIFdvcmsuQ2hhbmdlQm9udXMgKi87XG4gICAgICAgICAgICB0aGlzLnNjaGVkdWxlV29yaygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hlY2tBc3luY1NjaGVkdWxlKGN4KTtcbiAgICB9XG4gICAgc2NoZWR1bGVXb3JrKCkge1xuICAgICAgICBpZiAodGhpcy53b3JraW5nKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgeyBzdGF0ZSB9ID0gdGhpcy52aWV3LCBmaWVsZCA9IHN0YXRlLmZpZWxkKExhbmd1YWdlLnN0YXRlKTtcbiAgICAgICAgaWYgKGZpZWxkLnRyZWUgIT0gZmllbGQuY29udGV4dC50cmVlIHx8ICFmaWVsZC5jb250ZXh0LmlzRG9uZShzdGF0ZS5kb2MubGVuZ3RoKSlcbiAgICAgICAgICAgIHRoaXMud29ya2luZyA9IHJlcXVlc3RJZGxlKHRoaXMud29yayk7XG4gICAgfVxuICAgIHdvcmsoZGVhZGxpbmUpIHtcbiAgICAgICAgdGhpcy53b3JraW5nID0gbnVsbDtcbiAgICAgICAgbGV0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIGlmICh0aGlzLmNodW5rRW5kIDwgbm93ICYmICh0aGlzLmNodW5rRW5kIDwgMCB8fCB0aGlzLnZpZXcuaGFzRm9jdXMpKSB7IC8vIFN0YXJ0IGEgbmV3IGNodW5rXG4gICAgICAgICAgICB0aGlzLmNodW5rRW5kID0gbm93ICsgMzAwMDAgLyogV29yay5DaHVua1RpbWUgKi87XG4gICAgICAgICAgICB0aGlzLmNodW5rQnVkZ2V0ID0gMzAwMCAvKiBXb3JrLkNodW5rQnVkZ2V0ICovO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNodW5rQnVkZ2V0IDw9IDApXG4gICAgICAgICAgICByZXR1cm47IC8vIE5vIG1vcmUgYnVkZ2V0XG4gICAgICAgIGxldCB7IHN0YXRlLCB2aWV3cG9ydDogeyB0bzogdnBUbyB9IH0gPSB0aGlzLnZpZXcsIGZpZWxkID0gc3RhdGUuZmllbGQoTGFuZ3VhZ2Uuc3RhdGUpO1xuICAgICAgICBpZiAoZmllbGQudHJlZSA9PSBmaWVsZC5jb250ZXh0LnRyZWUgJiYgZmllbGQuY29udGV4dC5pc0RvbmUodnBUbyArIDEwMDAwMCAvKiBXb3JrLk1heFBhcnNlQWhlYWQgKi8pKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsZXQgZW5kVGltZSA9IERhdGUubm93KCkgKyBNYXRoLm1pbih0aGlzLmNodW5rQnVkZ2V0LCAxMDAgLyogV29yay5TbGljZSAqLywgZGVhZGxpbmUgJiYgIWlzSW5wdXRQZW5kaW5nID8gTWF0aC5tYXgoMjUgLyogV29yay5NaW5TbGljZSAqLywgZGVhZGxpbmUudGltZVJlbWFpbmluZygpIC0gNSkgOiAxZTkpO1xuICAgICAgICBsZXQgdmlld3BvcnRGaXJzdCA9IGZpZWxkLmNvbnRleHQudHJlZUxlbiA8IHZwVG8gJiYgc3RhdGUuZG9jLmxlbmd0aCA+IHZwVG8gKyAxMDAwO1xuICAgICAgICBsZXQgZG9uZSA9IGZpZWxkLmNvbnRleHQud29yaygoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gaXNJbnB1dFBlbmRpbmcgJiYgaXNJbnB1dFBlbmRpbmcoKSB8fCBEYXRlLm5vdygpID4gZW5kVGltZTtcbiAgICAgICAgfSwgdnBUbyArICh2aWV3cG9ydEZpcnN0ID8gMCA6IDEwMDAwMCAvKiBXb3JrLk1heFBhcnNlQWhlYWQgKi8pKTtcbiAgICAgICAgdGhpcy5jaHVua0J1ZGdldCAtPSBEYXRlLm5vdygpIC0gbm93O1xuICAgICAgICBpZiAoZG9uZSB8fCB0aGlzLmNodW5rQnVkZ2V0IDw9IDApIHtcbiAgICAgICAgICAgIGZpZWxkLmNvbnRleHQudGFrZVRyZWUoKTtcbiAgICAgICAgICAgIHRoaXMudmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IExhbmd1YWdlLnNldFN0YXRlLm9mKG5ldyBMYW5ndWFnZVN0YXRlKGZpZWxkLmNvbnRleHQpKSB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jaHVua0J1ZGdldCA+IDAgJiYgIShkb25lICYmICF2aWV3cG9ydEZpcnN0KSlcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVXb3JrKCk7XG4gICAgICAgIHRoaXMuY2hlY2tBc3luY1NjaGVkdWxlKGZpZWxkLmNvbnRleHQpO1xuICAgIH1cbiAgICBjaGVja0FzeW5jU2NoZWR1bGUoY3gpIHtcbiAgICAgICAgaWYgKGN4LnNjaGVkdWxlT24pIHtcbiAgICAgICAgICAgIHRoaXMud29ya1NjaGVkdWxlZCsrO1xuICAgICAgICAgICAgY3guc2NoZWR1bGVPblxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHRoaXMuc2NoZWR1bGVXb3JrKCkpXG4gICAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiBsb2dFeGNlcHRpb24odGhpcy52aWV3LnN0YXRlLCBlcnIpKVxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHRoaXMud29ya1NjaGVkdWxlZC0tKTtcbiAgICAgICAgICAgIGN4LnNjaGVkdWxlT24gPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLndvcmtpbmcpXG4gICAgICAgICAgICB0aGlzLndvcmtpbmcoKTtcbiAgICB9XG4gICAgaXNXb3JraW5nKCkge1xuICAgICAgICByZXR1cm4gISEodGhpcy53b3JraW5nIHx8IHRoaXMud29ya1NjaGVkdWxlZCA+IDApO1xuICAgIH1cbn0sIHtcbiAgICBldmVudEhhbmRsZXJzOiB7IGZvY3VzKCkgeyB0aGlzLnNjaGVkdWxlV29yaygpOyB9IH1cbn0pO1xuLyoqXG5UaGUgZmFjZXQgdXNlZCB0byBhc3NvY2lhdGUgYSBsYW5ndWFnZSB3aXRoIGFuIGVkaXRvciBzdGF0ZS4gVXNlZFxuYnkgYExhbmd1YWdlYCBvYmplY3QncyBgZXh0ZW5zaW9uYCBwcm9wZXJ0eSAoc28geW91IGRvbid0IG5lZWQgdG9cbm1hbnVhbGx5IHdyYXAgeW91ciBsYW5ndWFnZXMgaW4gdGhpcykuIENhbiBiZSB1c2VkIHRvIGFjY2VzcyB0aGVcbmN1cnJlbnQgbGFuZ3VhZ2Ugb24gYSBzdGF0ZS5cbiovXG5jb25zdCBsYW5ndWFnZSA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUobGFuZ3VhZ2VzKSB7IHJldHVybiBsYW5ndWFnZXMubGVuZ3RoID8gbGFuZ3VhZ2VzWzBdIDogbnVsbDsgfSxcbiAgICBlbmFibGVzOiBsYW5ndWFnZSA9PiBbXG4gICAgICAgIExhbmd1YWdlLnN0YXRlLFxuICAgICAgICBwYXJzZVdvcmtlcixcbiAgICAgICAgRWRpdG9yVmlldy5jb250ZW50QXR0cmlidXRlcy5jb21wdXRlKFtsYW5ndWFnZV0sIHN0YXRlID0+IHtcbiAgICAgICAgICAgIGxldCBsYW5nID0gc3RhdGUuZmFjZXQobGFuZ3VhZ2UpO1xuICAgICAgICAgICAgcmV0dXJuIGxhbmcgJiYgbGFuZy5uYW1lID8geyBcImRhdGEtbGFuZ3VhZ2VcIjogbGFuZy5uYW1lIH0gOiB7fTtcbiAgICAgICAgfSlcbiAgICBdXG59KTtcbi8qKlxuVGhpcyBjbGFzcyBidW5kbGVzIGEgW2xhbmd1YWdlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLkxhbmd1YWdlKSB3aXRoIGFuXG5vcHRpb25hbCBzZXQgb2Ygc3VwcG9ydGluZyBleHRlbnNpb25zLiBMYW5ndWFnZSBwYWNrYWdlcyBhcmVcbmVuY291cmFnZWQgdG8gZXhwb3J0IGEgZnVuY3Rpb24gdGhhdCBvcHRpb25hbGx5IHRha2VzIGFcbmNvbmZpZ3VyYXRpb24gb2JqZWN0IGFuZCByZXR1cm5zIGEgYExhbmd1YWdlU3VwcG9ydGAgaW5zdGFuY2UsIGFzXG50aGUgbWFpbiB3YXkgZm9yIGNsaWVudCBjb2RlIHRvIHVzZSB0aGUgcGFja2FnZS5cbiovXG5jbGFzcyBMYW5ndWFnZVN1cHBvcnQge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIGxhbmd1YWdlIHN1cHBvcnQgb2JqZWN0LlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIGxhbmd1YWdlIG9iamVjdC5cbiAgICAqL1xuICAgIGxhbmd1YWdlLCBcbiAgICAvKipcbiAgICBBbiBvcHRpb25hbCBzZXQgb2Ygc3VwcG9ydGluZyBleHRlbnNpb25zLiBXaGVuIG5lc3RpbmcgYVxuICAgIGxhbmd1YWdlIGluIGFub3RoZXIgbGFuZ3VhZ2UsIHRoZSBvdXRlciBsYW5ndWFnZSBpcyBlbmNvdXJhZ2VkXG4gICAgdG8gaW5jbHVkZSB0aGUgc3VwcG9ydGluZyBleHRlbnNpb25zIGZvciBpdHMgaW5uZXIgbGFuZ3VhZ2VzXG4gICAgaW4gaXRzIG93biBzZXQgb2Ygc3VwcG9ydCBleHRlbnNpb25zLlxuICAgICovXG4gICAgc3VwcG9ydCA9IFtdKSB7XG4gICAgICAgIHRoaXMubGFuZ3VhZ2UgPSBsYW5ndWFnZTtcbiAgICAgICAgdGhpcy5zdXBwb3J0ID0gc3VwcG9ydDtcbiAgICAgICAgdGhpcy5leHRlbnNpb24gPSBbbGFuZ3VhZ2UsIHN1cHBvcnRdO1xuICAgIH1cbn1cbi8qKlxuTGFuZ3VhZ2UgZGVzY3JpcHRpb25zIGFyZSB1c2VkIHRvIHN0b3JlIG1ldGFkYXRhIGFib3V0IGxhbmd1YWdlc1xuYW5kIHRvIGR5bmFtaWNhbGx5IGxvYWQgdGhlbS4gVGhlaXIgbWFpbiByb2xlIGlzIGZpbmRpbmcgdGhlXG5hcHByb3ByaWF0ZSBsYW5ndWFnZSBmb3IgYSBmaWxlbmFtZSBvciBkeW5hbWljYWxseSBsb2FkaW5nIG5lc3RlZFxucGFyc2Vycy5cbiovXG5jbGFzcyBMYW5ndWFnZURlc2NyaXB0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgbmFtZSBvZiB0aGlzIGxhbmd1YWdlLlxuICAgICovXG4gICAgbmFtZSwgXG4gICAgLyoqXG4gICAgQWx0ZXJuYXRpdmUgbmFtZXMgZm9yIHRoZSBtb2RlIChsb3dlcmNhc2VkLCBpbmNsdWRlcyBgdGhpcy5uYW1lYCkuXG4gICAgKi9cbiAgICBhbGlhcywgXG4gICAgLyoqXG4gICAgRmlsZSBleHRlbnNpb25zIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGxhbmd1YWdlLlxuICAgICovXG4gICAgZXh0ZW5zaW9ucywgXG4gICAgLyoqXG4gICAgT3B0aW9uYWwgZmlsZW5hbWUgcGF0dGVybiB0aGF0IHNob3VsZCBiZSBhc3NvY2lhdGVkIHdpdGggdGhpc1xuICAgIGxhbmd1YWdlLlxuICAgICovXG4gICAgZmlsZW5hbWUsIGxvYWRGdW5jLCBcbiAgICAvKipcbiAgICBJZiB0aGUgbGFuZ3VhZ2UgaGFzIGJlZW4gbG9hZGVkLCB0aGlzIHdpbGwgaG9sZCBpdHMgdmFsdWUuXG4gICAgKi9cbiAgICBzdXBwb3J0ID0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuYWxpYXMgPSBhbGlhcztcbiAgICAgICAgdGhpcy5leHRlbnNpb25zID0gZXh0ZW5zaW9ucztcbiAgICAgICAgdGhpcy5maWxlbmFtZSA9IGZpbGVuYW1lO1xuICAgICAgICB0aGlzLmxvYWRGdW5jID0gbG9hZEZ1bmM7XG4gICAgICAgIHRoaXMuc3VwcG9ydCA9IHN1cHBvcnQ7XG4gICAgICAgIHRoaXMubG9hZGluZyA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgIFN0YXJ0IGxvYWRpbmcgdGhlIHRoZSBsYW5ndWFnZS4gV2lsbCByZXR1cm4gYSBwcm9taXNlIHRoYXRcbiAgICByZXNvbHZlcyB0byBhIFtgTGFuZ3VhZ2VTdXBwb3J0YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5MYW5ndWFnZVN1cHBvcnQpXG4gICAgb2JqZWN0IHdoZW4gdGhlIGxhbmd1YWdlIHN1Y2Nlc3NmdWxseSBsb2Fkcy5cbiAgICAqL1xuICAgIGxvYWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvYWRpbmcgfHwgKHRoaXMubG9hZGluZyA9IHRoaXMubG9hZEZ1bmMoKS50aGVuKHN1cHBvcnQgPT4gdGhpcy5zdXBwb3J0ID0gc3VwcG9ydCwgZXJyID0+IHsgdGhpcy5sb2FkaW5nID0gbnVsbDsgdGhyb3cgZXJyOyB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgIENyZWF0ZSBhIGxhbmd1YWdlIGRlc2NyaXB0aW9uLlxuICAgICovXG4gICAgc3RhdGljIG9mKHNwZWMpIHtcbiAgICAgICAgbGV0IHsgbG9hZCwgc3VwcG9ydCB9ID0gc3BlYztcbiAgICAgICAgaWYgKCFsb2FkKSB7XG4gICAgICAgICAgICBpZiAoIXN1cHBvcnQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJNdXN0IHBhc3MgZWl0aGVyICdsb2FkJyBvciAnc3VwcG9ydCcgdG8gTGFuZ3VhZ2VEZXNjcmlwdGlvbi5vZlwiKTtcbiAgICAgICAgICAgIGxvYWQgPSAoKSA9PiBQcm9taXNlLnJlc29sdmUoc3VwcG9ydCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBMYW5ndWFnZURlc2NyaXB0aW9uKHNwZWMubmFtZSwgKHNwZWMuYWxpYXMgfHwgW10pLmNvbmNhdChzcGVjLm5hbWUpLm1hcChzID0+IHMudG9Mb3dlckNhc2UoKSksIHNwZWMuZXh0ZW5zaW9ucyB8fCBbXSwgc3BlYy5maWxlbmFtZSwgbG9hZCwgc3VwcG9ydCk7XG4gICAgfVxuICAgIC8qKlxuICAgIExvb2sgZm9yIGEgbGFuZ3VhZ2UgaW4gdGhlIGdpdmVuIGFycmF5IG9mIGRlc2NyaXB0aW9ucyB0aGF0XG4gICAgbWF0Y2hlcyB0aGUgZmlsZW5hbWUuIFdpbGwgZmlyc3QgbWF0Y2hcbiAgICBbYGZpbGVuYW1lYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5MYW5ndWFnZURlc2NyaXB0aW9uLmZpbGVuYW1lKSBwYXR0ZXJucyxcbiAgICBhbmQgdGhlbiBbZXh0ZW5zaW9uc10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5MYW5ndWFnZURlc2NyaXB0aW9uLmV4dGVuc2lvbnMpLFxuICAgIGFuZCByZXR1cm4gdGhlIGZpcnN0IGxhbmd1YWdlIHRoYXQgbWF0Y2hlcy5cbiAgICAqL1xuICAgIHN0YXRpYyBtYXRjaEZpbGVuYW1lKGRlc2NzLCBmaWxlbmFtZSkge1xuICAgICAgICBmb3IgKGxldCBkIG9mIGRlc2NzKVxuICAgICAgICAgICAgaWYgKGQuZmlsZW5hbWUgJiYgZC5maWxlbmFtZS50ZXN0KGZpbGVuYW1lKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgbGV0IGV4dCA9IC9cXC4oW14uXSspJC8uZXhlYyhmaWxlbmFtZSk7XG4gICAgICAgIGlmIChleHQpXG4gICAgICAgICAgICBmb3IgKGxldCBkIG9mIGRlc2NzKVxuICAgICAgICAgICAgICAgIGlmIChkLmV4dGVuc2lvbnMuaW5kZXhPZihleHRbMV0pID4gLTEpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgTG9vayBmb3IgYSBsYW5ndWFnZSB3aG9zZSBuYW1lIG9yIGFsaWFzIG1hdGNoZXMgdGhlIHRoZSBnaXZlblxuICAgIG5hbWUgKGNhc2UtaW5zZW5zaXRpdmVseSkuIElmIGBmdXp6eWAgaXMgdHJ1ZSwgYW5kIG5vIGRpcmVjdFxuICAgIG1hdGNocyBpcyBmb3VuZCwgdGhpcydsbCBhbHNvIHNlYXJjaCBmb3IgYSBsYW5ndWFnZSB3aG9zZSBuYW1lXG4gICAgb3IgYWxpYXMgb2NjdXJzIGluIHRoZSBzdHJpbmcgKGZvciBuYW1lcyBzaG9ydGVyIHRoYW4gdGhyZWVcbiAgICBjaGFyYWN0ZXJzLCBvbmx5IHdoZW4gc3Vycm91bmRlZCBieSBub24td29yZCBjaGFyYWN0ZXJzKS5cbiAgICAqL1xuICAgIHN0YXRpYyBtYXRjaExhbmd1YWdlTmFtZShkZXNjcywgbmFtZSwgZnV6enkgPSB0cnVlKSB7XG4gICAgICAgIG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGZvciAobGV0IGQgb2YgZGVzY3MpXG4gICAgICAgICAgICBpZiAoZC5hbGlhcy5zb21lKGEgPT4gYSA9PSBuYW1lKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZDtcbiAgICAgICAgaWYgKGZ1enp5KVxuICAgICAgICAgICAgZm9yIChsZXQgZCBvZiBkZXNjcylcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBhIG9mIGQuYWxpYXMpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZvdW5kID0gbmFtZS5pbmRleE9mKGEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm91bmQgPiAtMSAmJiAoYS5sZW5ndGggPiAyIHx8ICEvXFx3Ly50ZXN0KG5hbWVbZm91bmQgLSAxXSkgJiYgIS9cXHcvLnRlc3QobmFtZVtmb3VuZCArIGEubGVuZ3RoXSkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5cbi8qKlxuRmFjZXQgdGhhdCBkZWZpbmVzIGEgd2F5IHRvIHByb3ZpZGUgYSBmdW5jdGlvbiB0aGF0IGNvbXB1dGVzIHRoZVxuYXBwcm9wcmlhdGUgaW5kZW50YXRpb24gZGVwdGgsIGFzIGEgY29sdW1uIG51bWJlciAoc2VlXG5bYGluZGVudFN0cmluZ2BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuaW5kZW50U3RyaW5nKSksIGF0IHRoZSBzdGFydCBvZiBhIGdpdmVuXG5saW5lLiBBIHJldHVybiB2YWx1ZSBvZiBgbnVsbGAgaW5kaWNhdGVzIG5vIGluZGVudGF0aW9uIGNhbiBiZVxuZGV0ZXJtaW5lZCwgYW5kIHRoZSBsaW5lIHNob3VsZCBpbmhlcml0IHRoZSBpbmRlbnRhdGlvbiBvZiB0aGUgb25lXG5hYm92ZSBpdC4gQSByZXR1cm4gdmFsdWUgb2YgYHVuZGVmaW5lZGAgZGVmZXJzIHRvIHRoZSBuZXh0IGluZGVudFxuc2VydmljZS5cbiovXG5jb25zdCBpbmRlbnRTZXJ2aWNlID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuLyoqXG5GYWNldCBmb3Igb3ZlcnJpZGluZyB0aGUgdW5pdCBieSB3aGljaCBpbmRlbnRhdGlvbiBoYXBwZW5zLiBTaG91bGRcbmJlIGEgc3RyaW5nIGNvbnNpc3RpbmcgZWl0aGVyIGVudGlyZWx5IG9mIHRoZSBzYW1lIHdoaXRlc3BhY2VcbmNoYXJhY3Rlci4gV2hlbiBub3Qgc2V0LCB0aGlzIGRlZmF1bHRzIHRvIDIgc3BhY2VzLlxuKi9cbmNvbnN0IGluZGVudFVuaXQgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lOiB2YWx1ZXMgPT4ge1xuICAgICAgICBpZiAoIXZhbHVlcy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gXCIgIFwiO1xuICAgICAgICBsZXQgdW5pdCA9IHZhbHVlc1swXTtcbiAgICAgICAgaWYgKCF1bml0IHx8IC9cXFMvLnRlc3QodW5pdCkgfHwgQXJyYXkuZnJvbSh1bml0KS5zb21lKGUgPT4gZSAhPSB1bml0WzBdKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5kZW50IHVuaXQ6IFwiICsgSlNPTi5zdHJpbmdpZnkodmFsdWVzWzBdKSk7XG4gICAgICAgIHJldHVybiB1bml0O1xuICAgIH1cbn0pO1xuLyoqXG5SZXR1cm4gdGhlIF9jb2x1bW4gd2lkdGhfIG9mIGFuIGluZGVudCB1bml0IGluIHRoZSBzdGF0ZS5cbkRldGVybWluZWQgYnkgdGhlIFtgaW5kZW50VW5pdGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuaW5kZW50VW5pdClcbmZhY2V0LCBhbmQgW2B0YWJTaXplYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZV50YWJTaXplKSB3aGVuIHRoYXRcbmNvbnRhaW5zIHRhYnMuXG4qL1xuZnVuY3Rpb24gZ2V0SW5kZW50VW5pdChzdGF0ZSkge1xuICAgIGxldCB1bml0ID0gc3RhdGUuZmFjZXQoaW5kZW50VW5pdCk7XG4gICAgcmV0dXJuIHVuaXQuY2hhckNvZGVBdCgwKSA9PSA5ID8gc3RhdGUudGFiU2l6ZSAqIHVuaXQubGVuZ3RoIDogdW5pdC5sZW5ndGg7XG59XG4vKipcbkNyZWF0ZSBhbiBpbmRlbnRhdGlvbiBzdHJpbmcgdGhhdCBjb3ZlcnMgY29sdW1ucyAwIHRvIGBjb2xzYC5cbldpbGwgdXNlIHRhYnMgZm9yIGFzIG11Y2ggb2YgdGhlIGNvbHVtbnMgYXMgcG9zc2libGUgd2hlbiB0aGVcbltgaW5kZW50VW5pdGBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuaW5kZW50VW5pdCkgZmFjZXQgY29udGFpbnNcbnRhYnMuXG4qL1xuZnVuY3Rpb24gaW5kZW50U3RyaW5nKHN0YXRlLCBjb2xzKSB7XG4gICAgbGV0IHJlc3VsdCA9IFwiXCIsIHRzID0gc3RhdGUudGFiU2l6ZSwgY2ggPSBzdGF0ZS5mYWNldChpbmRlbnRVbml0KVswXTtcbiAgICBpZiAoY2ggPT0gXCJcXHRcIikge1xuICAgICAgICB3aGlsZSAoY29scyA+PSB0cykge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFwiXFx0XCI7XG4gICAgICAgICAgICBjb2xzIC09IHRzO1xuICAgICAgICB9XG4gICAgICAgIGNoID0gXCIgXCI7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29sczsgaSsrKVxuICAgICAgICByZXN1bHQgKz0gY2g7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbi8qKlxuR2V0IHRoZSBpbmRlbnRhdGlvbiwgYXMgYSBjb2x1bW4gbnVtYmVyLCBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24uXG5XaWxsIGZpcnN0IGNvbnN1bHQgYW55IFtpbmRlbnQgc2VydmljZXNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuaW5kZW50U2VydmljZSlcbnRoYXQgYXJlIHJlZ2lzdGVyZWQsIGFuZCBpZiBub25lIG9mIHRob3NlIHJldHVybiBhbiBpbmRlbnRhdGlvbixcbnRoaXMgd2lsbCBjaGVjayB0aGUgc3ludGF4IHRyZWUgZm9yIHRoZSBbaW5kZW50IG5vZGVcbnByb3BdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuaW5kZW50Tm9kZVByb3ApIGFuZCB1c2UgdGhhdCBpZiBmb3VuZC4gUmV0dXJucyBhXG5udW1iZXIgd2hlbiBhbiBpbmRlbnRhdGlvbiBjb3VsZCBiZSBkZXRlcm1pbmVkLCBhbmQgbnVsbFxub3RoZXJ3aXNlLlxuKi9cbmZ1bmN0aW9uIGdldEluZGVudGF0aW9uKGNvbnRleHQsIHBvcykge1xuICAgIGlmIChjb250ZXh0IGluc3RhbmNlb2YgRWRpdG9yU3RhdGUpXG4gICAgICAgIGNvbnRleHQgPSBuZXcgSW5kZW50Q29udGV4dChjb250ZXh0KTtcbiAgICBmb3IgKGxldCBzZXJ2aWNlIG9mIGNvbnRleHQuc3RhdGUuZmFjZXQoaW5kZW50U2VydmljZSkpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHNlcnZpY2UoY29udGV4dCwgcG9zKTtcbiAgICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgbGV0IHRyZWUgPSBzeW50YXhUcmVlKGNvbnRleHQuc3RhdGUpO1xuICAgIHJldHVybiB0cmVlLmxlbmd0aCA+PSBwb3MgPyBzeW50YXhJbmRlbnRhdGlvbihjb250ZXh0LCB0cmVlLCBwb3MpIDogbnVsbDtcbn1cbi8qKlxuQ3JlYXRlIGEgY2hhbmdlIHNldCB0aGF0IGF1dG8taW5kZW50cyBhbGwgbGluZXMgdG91Y2hlZCBieSB0aGVcbmdpdmVuIGRvY3VtZW50IHJhbmdlLlxuKi9cbmZ1bmN0aW9uIGluZGVudFJhbmdlKHN0YXRlLCBmcm9tLCB0bykge1xuICAgIGxldCB1cGRhdGVkID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBsZXQgY29udGV4dCA9IG5ldyBJbmRlbnRDb250ZXh0KHN0YXRlLCB7IG92ZXJyaWRlSW5kZW50YXRpb246IHN0YXJ0ID0+IHsgdmFyIF9hOyByZXR1cm4gKF9hID0gdXBkYXRlZFtzdGFydF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IC0xOyB9IH0pO1xuICAgIGxldCBjaGFuZ2VzID0gW107XG4gICAgZm9yIChsZXQgcG9zID0gZnJvbTsgcG9zIDw9IHRvOykge1xuICAgICAgICBsZXQgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQocG9zKTtcbiAgICAgICAgcG9zID0gbGluZS50byArIDE7XG4gICAgICAgIGxldCBpbmRlbnQgPSBnZXRJbmRlbnRhdGlvbihjb250ZXh0LCBsaW5lLmZyb20pO1xuICAgICAgICBpZiAoaW5kZW50ID09IG51bGwpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKCEvXFxTLy50ZXN0KGxpbmUudGV4dCkpXG4gICAgICAgICAgICBpbmRlbnQgPSAwO1xuICAgICAgICBsZXQgY3VyID0gL15cXHMqLy5leGVjKGxpbmUudGV4dClbMF07XG4gICAgICAgIGxldCBub3JtID0gaW5kZW50U3RyaW5nKHN0YXRlLCBpbmRlbnQpO1xuICAgICAgICBpZiAoY3VyICE9IG5vcm0pIHtcbiAgICAgICAgICAgIHVwZGF0ZWRbbGluZS5mcm9tXSA9IGluZGVudDtcbiAgICAgICAgICAgIGNoYW5nZXMucHVzaCh7IGZyb206IGxpbmUuZnJvbSwgdG86IGxpbmUuZnJvbSArIGN1ci5sZW5ndGgsIGluc2VydDogbm9ybSB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RhdGUuY2hhbmdlcyhjaGFuZ2VzKTtcbn1cbi8qKlxuSW5kZW50YXRpb24gY29udGV4dHMgYXJlIHVzZWQgd2hlbiBjYWxsaW5nIFtpbmRlbnRhdGlvblxuc2VydmljZXNdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuaW5kZW50U2VydmljZSkuIFRoZXkgcHJvdmlkZSBoZWxwZXIgdXRpbGl0aWVzXG51c2VmdWwgaW4gaW5kZW50YXRpb24gbG9naWMsIGFuZCBjYW4gc2VsZWN0aXZlbHkgb3ZlcnJpZGUgdGhlXG5pbmRlbnRhdGlvbiByZXBvcnRlZCBmb3Igc29tZSBsaW5lcy5cbiovXG5jbGFzcyBJbmRlbnRDb250ZXh0IHtcbiAgICAvKipcbiAgICBDcmVhdGUgYW4gaW5kZW50IGNvbnRleHQuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgZWRpdG9yIHN0YXRlLlxuICAgICovXG4gICAgc3RhdGUsIFxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy51bml0ID0gZ2V0SW5kZW50VW5pdChzdGF0ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCBhIGRlc2NyaXB0aW9uIG9mIHRoZSBsaW5lIGF0IHRoZSBnaXZlbiBwb3NpdGlvbiwgdGFraW5nXG4gICAgW3NpbXVsYXRlZCBsaW5lXG4gICAgYnJlYWtzXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLkluZGVudENvbnRleHQuY29uc3RydWN0b3Jeb3B0aW9ucy5zaW11bGF0ZUJyZWFrKVxuICAgIGludG8gYWNjb3VudC4gSWYgdGhlcmUgaXMgc3VjaCBhIGJyZWFrIGF0IGBwb3NgLCB0aGUgYGJpYXNgXG4gICAgYXJndW1lbnQgZGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBwYXJ0IG9mIHRoZSBsaW5lIGxpbmUgYmVmb3JlIG9yXG4gICAgYWZ0ZXIgdGhlIGJyZWFrIGlzIHVzZWQuXG4gICAgKi9cbiAgICBsaW5lQXQocG9zLCBiaWFzID0gMSkge1xuICAgICAgICBsZXQgbGluZSA9IHRoaXMuc3RhdGUuZG9jLmxpbmVBdChwb3MpO1xuICAgICAgICBsZXQgeyBzaW11bGF0ZUJyZWFrLCBzaW11bGF0ZURvdWJsZUJyZWFrIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGlmIChzaW11bGF0ZUJyZWFrICE9IG51bGwgJiYgc2ltdWxhdGVCcmVhayA+PSBsaW5lLmZyb20gJiYgc2ltdWxhdGVCcmVhayA8PSBsaW5lLnRvKSB7XG4gICAgICAgICAgICBpZiAoc2ltdWxhdGVEb3VibGVCcmVhayAmJiBzaW11bGF0ZUJyZWFrID09IHBvcylcbiAgICAgICAgICAgICAgICByZXR1cm4geyB0ZXh0OiBcIlwiLCBmcm9tOiBwb3MgfTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGJpYXMgPCAwID8gc2ltdWxhdGVCcmVhayA8IHBvcyA6IHNpbXVsYXRlQnJlYWsgPD0gcG9zKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHRleHQ6IGxpbmUudGV4dC5zbGljZShzaW11bGF0ZUJyZWFrIC0gbGluZS5mcm9tKSwgZnJvbTogc2ltdWxhdGVCcmVhayB9O1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHRleHQ6IGxpbmUudGV4dC5zbGljZSgwLCBzaW11bGF0ZUJyZWFrIC0gbGluZS5mcm9tKSwgZnJvbTogbGluZS5mcm9tIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpbmU7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgdGV4dCBkaXJlY3RseSBhZnRlciBgcG9zYCwgZWl0aGVyIHRoZSBlbnRpcmUgbGluZVxuICAgIG9yIHRoZSBuZXh0IDEwMCBjaGFyYWN0ZXJzLCB3aGljaGV2ZXIgaXMgc2hvcnRlci5cbiAgICAqL1xuICAgIHRleHRBZnRlclBvcyhwb3MsIGJpYXMgPSAxKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2ltdWxhdGVEb3VibGVCcmVhayAmJiBwb3MgPT0gdGhpcy5vcHRpb25zLnNpbXVsYXRlQnJlYWspXG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgbGV0IHsgdGV4dCwgZnJvbSB9ID0gdGhpcy5saW5lQXQocG9zLCBiaWFzKTtcbiAgICAgICAgcmV0dXJuIHRleHQuc2xpY2UocG9zIC0gZnJvbSwgTWF0aC5taW4odGV4dC5sZW5ndGgsIHBvcyArIDEwMCAtIGZyb20pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgRmluZCB0aGUgY29sdW1uIGZvciB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gICAgKi9cbiAgICBjb2x1bW4ocG9zLCBiaWFzID0gMSkge1xuICAgICAgICBsZXQgeyB0ZXh0LCBmcm9tIH0gPSB0aGlzLmxpbmVBdChwb3MsIGJpYXMpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5jb3VudENvbHVtbih0ZXh0LCBwb3MgLSBmcm9tKTtcbiAgICAgICAgbGV0IG92ZXJyaWRlID0gdGhpcy5vcHRpb25zLm92ZXJyaWRlSW5kZW50YXRpb24gPyB0aGlzLm9wdGlvbnMub3ZlcnJpZGVJbmRlbnRhdGlvbihmcm9tKSA6IC0xO1xuICAgICAgICBpZiAob3ZlcnJpZGUgPiAtMSlcbiAgICAgICAgICAgIHJlc3VsdCArPSBvdmVycmlkZSAtIHRoaXMuY291bnRDb2x1bW4odGV4dCwgdGV4dC5zZWFyY2goL1xcU3wkLykpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBGaW5kIHRoZSBjb2x1bW4gcG9zaXRpb24gKHRha2luZyB0YWJzIGludG8gYWNjb3VudCkgb2YgdGhlIGdpdmVuXG4gICAgcG9zaXRpb24gaW4gdGhlIGdpdmVuIHN0cmluZy5cbiAgICAqL1xuICAgIGNvdW50Q29sdW1uKGxpbmUsIHBvcyA9IGxpbmUubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBjb3VudENvbHVtbihsaW5lLCB0aGlzLnN0YXRlLnRhYlNpemUsIHBvcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIEZpbmQgdGhlIGluZGVudGF0aW9uIGNvbHVtbiBvZiB0aGUgbGluZSBhdCB0aGUgZ2l2ZW4gcG9pbnQuXG4gICAgKi9cbiAgICBsaW5lSW5kZW50KHBvcywgYmlhcyA9IDEpIHtcbiAgICAgICAgbGV0IHsgdGV4dCwgZnJvbSB9ID0gdGhpcy5saW5lQXQocG9zLCBiaWFzKTtcbiAgICAgICAgbGV0IG92ZXJyaWRlID0gdGhpcy5vcHRpb25zLm92ZXJyaWRlSW5kZW50YXRpb247XG4gICAgICAgIGlmIChvdmVycmlkZSkge1xuICAgICAgICAgICAgbGV0IG92ZXJyaWRlbiA9IG92ZXJyaWRlKGZyb20pO1xuICAgICAgICAgICAgaWYgKG92ZXJyaWRlbiA+IC0xKVxuICAgICAgICAgICAgICAgIHJldHVybiBvdmVycmlkZW47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY291bnRDb2x1bW4odGV4dCwgdGV4dC5zZWFyY2goL1xcU3wkLykpO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIHRoZSBbc2ltdWxhdGVkIGxpbmVcbiAgICBicmVha10oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5JbmRlbnRDb250ZXh0LmNvbnN0cnVjdG9yXm9wdGlvbnMuc2ltdWxhdGVCcmVhaylcbiAgICBmb3IgdGhpcyBjb250ZXh0LCBpZiBhbnkuXG4gICAgKi9cbiAgICBnZXQgc2ltdWxhdGVkQnJlYWsoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMuc2ltdWxhdGVCcmVhayB8fCBudWxsO1xuICAgIH1cbn1cbi8qKlxuQSBzeW50YXggdHJlZSBub2RlIHByb3AgdXNlZCB0byBhc3NvY2lhdGUgaW5kZW50YXRpb24gc3RyYXRlZ2llc1xud2l0aCBub2RlIHR5cGVzLiBTdWNoIGEgc3RyYXRlZ3kgaXMgYSBmdW5jdGlvbiBmcm9tIGFuIGluZGVudGF0aW9uXG5jb250ZXh0IHRvIGEgY29sdW1uIG51bWJlciAoc2VlIGFsc29cbltgaW5kZW50U3RyaW5nYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5pbmRlbnRTdHJpbmcpKSBvciBudWxsLCB3aGVyZSBudWxsXG5pbmRpY2F0ZXMgdGhhdCBubyBkZWZpbml0aXZlIGluZGVudGF0aW9uIGNhbiBiZSBkZXRlcm1pbmVkLlxuKi9cbmNvbnN0IGluZGVudE5vZGVQcm9wID0gLypAX19QVVJFX18qL25ldyBOb2RlUHJvcCgpO1xuLy8gQ29tcHV0ZSB0aGUgaW5kZW50YXRpb24gZm9yIGEgZ2l2ZW4gcG9zaXRpb24gZnJvbSB0aGUgc3ludGF4IHRyZWUuXG5mdW5jdGlvbiBzeW50YXhJbmRlbnRhdGlvbihjeCwgYXN0LCBwb3MpIHtcbiAgICBsZXQgc3RhY2sgPSBhc3QucmVzb2x2ZVN0YWNrKHBvcyk7XG4gICAgbGV0IGlubmVyID0gc3RhY2subm9kZS5lbnRlclVuZmluaXNoZWROb2Rlc0JlZm9yZShwb3MpO1xuICAgIGlmIChpbm5lciAhPSBzdGFjay5ub2RlKSB7XG4gICAgICAgIGxldCBhZGQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgY3VyID0gaW5uZXI7IGN1ciAhPSBzdGFjay5ub2RlOyBjdXIgPSBjdXIucGFyZW50KVxuICAgICAgICAgICAgYWRkLnB1c2goY3VyKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IGFkZC5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcbiAgICAgICAgICAgIHN0YWNrID0geyBub2RlOiBhZGRbaV0sIG5leHQ6IHN0YWNrIH07XG4gICAgfVxuICAgIHJldHVybiBpbmRlbnRGb3Ioc3RhY2ssIGN4LCBwb3MpO1xufVxuZnVuY3Rpb24gaW5kZW50Rm9yKHN0YWNrLCBjeCwgcG9zKSB7XG4gICAgZm9yIChsZXQgY3VyID0gc3RhY2s7IGN1cjsgY3VyID0gY3VyLm5leHQpIHtcbiAgICAgICAgbGV0IHN0cmF0ZWd5ID0gaW5kZW50U3RyYXRlZ3koY3VyLm5vZGUpO1xuICAgICAgICBpZiAoc3RyYXRlZ3kpXG4gICAgICAgICAgICByZXR1cm4gc3RyYXRlZ3koVHJlZUluZGVudENvbnRleHQuY3JlYXRlKGN4LCBwb3MsIGN1cikpO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIGlnbm9yZUNsb3NlZChjeCkge1xuICAgIHJldHVybiBjeC5wb3MgPT0gY3gub3B0aW9ucy5zaW11bGF0ZUJyZWFrICYmIGN4Lm9wdGlvbnMuc2ltdWxhdGVEb3VibGVCcmVhaztcbn1cbmZ1bmN0aW9uIGluZGVudFN0cmF0ZWd5KHRyZWUpIHtcbiAgICBsZXQgc3RyYXRlZ3kgPSB0cmVlLnR5cGUucHJvcChpbmRlbnROb2RlUHJvcCk7XG4gICAgaWYgKHN0cmF0ZWd5KVxuICAgICAgICByZXR1cm4gc3RyYXRlZ3k7XG4gICAgbGV0IGZpcnN0ID0gdHJlZS5maXJzdENoaWxkLCBjbG9zZTtcbiAgICBpZiAoZmlyc3QgJiYgKGNsb3NlID0gZmlyc3QudHlwZS5wcm9wKE5vZGVQcm9wLmNsb3NlZEJ5KSkpIHtcbiAgICAgICAgbGV0IGxhc3QgPSB0cmVlLmxhc3RDaGlsZCwgY2xvc2VkID0gbGFzdCAmJiBjbG9zZS5pbmRleE9mKGxhc3QubmFtZSkgPiAtMTtcbiAgICAgICAgcmV0dXJuIGN4ID0+IGRlbGltaXRlZFN0cmF0ZWd5KGN4LCB0cnVlLCAxLCB1bmRlZmluZWQsIGNsb3NlZCAmJiAhaWdub3JlQ2xvc2VkKGN4KSA/IGxhc3QuZnJvbSA6IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIHJldHVybiB0cmVlLnBhcmVudCA9PSBudWxsID8gdG9wSW5kZW50IDogbnVsbDtcbn1cbmZ1bmN0aW9uIHRvcEluZGVudCgpIHsgcmV0dXJuIDA7IH1cbi8qKlxuT2JqZWN0cyBvZiB0aGlzIHR5cGUgcHJvdmlkZSBjb250ZXh0IGluZm9ybWF0aW9uIGFuZCBoZWxwZXJcbm1ldGhvZHMgdG8gaW5kZW50YXRpb24gZnVuY3Rpb25zIHJlZ2lzdGVyZWQgb24gc3ludGF4IG5vZGVzLlxuKi9cbmNsYXNzIFRyZWVJbmRlbnRDb250ZXh0IGV4dGVuZHMgSW5kZW50Q29udGV4dCB7XG4gICAgY29uc3RydWN0b3IoYmFzZSwgXG4gICAgLyoqXG4gICAgVGhlIHBvc2l0aW9uIGF0IHdoaWNoIGluZGVudGF0aW9uIGlzIGJlaW5nIGNvbXB1dGVkLlxuICAgICovXG4gICAgcG9zLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIoYmFzZS5zdGF0ZSwgYmFzZS5vcHRpb25zKTtcbiAgICAgICAgdGhpcy5iYXNlID0gYmFzZTtcbiAgICAgICAgdGhpcy5wb3MgPSBwb3M7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoZSBzeW50YXggdHJlZSBub2RlIHRvIHdoaWNoIHRoZSBpbmRlbnRhdGlvbiBzdHJhdGVneVxuICAgIGFwcGxpZXMuXG4gICAgKi9cbiAgICBnZXQgbm9kZSgpIHsgcmV0dXJuIHRoaXMuY29udGV4dC5ub2RlOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlKGJhc2UsIHBvcywgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gbmV3IFRyZWVJbmRlbnRDb250ZXh0KGJhc2UsIHBvcywgY29udGV4dCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgdGV4dCBkaXJlY3RseSBhZnRlciBgdGhpcy5wb3NgLCBlaXRoZXIgdGhlIGVudGlyZSBsaW5lXG4gICAgb3IgdGhlIG5leHQgMTAwIGNoYXJhY3RlcnMsIHdoaWNoZXZlciBpcyBzaG9ydGVyLlxuICAgICovXG4gICAgZ2V0IHRleHRBZnRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGV4dEFmdGVyUG9zKHRoaXMucG9zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBpbmRlbnRhdGlvbiBhdCB0aGUgcmVmZXJlbmNlIGxpbmUgZm9yIGB0aGlzLm5vZGVgLCB3aGljaFxuICAgIGlzIHRoZSBsaW5lIG9uIHdoaWNoIGl0IHN0YXJ0cywgdW5sZXNzIHRoZXJlIGlzIGEgbm9kZSB0aGF0IGlzXG4gICAgX25vdF8gYSBwYXJlbnQgb2YgdGhpcyBub2RlIGNvdmVyaW5nIHRoZSBzdGFydCBvZiB0aGF0IGxpbmUuIElmXG4gICAgc28sIHRoZSBsaW5lIGF0IHRoZSBzdGFydCBvZiB0aGF0IG5vZGUgaXMgdHJpZWQsIGFnYWluIHNraXBwaW5nXG4gICAgb24gaWYgaXQgaXMgY292ZXJlZCBieSBhbm90aGVyIHN1Y2ggbm9kZS5cbiAgICAqL1xuICAgIGdldCBiYXNlSW5kZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iYXNlSW5kZW50Rm9yKHRoaXMubm9kZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgaW5kZW50YXRpb24gZm9yIHRoZSByZWZlcmVuY2UgbGluZSBvZiB0aGUgZ2l2ZW4gbm9kZVxuICAgIChzZWUgW2BiYXNlSW5kZW50YF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5UcmVlSW5kZW50Q29udGV4dC5iYXNlSW5kZW50KSkuXG4gICAgKi9cbiAgICBiYXNlSW5kZW50Rm9yKG5vZGUpIHtcbiAgICAgICAgbGV0IGxpbmUgPSB0aGlzLnN0YXRlLmRvYy5saW5lQXQobm9kZS5mcm9tKTtcbiAgICAgICAgLy8gU2tpcCBsaW5lIHN0YXJ0cyB0aGF0IGFyZSBjb3ZlcmVkIGJ5IGEgc2libGluZyAob3IgY291c2luLCBldGMpXG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBhdEJyZWFrID0gbm9kZS5yZXNvbHZlKGxpbmUuZnJvbSk7XG4gICAgICAgICAgICB3aGlsZSAoYXRCcmVhay5wYXJlbnQgJiYgYXRCcmVhay5wYXJlbnQuZnJvbSA9PSBhdEJyZWFrLmZyb20pXG4gICAgICAgICAgICAgICAgYXRCcmVhayA9IGF0QnJlYWsucGFyZW50O1xuICAgICAgICAgICAgaWYgKGlzUGFyZW50KGF0QnJlYWssIG5vZGUpKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgbGluZSA9IHRoaXMuc3RhdGUuZG9jLmxpbmVBdChhdEJyZWFrLmZyb20pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmxpbmVJbmRlbnQobGluZS5mcm9tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQ29udGludWUgbG9va2luZyBmb3IgaW5kZW50YXRpb25zIGluIHRoZSBub2RlJ3MgcGFyZW50IG5vZGVzLFxuICAgIGFuZCByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGF0LlxuICAgICovXG4gICAgY29udGludWUoKSB7XG4gICAgICAgIHJldHVybiBpbmRlbnRGb3IodGhpcy5jb250ZXh0Lm5leHQsIHRoaXMuYmFzZSwgdGhpcy5wb3MpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzUGFyZW50KHBhcmVudCwgb2YpIHtcbiAgICBmb3IgKGxldCBjdXIgPSBvZjsgY3VyOyBjdXIgPSBjdXIucGFyZW50KVxuICAgICAgICBpZiAocGFyZW50ID09IGN1cilcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbi8vIENoZWNrIHdoZXRoZXIgYSBkZWxpbWl0ZWQgbm9kZSBpcyBhbGlnbmVkIChtZWFuaW5nIHRoZXJlIGFyZVxuLy8gbm9uLXNraXBwZWQgbm9kZXMgb24gdGhlIHNhbWUgbGluZSBhcyB0aGUgb3BlbmluZyBkZWxpbWl0ZXIpLiBBbmRcbi8vIGlmIHNvLCByZXR1cm4gdGhlIG9wZW5pbmcgdG9rZW4uXG5mdW5jdGlvbiBicmFja2V0ZWRBbGlnbmVkKGNvbnRleHQpIHtcbiAgICBsZXQgdHJlZSA9IGNvbnRleHQubm9kZTtcbiAgICBsZXQgb3BlblRva2VuID0gdHJlZS5jaGlsZEFmdGVyKHRyZWUuZnJvbSksIGxhc3QgPSB0cmVlLmxhc3RDaGlsZDtcbiAgICBpZiAoIW9wZW5Ub2tlbilcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgbGV0IHNpbSA9IGNvbnRleHQub3B0aW9ucy5zaW11bGF0ZUJyZWFrO1xuICAgIGxldCBvcGVuTGluZSA9IGNvbnRleHQuc3RhdGUuZG9jLmxpbmVBdChvcGVuVG9rZW4uZnJvbSk7XG4gICAgbGV0IGxpbmVFbmQgPSBzaW0gPT0gbnVsbCB8fCBzaW0gPD0gb3BlbkxpbmUuZnJvbSA/IG9wZW5MaW5lLnRvIDogTWF0aC5taW4ob3BlbkxpbmUudG8sIHNpbSk7XG4gICAgZm9yIChsZXQgcG9zID0gb3BlblRva2VuLnRvOzspIHtcbiAgICAgICAgbGV0IG5leHQgPSB0cmVlLmNoaWxkQWZ0ZXIocG9zKTtcbiAgICAgICAgaWYgKCFuZXh0IHx8IG5leHQgPT0gbGFzdClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpZiAoIW5leHQudHlwZS5pc1NraXBwZWQpXG4gICAgICAgICAgICByZXR1cm4gbmV4dC5mcm9tIDwgbGluZUVuZCA/IG9wZW5Ub2tlbiA6IG51bGw7XG4gICAgICAgIHBvcyA9IG5leHQudG87XG4gICAgfVxufVxuLyoqXG5BbiBpbmRlbnRhdGlvbiBzdHJhdGVneSBmb3IgZGVsaW1pdGVkICh1c3VhbGx5IGJyYWNrZXRlZCkgbm9kZXMuXG5XaWxsLCBieSBkZWZhdWx0LCBpbmRlbnQgb25lIHVuaXQgbW9yZSB0aGFuIHRoZSBwYXJlbnQncyBiYXNlXG5pbmRlbnQgdW5sZXNzIHRoZSBsaW5lIHN0YXJ0cyB3aXRoIGEgY2xvc2luZyB0b2tlbi4gV2hlbiBgYWxpZ25gXG5pcyB0cnVlIGFuZCB0aGVyZSBhcmUgbm9uLXNraXBwZWQgbm9kZXMgb24gdGhlIG5vZGUncyBvcGVuaW5nXG5saW5lLCB0aGUgY29udGVudCBvZiB0aGUgbm9kZSB3aWxsIGJlIGFsaWduZWQgd2l0aCB0aGUgZW5kIG9mIHRoZVxub3BlbmluZyBub2RlLCBsaWtlIHRoaXM6XG5cbiAgICBmb28oYmFyLFxuICAgICAgICBiYXopXG4qL1xuZnVuY3Rpb24gZGVsaW1pdGVkSW5kZW50KHsgY2xvc2luZywgYWxpZ24gPSB0cnVlLCB1bml0cyA9IDEgfSkge1xuICAgIHJldHVybiAoY29udGV4dCkgPT4gZGVsaW1pdGVkU3RyYXRlZ3koY29udGV4dCwgYWxpZ24sIHVuaXRzLCBjbG9zaW5nKTtcbn1cbmZ1bmN0aW9uIGRlbGltaXRlZFN0cmF0ZWd5KGNvbnRleHQsIGFsaWduLCB1bml0cywgY2xvc2luZywgY2xvc2VkQXQpIHtcbiAgICBsZXQgYWZ0ZXIgPSBjb250ZXh0LnRleHRBZnRlciwgc3BhY2UgPSBhZnRlci5tYXRjaCgvXlxccyovKVswXS5sZW5ndGg7XG4gICAgbGV0IGNsb3NlZCA9IGNsb3NpbmcgJiYgYWZ0ZXIuc2xpY2Uoc3BhY2UsIHNwYWNlICsgY2xvc2luZy5sZW5ndGgpID09IGNsb3NpbmcgfHwgY2xvc2VkQXQgPT0gY29udGV4dC5wb3MgKyBzcGFjZTtcbiAgICBsZXQgYWxpZ25lZCA9IGFsaWduID8gYnJhY2tldGVkQWxpZ25lZChjb250ZXh0KSA6IG51bGw7XG4gICAgaWYgKGFsaWduZWQpXG4gICAgICAgIHJldHVybiBjbG9zZWQgPyBjb250ZXh0LmNvbHVtbihhbGlnbmVkLmZyb20pIDogY29udGV4dC5jb2x1bW4oYWxpZ25lZC50byk7XG4gICAgcmV0dXJuIGNvbnRleHQuYmFzZUluZGVudCArIChjbG9zZWQgPyAwIDogY29udGV4dC51bml0ICogdW5pdHMpO1xufVxuLyoqXG5BbiBpbmRlbnRhdGlvbiBzdHJhdGVneSB0aGF0IGFsaWducyBhIG5vZGUncyBjb250ZW50IHRvIGl0cyBiYXNlXG5pbmRlbnRhdGlvbi5cbiovXG5jb25zdCBmbGF0SW5kZW50ID0gKGNvbnRleHQpID0+IGNvbnRleHQuYmFzZUluZGVudDtcbi8qKlxuQ3JlYXRlcyBhbiBpbmRlbnRhdGlvbiBzdHJhdGVneSB0aGF0LCBieSBkZWZhdWx0LCBpbmRlbnRzXG5jb250aW51ZWQgbGluZXMgb25lIHVuaXQgbW9yZSB0aGFuIHRoZSBub2RlJ3MgYmFzZSBpbmRlbnRhdGlvbi5cbllvdSBjYW4gcHJvdmlkZSBgZXhjZXB0YCB0byBwcmV2ZW50IGluZGVudGF0aW9uIG9mIGxpbmVzIHRoYXRcbm1hdGNoIGEgcGF0dGVybiAoZm9yIGV4YW1wbGUgYC9eZWxzZVxcYi9gIGluIGBpZmAvYGVsc2VgXG5jb25zdHJ1Y3RzKSwgYW5kIHlvdSBjYW4gY2hhbmdlIHRoZSBhbW91bnQgb2YgdW5pdHMgdXNlZCB3aXRoIHRoZVxuYHVuaXRzYCBvcHRpb24uXG4qL1xuZnVuY3Rpb24gY29udGludWVkSW5kZW50KHsgZXhjZXB0LCB1bml0cyA9IDEgfSA9IHt9KSB7XG4gICAgcmV0dXJuIChjb250ZXh0KSA9PiB7XG4gICAgICAgIGxldCBtYXRjaEV4Y2VwdCA9IGV4Y2VwdCAmJiBleGNlcHQudGVzdChjb250ZXh0LnRleHRBZnRlcik7XG4gICAgICAgIHJldHVybiBjb250ZXh0LmJhc2VJbmRlbnQgKyAobWF0Y2hFeGNlcHQgPyAwIDogdW5pdHMgKiBjb250ZXh0LnVuaXQpO1xuICAgIH07XG59XG5jb25zdCBEb250SW5kZW50QmV5b25kID0gMjAwO1xuLyoqXG5FbmFibGVzIHJlaW5kZW50YXRpb24gb24gaW5wdXQuIFdoZW4gYSBsYW5ndWFnZSBkZWZpbmVzIGFuXG5gaW5kZW50T25JbnB1dGAgZmllbGQgaW4gaXRzIFtsYW5ndWFnZVxuZGF0YV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS5sYW5ndWFnZURhdGFBdCksIHdoaWNoIG11c3QgaG9sZCBhIHJlZ3VsYXJcbmV4cHJlc3Npb24sIHRoZSBsaW5lIGF0IHRoZSBjdXJzb3Igd2lsbCBiZSByZWluZGVudGVkIHdoZW5ldmVyIG5ld1xudGV4dCBpcyB0eXBlZCBhbmQgdGhlIGlucHV0IGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBsaW5lIHVwIHRvIHRoZVxuY3Vyc29yIG1hdGNoZXMgdGhhdCByZWdleHAuXG5cblRvIGF2b2lkIHVubmVjY2VzYXJ5IHJlaW5kZW50cywgaXQgaXMgcmVjb21tZW5kZWQgdG8gc3RhcnQgdGhlXG5yZWdleHAgd2l0aCBgXmAgKHVzdWFsbHkgZm9sbG93ZWQgYnkgYFxccypgKSwgYW5kIGVuZCBpdCB3aXRoIGAkYC5cbkZvciBleGFtcGxlLCBgL15cXHMqXFx9JC9gIHdpbGwgcmVpbmRlbnQgd2hlbiBhIGNsb3NpbmcgYnJhY2UgaXNcbmFkZGVkIGF0IHRoZSBzdGFydCBvZiBhIGxpbmUuXG4qL1xuZnVuY3Rpb24gaW5kZW50T25JbnB1dCgpIHtcbiAgICByZXR1cm4gRWRpdG9yU3RhdGUudHJhbnNhY3Rpb25GaWx0ZXIub2YodHIgPT4ge1xuICAgICAgICBpZiAoIXRyLmRvY0NoYW5nZWQgfHwgIXRyLmlzVXNlckV2ZW50KFwiaW5wdXQudHlwZVwiKSAmJiAhdHIuaXNVc2VyRXZlbnQoXCJpbnB1dC5jb21wbGV0ZVwiKSlcbiAgICAgICAgICAgIHJldHVybiB0cjtcbiAgICAgICAgbGV0IHJ1bGVzID0gdHIuc3RhcnRTdGF0ZS5sYW5ndWFnZURhdGFBdChcImluZGVudE9uSW5wdXRcIiwgdHIuc3RhcnRTdGF0ZS5zZWxlY3Rpb24ubWFpbi5oZWFkKTtcbiAgICAgICAgaWYgKCFydWxlcy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdHI7XG4gICAgICAgIGxldCBkb2MgPSB0ci5uZXdEb2MsIHsgaGVhZCB9ID0gdHIubmV3U2VsZWN0aW9uLm1haW4sIGxpbmUgPSBkb2MubGluZUF0KGhlYWQpO1xuICAgICAgICBpZiAoaGVhZCA+IGxpbmUuZnJvbSArIERvbnRJbmRlbnRCZXlvbmQpXG4gICAgICAgICAgICByZXR1cm4gdHI7XG4gICAgICAgIGxldCBsaW5lU3RhcnQgPSBkb2Muc2xpY2VTdHJpbmcobGluZS5mcm9tLCBoZWFkKTtcbiAgICAgICAgaWYgKCFydWxlcy5zb21lKHIgPT4gci50ZXN0KGxpbmVTdGFydCkpKVxuICAgICAgICAgICAgcmV0dXJuIHRyO1xuICAgICAgICBsZXQgeyBzdGF0ZSB9ID0gdHIsIGxhc3QgPSAtMSwgY2hhbmdlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCB7IGhlYWQgfSBvZiBzdGF0ZS5zZWxlY3Rpb24ucmFuZ2VzKSB7XG4gICAgICAgICAgICBsZXQgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQoaGVhZCk7XG4gICAgICAgICAgICBpZiAobGluZS5mcm9tID09IGxhc3QpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBsYXN0ID0gbGluZS5mcm9tO1xuICAgICAgICAgICAgbGV0IGluZGVudCA9IGdldEluZGVudGF0aW9uKHN0YXRlLCBsaW5lLmZyb20pO1xuICAgICAgICAgICAgaWYgKGluZGVudCA9PSBudWxsKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgbGV0IGN1ciA9IC9eXFxzKi8uZXhlYyhsaW5lLnRleHQpWzBdO1xuICAgICAgICAgICAgbGV0IG5vcm0gPSBpbmRlbnRTdHJpbmcoc3RhdGUsIGluZGVudCk7XG4gICAgICAgICAgICBpZiAoY3VyICE9IG5vcm0pXG4gICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgZnJvbTogbGluZS5mcm9tLCB0bzogbGluZS5mcm9tICsgY3VyLmxlbmd0aCwgaW5zZXJ0OiBub3JtIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjaGFuZ2VzLmxlbmd0aCA/IFt0ciwgeyBjaGFuZ2VzLCBzZXF1ZW50aWFsOiB0cnVlIH1dIDogdHI7XG4gICAgfSk7XG59XG5cbi8qKlxuQSBmYWNldCB0aGF0IHJlZ2lzdGVycyBhIGNvZGUgZm9sZGluZyBzZXJ2aWNlLiBXaGVuIGNhbGxlZCB3aXRoXG50aGUgZXh0ZW50IG9mIGEgbGluZSwgc3VjaCBhIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYSBmb2xkYWJsZVxucmFuZ2UgdGhhdCBzdGFydHMgb24gdGhhdCBsaW5lIChidXQgY29udGludWVzIGJleW9uZCBpdCksIGlmIG9uZVxuY2FuIGJlIGZvdW5kLlxuKi9cbmNvbnN0IGZvbGRTZXJ2aWNlID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSgpO1xuLyoqXG5UaGlzIG5vZGUgcHJvcCBpcyB1c2VkIHRvIGFzc29jaWF0ZSBmb2xkaW5nIGluZm9ybWF0aW9uIHdpdGhcbnN5bnRheCBub2RlIHR5cGVzLiBHaXZlbiBhIHN5bnRheCBub2RlLCBpdCBzaG91bGQgY2hlY2sgd2hldGhlclxudGhhdCB0cmVlIGlzIGZvbGRhYmxlIGFuZCByZXR1cm4gdGhlIHJhbmdlIHRoYXQgY2FuIGJlIGNvbGxhcHNlZFxud2hlbiBpdCBpcy5cbiovXG5jb25zdCBmb2xkTm9kZVByb3AgPSAvKkBfX1BVUkVfXyovbmV3IE5vZGVQcm9wKCk7XG4vKipcbltGb2xkXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmZvbGROb2RlUHJvcCkgZnVuY3Rpb24gdGhhdCBmb2xkcyBldmVyeXRoaW5nIGJ1dFxudGhlIGZpcnN0IGFuZCB0aGUgbGFzdCBjaGlsZCBvZiBhIHN5bnRheCBub2RlLiBVc2VmdWwgZm9yIG5vZGVzXG50aGF0IHN0YXJ0IGFuZCBlbmQgd2l0aCBkZWxpbWl0ZXJzLlxuKi9cbmZ1bmN0aW9uIGZvbGRJbnNpZGUobm9kZSkge1xuICAgIGxldCBmaXJzdCA9IG5vZGUuZmlyc3RDaGlsZCwgbGFzdCA9IG5vZGUubGFzdENoaWxkO1xuICAgIHJldHVybiBmaXJzdCAmJiBmaXJzdC50byA8IGxhc3QuZnJvbSA/IHsgZnJvbTogZmlyc3QudG8sIHRvOiBsYXN0LnR5cGUuaXNFcnJvciA/IG5vZGUudG8gOiBsYXN0LmZyb20gfSA6IG51bGw7XG59XG5mdW5jdGlvbiBzeW50YXhGb2xkaW5nKHN0YXRlLCBzdGFydCwgZW5kKSB7XG4gICAgbGV0IHRyZWUgPSBzeW50YXhUcmVlKHN0YXRlKTtcbiAgICBpZiAodHJlZS5sZW5ndGggPCBlbmQpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBzdGFjayA9IHRyZWUucmVzb2x2ZVN0YWNrKGVuZCwgMSk7XG4gICAgbGV0IGZvdW5kID0gbnVsbDtcbiAgICBmb3IgKGxldCBpdGVyID0gc3RhY2s7IGl0ZXI7IGl0ZXIgPSBpdGVyLm5leHQpIHtcbiAgICAgICAgbGV0IGN1ciA9IGl0ZXIubm9kZTtcbiAgICAgICAgaWYgKGN1ci50byA8PSBlbmQgfHwgY3VyLmZyb20gPiBlbmQpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKGZvdW5kICYmIGN1ci5mcm9tIDwgc3RhcnQpXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgbGV0IHByb3AgPSBjdXIudHlwZS5wcm9wKGZvbGROb2RlUHJvcCk7XG4gICAgICAgIGlmIChwcm9wICYmIChjdXIudG8gPCB0cmVlLmxlbmd0aCAtIDUwIHx8IHRyZWUubGVuZ3RoID09IHN0YXRlLmRvYy5sZW5ndGggfHwgIWlzVW5maW5pc2hlZChjdXIpKSkge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gcHJvcChjdXIsIHN0YXRlKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS5mcm9tIDw9IGVuZCAmJiB2YWx1ZS5mcm9tID49IHN0YXJ0ICYmIHZhbHVlLnRvID4gZW5kKVxuICAgICAgICAgICAgICAgIGZvdW5kID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZvdW5kO1xufVxuZnVuY3Rpb24gaXNVbmZpbmlzaGVkKG5vZGUpIHtcbiAgICBsZXQgY2ggPSBub2RlLmxhc3RDaGlsZDtcbiAgICByZXR1cm4gY2ggJiYgY2gudG8gPT0gbm9kZS50byAmJiBjaC50eXBlLmlzRXJyb3I7XG59XG4vKipcbkNoZWNrIHdoZXRoZXIgdGhlIGdpdmVuIGxpbmUgaXMgZm9sZGFibGUuIEZpcnN0IGFza3MgYW55IGZvbGRcbnNlcnZpY2VzIHJlZ2lzdGVyZWQgdGhyb3VnaFxuW2Bmb2xkU2VydmljZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuZm9sZFNlcnZpY2UpLCBhbmQgaWYgbm9uZSBvZiB0aGVtIHJldHVyblxuYSByZXN1bHQsIHRyaWVzIHRvIHF1ZXJ5IHRoZSBbZm9sZCBub2RlXG5wcm9wXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmZvbGROb2RlUHJvcCkgb2Ygc3ludGF4IG5vZGVzIHRoYXQgY292ZXIgdGhlIGVuZFxub2YgdGhlIGxpbmUuXG4qL1xuZnVuY3Rpb24gZm9sZGFibGUoc3RhdGUsIGxpbmVTdGFydCwgbGluZUVuZCkge1xuICAgIGZvciAobGV0IHNlcnZpY2Ugb2Ygc3RhdGUuZmFjZXQoZm9sZFNlcnZpY2UpKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBzZXJ2aWNlKHN0YXRlLCBsaW5lU3RhcnQsIGxpbmVFbmQpO1xuICAgICAgICBpZiAocmVzdWx0KVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIHN5bnRheEZvbGRpbmcoc3RhdGUsIGxpbmVTdGFydCwgbGluZUVuZCk7XG59XG5mdW5jdGlvbiBtYXBSYW5nZShyYW5nZSwgbWFwcGluZykge1xuICAgIGxldCBmcm9tID0gbWFwcGluZy5tYXBQb3MocmFuZ2UuZnJvbSwgMSksIHRvID0gbWFwcGluZy5tYXBQb3MocmFuZ2UudG8sIC0xKTtcbiAgICByZXR1cm4gZnJvbSA+PSB0byA/IHVuZGVmaW5lZCA6IHsgZnJvbSwgdG8gfTtcbn1cbi8qKlxuU3RhdGUgZWZmZWN0IHRoYXQgY2FuIGJlIGF0dGFjaGVkIHRvIGEgdHJhbnNhY3Rpb24gdG8gZm9sZCB0aGVcbmdpdmVuIHJhbmdlLiAoWW91IHByb2JhYmx5IG9ubHkgbmVlZCB0aGlzIGluIGV4Y2VwdGlvbmFsXG5jaXJjdW1zdGFuY2Vz4oCUdXN1YWxseSB5b3UnbGwganVzdCB3YW50IHRvIGxldFxuW2Bmb2xkQ29kZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuZm9sZENvZGUpIGFuZCB0aGUgW2ZvbGRcbmd1dHRlcl0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5mb2xkR3V0dGVyKSBjcmVhdGUgdGhlIHRyYW5zYWN0aW9ucy4pXG4qL1xuY29uc3QgZm9sZEVmZmVjdCA9IC8qQF9fUFVSRV9fKi9TdGF0ZUVmZmVjdC5kZWZpbmUoeyBtYXA6IG1hcFJhbmdlIH0pO1xuLyoqXG5TdGF0ZSBlZmZlY3QgdGhhdCB1bmZvbGRzIHRoZSBnaXZlbiByYW5nZSAoaWYgaXQgd2FzIGZvbGRlZCkuXG4qL1xuY29uc3QgdW5mb2xkRWZmZWN0ID0gLypAX19QVVJFX18qL1N0YXRlRWZmZWN0LmRlZmluZSh7IG1hcDogbWFwUmFuZ2UgfSk7XG5mdW5jdGlvbiBzZWxlY3RlZExpbmVzKHZpZXcpIHtcbiAgICBsZXQgbGluZXMgPSBbXTtcbiAgICBmb3IgKGxldCB7IGhlYWQgfSBvZiB2aWV3LnN0YXRlLnNlbGVjdGlvbi5yYW5nZXMpIHtcbiAgICAgICAgaWYgKGxpbmVzLnNvbWUobCA9PiBsLmZyb20gPD0gaGVhZCAmJiBsLnRvID49IGhlYWQpKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGxpbmVzLnB1c2godmlldy5saW5lQmxvY2tBdChoZWFkKSk7XG4gICAgfVxuICAgIHJldHVybiBsaW5lcztcbn1cbi8qKlxuVGhlIHN0YXRlIGZpZWxkIHRoYXQgc3RvcmVzIHRoZSBmb2xkZWQgcmFuZ2VzIChhcyBhIFtkZWNvcmF0aW9uXG5zZXRdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jdmlldy5EZWNvcmF0aW9uU2V0KSkuIENhbiBiZSBwYXNzZWQgdG9cbltgRWRpdG9yU3RhdGUudG9KU09OYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNzdGF0ZS5FZGl0b3JTdGF0ZS50b0pTT04pIGFuZFxuW2Bmcm9tSlNPTmBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jc3RhdGUuRWRpdG9yU3RhdGVeZnJvbUpTT04pIHRvIHNlcmlhbGl6ZSB0aGUgZm9sZFxuc3RhdGUuXG4qL1xuY29uc3QgZm9sZFN0YXRlID0gLypAX19QVVJFX18qL1N0YXRlRmllbGQuZGVmaW5lKHtcbiAgICBjcmVhdGUoKSB7XG4gICAgICAgIHJldHVybiBEZWNvcmF0aW9uLm5vbmU7XG4gICAgfSxcbiAgICB1cGRhdGUoZm9sZGVkLCB0cikge1xuICAgICAgICBmb2xkZWQgPSBmb2xkZWQubWFwKHRyLmNoYW5nZXMpO1xuICAgICAgICBmb3IgKGxldCBlIG9mIHRyLmVmZmVjdHMpIHtcbiAgICAgICAgICAgIGlmIChlLmlzKGZvbGRFZmZlY3QpICYmICFmb2xkRXhpc3RzKGZvbGRlZCwgZS52YWx1ZS5mcm9tLCBlLnZhbHVlLnRvKSkge1xuICAgICAgICAgICAgICAgIGxldCB7IHByZXBhcmVQbGFjZWhvbGRlciB9ID0gdHIuc3RhdGUuZmFjZXQoZm9sZENvbmZpZyk7XG4gICAgICAgICAgICAgICAgbGV0IHdpZGdldCA9ICFwcmVwYXJlUGxhY2Vob2xkZXIgPyBmb2xkV2lkZ2V0IDpcbiAgICAgICAgICAgICAgICAgICAgRGVjb3JhdGlvbi5yZXBsYWNlKHsgd2lkZ2V0OiBuZXcgUHJlcGFyZWRGb2xkV2lkZ2V0KHByZXBhcmVQbGFjZWhvbGRlcih0ci5zdGF0ZSwgZS52YWx1ZSkpIH0pO1xuICAgICAgICAgICAgICAgIGZvbGRlZCA9IGZvbGRlZC51cGRhdGUoeyBhZGQ6IFt3aWRnZXQucmFuZ2UoZS52YWx1ZS5mcm9tLCBlLnZhbHVlLnRvKV0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlLmlzKHVuZm9sZEVmZmVjdCkpIHtcbiAgICAgICAgICAgICAgICBmb2xkZWQgPSBmb2xkZWQudXBkYXRlKHsgZmlsdGVyOiAoZnJvbSwgdG8pID0+IGUudmFsdWUuZnJvbSAhPSBmcm9tIHx8IGUudmFsdWUudG8gIT0gdG8sXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlckZyb206IGUudmFsdWUuZnJvbSwgZmlsdGVyVG86IGUudmFsdWUudG8gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2xlYXIgZm9sZGVkIHJhbmdlcyB0aGF0IGNvdmVyIHRoZSBzZWxlY3Rpb24gaGVhZFxuICAgICAgICBpZiAodHIuc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICBsZXQgb25TZWxlY3Rpb24gPSBmYWxzZSwgeyBoZWFkIH0gPSB0ci5zZWxlY3Rpb24ubWFpbjtcbiAgICAgICAgICAgIGZvbGRlZC5iZXR3ZWVuKGhlYWQsIGhlYWQsIChhLCBiKSA9PiB7IGlmIChhIDwgaGVhZCAmJiBiID4gaGVhZClcbiAgICAgICAgICAgICAgICBvblNlbGVjdGlvbiA9IHRydWU7IH0pO1xuICAgICAgICAgICAgaWYgKG9uU2VsZWN0aW9uKVxuICAgICAgICAgICAgICAgIGZvbGRlZCA9IGZvbGRlZC51cGRhdGUoe1xuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJGcm9tOiBoZWFkLFxuICAgICAgICAgICAgICAgICAgICBmaWx0ZXJUbzogaGVhZCxcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyOiAoYSwgYikgPT4gYiA8PSBoZWFkIHx8IGEgPj0gaGVhZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmb2xkZWQ7XG4gICAgfSxcbiAgICBwcm92aWRlOiBmID0+IEVkaXRvclZpZXcuZGVjb3JhdGlvbnMuZnJvbShmKSxcbiAgICB0b0pTT04oZm9sZGVkLCBzdGF0ZSkge1xuICAgICAgICBsZXQgcmFuZ2VzID0gW107XG4gICAgICAgIGZvbGRlZC5iZXR3ZWVuKDAsIHN0YXRlLmRvYy5sZW5ndGgsIChmcm9tLCB0bykgPT4geyByYW5nZXMucHVzaChmcm9tLCB0byk7IH0pO1xuICAgICAgICByZXR1cm4gcmFuZ2VzO1xuICAgIH0sXG4gICAgZnJvbUpTT04odmFsdWUpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSB8fCB2YWx1ZS5sZW5ndGggJSAyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIEpTT04gZm9yIGZvbGQgc3RhdGVcIik7XG4gICAgICAgIGxldCByYW5nZXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7KSB7XG4gICAgICAgICAgICBsZXQgZnJvbSA9IHZhbHVlW2krK10sIHRvID0gdmFsdWVbaSsrXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZnJvbSAhPSBcIm51bWJlclwiIHx8IHR5cGVvZiB0byAhPSBcIm51bWJlclwiKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBKU09OIGZvciBmb2xkIHN0YXRlXCIpO1xuICAgICAgICAgICAgcmFuZ2VzLnB1c2goZm9sZFdpZGdldC5yYW5nZShmcm9tLCB0bykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBEZWNvcmF0aW9uLnNldChyYW5nZXMsIHRydWUpO1xuICAgIH1cbn0pO1xuLyoqXG5HZXQgYSBbcmFuZ2Ugc2V0XShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI3N0YXRlLlJhbmdlU2V0KSBjb250YWluaW5nIHRoZSBmb2xkZWQgcmFuZ2VzXG5pbiB0aGUgZ2l2ZW4gc3RhdGUuXG4qL1xuZnVuY3Rpb24gZm9sZGVkUmFuZ2VzKHN0YXRlKSB7XG4gICAgcmV0dXJuIHN0YXRlLmZpZWxkKGZvbGRTdGF0ZSwgZmFsc2UpIHx8IFJhbmdlU2V0LmVtcHR5O1xufVxuZnVuY3Rpb24gZmluZEZvbGQoc3RhdGUsIGZyb20sIHRvKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBmb3VuZCA9IG51bGw7XG4gICAgKF9hID0gc3RhdGUuZmllbGQoZm9sZFN0YXRlLCBmYWxzZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5iZXR3ZWVuKGZyb20sIHRvLCAoZnJvbSwgdG8pID0+IHtcbiAgICAgICAgaWYgKCFmb3VuZCB8fCBmb3VuZC5mcm9tID4gZnJvbSlcbiAgICAgICAgICAgIGZvdW5kID0geyBmcm9tLCB0byB9O1xuICAgIH0pO1xuICAgIHJldHVybiBmb3VuZDtcbn1cbmZ1bmN0aW9uIGZvbGRFeGlzdHMoZm9sZGVkLCBmcm9tLCB0bykge1xuICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgIGZvbGRlZC5iZXR3ZWVuKGZyb20sIGZyb20sIChhLCBiKSA9PiB7IGlmIChhID09IGZyb20gJiYgYiA9PSB0bylcbiAgICAgICAgZm91bmQgPSB0cnVlOyB9KTtcbiAgICByZXR1cm4gZm91bmQ7XG59XG5mdW5jdGlvbiBtYXliZUVuYWJsZShzdGF0ZSwgb3RoZXIpIHtcbiAgICByZXR1cm4gc3RhdGUuZmllbGQoZm9sZFN0YXRlLCBmYWxzZSkgPyBvdGhlciA6IG90aGVyLmNvbmNhdChTdGF0ZUVmZmVjdC5hcHBlbmRDb25maWcub2YoY29kZUZvbGRpbmcoKSkpO1xufVxuLyoqXG5Gb2xkIHRoZSBsaW5lcyB0aGF0IGFyZSBzZWxlY3RlZCwgaWYgcG9zc2libGUuXG4qL1xuY29uc3QgZm9sZENvZGUgPSB2aWV3ID0+IHtcbiAgICBmb3IgKGxldCBsaW5lIG9mIHNlbGVjdGVkTGluZXModmlldykpIHtcbiAgICAgICAgbGV0IHJhbmdlID0gZm9sZGFibGUodmlldy5zdGF0ZSwgbGluZS5mcm9tLCBsaW5lLnRvKTtcbiAgICAgICAgaWYgKHJhbmdlKSB7XG4gICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogbWF5YmVFbmFibGUodmlldy5zdGF0ZSwgW2ZvbGRFZmZlY3Qub2YocmFuZ2UpLCBhbm5vdW5jZUZvbGQodmlldywgcmFuZ2UpXSkgfSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuLyoqXG5VbmZvbGQgZm9sZGVkIHJhbmdlcyBvbiBzZWxlY3RlZCBsaW5lcy5cbiovXG5jb25zdCB1bmZvbGRDb2RlID0gdmlldyA9PiB7XG4gICAgaWYgKCF2aWV3LnN0YXRlLmZpZWxkKGZvbGRTdGF0ZSwgZmFsc2UpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGVmZmVjdHMgPSBbXTtcbiAgICBmb3IgKGxldCBsaW5lIG9mIHNlbGVjdGVkTGluZXModmlldykpIHtcbiAgICAgICAgbGV0IGZvbGRlZCA9IGZpbmRGb2xkKHZpZXcuc3RhdGUsIGxpbmUuZnJvbSwgbGluZS50byk7XG4gICAgICAgIGlmIChmb2xkZWQpXG4gICAgICAgICAgICBlZmZlY3RzLnB1c2godW5mb2xkRWZmZWN0Lm9mKGZvbGRlZCksIGFubm91bmNlRm9sZCh2aWV3LCBmb2xkZWQsIGZhbHNlKSk7XG4gICAgfVxuICAgIGlmIChlZmZlY3RzLmxlbmd0aClcbiAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHMgfSk7XG4gICAgcmV0dXJuIGVmZmVjdHMubGVuZ3RoID4gMDtcbn07XG5mdW5jdGlvbiBhbm5vdW5jZUZvbGQodmlldywgcmFuZ2UsIGZvbGQgPSB0cnVlKSB7XG4gICAgbGV0IGxpbmVGcm9tID0gdmlldy5zdGF0ZS5kb2MubGluZUF0KHJhbmdlLmZyb20pLm51bWJlciwgbGluZVRvID0gdmlldy5zdGF0ZS5kb2MubGluZUF0KHJhbmdlLnRvKS5udW1iZXI7XG4gICAgcmV0dXJuIEVkaXRvclZpZXcuYW5ub3VuY2Uub2YoYCR7dmlldy5zdGF0ZS5waHJhc2UoZm9sZCA/IFwiRm9sZGVkIGxpbmVzXCIgOiBcIlVuZm9sZGVkIGxpbmVzXCIpfSAke2xpbmVGcm9tfSAke3ZpZXcuc3RhdGUucGhyYXNlKFwidG9cIil9ICR7bGluZVRvfS5gKTtcbn1cbi8qKlxuRm9sZCBhbGwgdG9wLWxldmVsIGZvbGRhYmxlIHJhbmdlcy4gTm90ZSB0aGF0LCBpbiBtb3N0IGNhc2VzLFxuZm9sZGluZyBpbmZvcm1hdGlvbiB3aWxsIGRlcGVuZCBvbiB0aGUgW3N5bnRheFxudHJlZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5zeW50YXhUcmVlKSwgYW5kIGZvbGRpbmcgZXZlcnl0aGluZyBtYXkgbm90IHdvcmtcbnJlbGlhYmx5IHdoZW4gdGhlIGRvY3VtZW50IGhhc24ndCBiZWVuIGZ1bGx5IHBhcnNlZCAoZWl0aGVyXG5iZWNhdXNlIHRoZSBlZGl0b3Igc3RhdGUgd2FzIG9ubHkganVzdCBpbml0aWFsaXplZCwgb3IgYmVjYXVzZSB0aGVcbmRvY3VtZW50IGlzIHNvIGJpZyB0aGF0IHRoZSBwYXJzZXIgZGVjaWRlZCBub3QgdG8gcGFyc2UgaXRcbmVudGlyZWx5KS5cbiovXG5jb25zdCBmb2xkQWxsID0gdmlldyA9PiB7XG4gICAgbGV0IHsgc3RhdGUgfSA9IHZpZXcsIGVmZmVjdHMgPSBbXTtcbiAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBzdGF0ZS5kb2MubGVuZ3RoOykge1xuICAgICAgICBsZXQgbGluZSA9IHZpZXcubGluZUJsb2NrQXQocG9zKSwgcmFuZ2UgPSBmb2xkYWJsZShzdGF0ZSwgbGluZS5mcm9tLCBsaW5lLnRvKTtcbiAgICAgICAgaWYgKHJhbmdlKVxuICAgICAgICAgICAgZWZmZWN0cy5wdXNoKGZvbGRFZmZlY3Qub2YocmFuZ2UpKTtcbiAgICAgICAgcG9zID0gKHJhbmdlID8gdmlldy5saW5lQmxvY2tBdChyYW5nZS50bykgOiBsaW5lKS50byArIDE7XG4gICAgfVxuICAgIGlmIChlZmZlY3RzLmxlbmd0aClcbiAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IG1heWJlRW5hYmxlKHZpZXcuc3RhdGUsIGVmZmVjdHMpIH0pO1xuICAgIHJldHVybiAhIWVmZmVjdHMubGVuZ3RoO1xufTtcbi8qKlxuVW5mb2xkIGFsbCBmb2xkZWQgY29kZS5cbiovXG5jb25zdCB1bmZvbGRBbGwgPSB2aWV3ID0+IHtcbiAgICBsZXQgZmllbGQgPSB2aWV3LnN0YXRlLmZpZWxkKGZvbGRTdGF0ZSwgZmFsc2UpO1xuICAgIGlmICghZmllbGQgfHwgIWZpZWxkLnNpemUpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgZWZmZWN0cyA9IFtdO1xuICAgIGZpZWxkLmJldHdlZW4oMCwgdmlldy5zdGF0ZS5kb2MubGVuZ3RoLCAoZnJvbSwgdG8pID0+IHsgZWZmZWN0cy5wdXNoKHVuZm9sZEVmZmVjdC5vZih7IGZyb20sIHRvIH0pKTsgfSk7XG4gICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHMgfSk7XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLy8gRmluZCB0aGUgZm9sZGFibGUgcmVnaW9uIGNvbnRhaW5pbmcgdGhlIGdpdmVuIGxpbmUsIGlmIG9uZSBleGlzdHNcbmZ1bmN0aW9uIGZvbGRhYmxlQ29udGFpbmVyKHZpZXcsIGxpbmVCbG9jaykge1xuICAgIC8vIExvb2sgYmFja3dhcmRzIHRocm91Z2ggbGluZSBibG9ja3MgdW50aWwgd2UgZmluZCBhIGZvbGRhYmxlIHJlZ2lvbiB0aGF0XG4gICAgLy8gaW50ZXJzZWN0cyB3aXRoIHRoZSBsaW5lXG4gICAgZm9yIChsZXQgbGluZSA9IGxpbmVCbG9jazs7KSB7XG4gICAgICAgIGxldCBmb2xkYWJsZVJlZ2lvbiA9IGZvbGRhYmxlKHZpZXcuc3RhdGUsIGxpbmUuZnJvbSwgbGluZS50byk7XG4gICAgICAgIGlmIChmb2xkYWJsZVJlZ2lvbiAmJiBmb2xkYWJsZVJlZ2lvbi50byA+IGxpbmVCbG9jay5mcm9tKVxuICAgICAgICAgICAgcmV0dXJuIGZvbGRhYmxlUmVnaW9uO1xuICAgICAgICBpZiAoIWxpbmUuZnJvbSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsaW5lID0gdmlldy5saW5lQmxvY2tBdChsaW5lLmZyb20gLSAxKTtcbiAgICB9XG59XG4vKipcblRvZ2dsZSBmb2xkaW5nIGF0IGN1cnNvcnMuIFVuZm9sZHMgaWYgdGhlcmUgaXMgYW4gZXhpc3RpbmcgZm9sZFxuc3RhcnRpbmcgaW4gdGhhdCBsaW5lLCB0cmllcyB0byBmaW5kIGEgZm9sZGFibGUgcmFuZ2UgYXJvdW5kIGl0XG5vdGhlcndpc2UuXG4qL1xuY29uc3QgdG9nZ2xlRm9sZCA9ICh2aWV3KSA9PiB7XG4gICAgbGV0IGVmZmVjdHMgPSBbXTtcbiAgICBmb3IgKGxldCBsaW5lIG9mIHNlbGVjdGVkTGluZXModmlldykpIHtcbiAgICAgICAgbGV0IGZvbGRlZCA9IGZpbmRGb2xkKHZpZXcuc3RhdGUsIGxpbmUuZnJvbSwgbGluZS50byk7XG4gICAgICAgIGlmIChmb2xkZWQpIHtcbiAgICAgICAgICAgIGVmZmVjdHMucHVzaCh1bmZvbGRFZmZlY3Qub2YoZm9sZGVkKSwgYW5ub3VuY2VGb2xkKHZpZXcsIGZvbGRlZCwgZmFsc2UpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBmb2xkUmFuZ2UgPSBmb2xkYWJsZUNvbnRhaW5lcih2aWV3LCBsaW5lKTtcbiAgICAgICAgICAgIGlmIChmb2xkUmFuZ2UpXG4gICAgICAgICAgICAgICAgZWZmZWN0cy5wdXNoKGZvbGRFZmZlY3Qub2YoZm9sZFJhbmdlKSwgYW5ub3VuY2VGb2xkKHZpZXcsIGZvbGRSYW5nZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChlZmZlY3RzLmxlbmd0aCA+IDApXG4gICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiBtYXliZUVuYWJsZSh2aWV3LnN0YXRlLCBlZmZlY3RzKSB9KTtcbiAgICByZXR1cm4gISFlZmZlY3RzLmxlbmd0aDtcbn07XG4vKipcbkRlZmF1bHQgZm9sZC1yZWxhdGVkIGtleSBiaW5kaW5ncy5cblxuIC0gQ3RybC1TaGlmdC1bIChDbWQtQWx0LVsgb24gbWFjT1MpOiBbYGZvbGRDb2RlYF0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5mb2xkQ29kZSkuXG4gLSBDdHJsLVNoaWZ0LV0gKENtZC1BbHQtXSBvbiBtYWNPUyk6IFtgdW5mb2xkQ29kZWBdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UudW5mb2xkQ29kZSkuXG4gLSBDdHJsLUFsdC1bOiBbYGZvbGRBbGxgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLmZvbGRBbGwpLlxuIC0gQ3RybC1BbHQtXTogW2B1bmZvbGRBbGxgXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLnVuZm9sZEFsbCkuXG4qL1xuY29uc3QgZm9sZEtleW1hcCA9IFtcbiAgICB7IGtleTogXCJDdHJsLVNoaWZ0LVtcIiwgbWFjOiBcIkNtZC1BbHQtW1wiLCBydW46IGZvbGRDb2RlIH0sXG4gICAgeyBrZXk6IFwiQ3RybC1TaGlmdC1dXCIsIG1hYzogXCJDbWQtQWx0LV1cIiwgcnVuOiB1bmZvbGRDb2RlIH0sXG4gICAgeyBrZXk6IFwiQ3RybC1BbHQtW1wiLCBydW46IGZvbGRBbGwgfSxcbiAgICB7IGtleTogXCJDdHJsLUFsdC1dXCIsIHJ1bjogdW5mb2xkQWxsIH1cbl07XG5jb25zdCBkZWZhdWx0Q29uZmlnID0ge1xuICAgIHBsYWNlaG9sZGVyRE9NOiBudWxsLFxuICAgIHByZXBhcmVQbGFjZWhvbGRlcjogbnVsbCxcbiAgICBwbGFjZWhvbGRlclRleHQ6IFwi4oCmXCJcbn07XG5jb25zdCBmb2xkQ29uZmlnID0gLypAX19QVVJFX18qL0ZhY2V0LmRlZmluZSh7XG4gICAgY29tYmluZSh2YWx1ZXMpIHsgcmV0dXJuIGNvbWJpbmVDb25maWcodmFsdWVzLCBkZWZhdWx0Q29uZmlnKTsgfVxufSk7XG4vKipcbkNyZWF0ZSBhbiBleHRlbnNpb24gdGhhdCBjb25maWd1cmVzIGNvZGUgZm9sZGluZy5cbiovXG5mdW5jdGlvbiBjb2RlRm9sZGluZyhjb25maWcpIHtcbiAgICBsZXQgcmVzdWx0ID0gW2ZvbGRTdGF0ZSwgYmFzZVRoZW1lJDFdO1xuICAgIGlmIChjb25maWcpXG4gICAgICAgIHJlc3VsdC5wdXNoKGZvbGRDb25maWcub2YoY29uZmlnKSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHdpZGdldFRvRE9NKHZpZXcsIHByZXBhcmVkKSB7XG4gICAgbGV0IHsgc3RhdGUgfSA9IHZpZXcsIGNvbmYgPSBzdGF0ZS5mYWNldChmb2xkQ29uZmlnKTtcbiAgICBsZXQgb25jbGljayA9IChldmVudCkgPT4ge1xuICAgICAgICBsZXQgbGluZSA9IHZpZXcubGluZUJsb2NrQXQodmlldy5wb3NBdERPTShldmVudC50YXJnZXQpKTtcbiAgICAgICAgbGV0IGZvbGRlZCA9IGZpbmRGb2xkKHZpZXcuc3RhdGUsIGxpbmUuZnJvbSwgbGluZS50byk7XG4gICAgICAgIGlmIChmb2xkZWQpXG4gICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHsgZWZmZWN0czogdW5mb2xkRWZmZWN0Lm9mKGZvbGRlZCkgfSk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfTtcbiAgICBpZiAoY29uZi5wbGFjZWhvbGRlckRPTSlcbiAgICAgICAgcmV0dXJuIGNvbmYucGxhY2Vob2xkZXJET00odmlldywgb25jbGljaywgcHJlcGFyZWQpO1xuICAgIGxldCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgZWxlbWVudC50ZXh0Q29udGVudCA9IGNvbmYucGxhY2Vob2xkZXJUZXh0O1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiYXJpYS1sYWJlbFwiLCBzdGF0ZS5waHJhc2UoXCJmb2xkZWQgY29kZVwiKSk7XG4gICAgZWxlbWVudC50aXRsZSA9IHN0YXRlLnBocmFzZShcInVuZm9sZFwiKTtcbiAgICBlbGVtZW50LmNsYXNzTmFtZSA9IFwiY20tZm9sZFBsYWNlaG9sZGVyXCI7XG4gICAgZWxlbWVudC5vbmNsaWNrID0gb25jbGljaztcbiAgICByZXR1cm4gZWxlbWVudDtcbn1cbmNvbnN0IGZvbGRXaWRnZXQgPSAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi5yZXBsYWNlKHsgd2lkZ2V0OiAvKkBfX1BVUkVfXyovbmV3IGNsYXNzIGV4dGVuZHMgV2lkZ2V0VHlwZSB7XG4gICAgICAgIHRvRE9NKHZpZXcpIHsgcmV0dXJuIHdpZGdldFRvRE9NKHZpZXcsIG51bGwpOyB9XG4gICAgfSB9KTtcbmNsYXNzIFByZXBhcmVkRm9sZFdpZGdldCBleHRlbmRzIFdpZGdldFR5cGUge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB9XG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIHRoaXMudmFsdWUgPT0gb3RoZXIudmFsdWU7IH1cbiAgICB0b0RPTSh2aWV3KSB7IHJldHVybiB3aWRnZXRUb0RPTSh2aWV3LCB0aGlzLnZhbHVlKTsgfVxufVxuY29uc3QgZm9sZEd1dHRlckRlZmF1bHRzID0ge1xuICAgIG9wZW5UZXh0OiBcIuKMhFwiLFxuICAgIGNsb3NlZFRleHQ6IFwi4oC6XCIsXG4gICAgbWFya2VyRE9NOiBudWxsLFxuICAgIGRvbUV2ZW50SGFuZGxlcnM6IHt9LFxuICAgIGZvbGRpbmdDaGFuZ2VkOiAoKSA9PiBmYWxzZVxufTtcbmNsYXNzIEZvbGRNYXJrZXIgZXh0ZW5kcyBHdXR0ZXJNYXJrZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZywgb3Blbikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgdGhpcy5vcGVuID0gb3BlbjtcbiAgICB9XG4gICAgZXEob3RoZXIpIHsgcmV0dXJuIHRoaXMuY29uZmlnID09IG90aGVyLmNvbmZpZyAmJiB0aGlzLm9wZW4gPT0gb3RoZXIub3BlbjsgfVxuICAgIHRvRE9NKHZpZXcpIHtcbiAgICAgICAgaWYgKHRoaXMuY29uZmlnLm1hcmtlckRPTSlcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbmZpZy5tYXJrZXJET00odGhpcy5vcGVuKTtcbiAgICAgICAgbGV0IHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgc3Bhbi50ZXh0Q29udGVudCA9IHRoaXMub3BlbiA/IHRoaXMuY29uZmlnLm9wZW5UZXh0IDogdGhpcy5jb25maWcuY2xvc2VkVGV4dDtcbiAgICAgICAgc3Bhbi50aXRsZSA9IHZpZXcuc3RhdGUucGhyYXNlKHRoaXMub3BlbiA/IFwiRm9sZCBsaW5lXCIgOiBcIlVuZm9sZCBsaW5lXCIpO1xuICAgICAgICByZXR1cm4gc3BhbjtcbiAgICB9XG59XG4vKipcbkNyZWF0ZSBhbiBleHRlbnNpb24gdGhhdCByZWdpc3RlcnMgYSBmb2xkIGd1dHRlciwgd2hpY2ggc2hvd3MgYVxuZm9sZCBzdGF0dXMgaW5kaWNhdG9yIGJlZm9yZSBmb2xkYWJsZSBsaW5lcyAod2hpY2ggY2FuIGJlIGNsaWNrZWRcbnRvIGZvbGQgb3IgdW5mb2xkIHRoZSBsaW5lKS5cbiovXG5mdW5jdGlvbiBmb2xkR3V0dGVyKGNvbmZpZyA9IHt9KSB7XG4gICAgbGV0IGZ1bGxDb25maWcgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGZvbGRHdXR0ZXJEZWZhdWx0cyksIGNvbmZpZyk7XG4gICAgbGV0IGNhbkZvbGQgPSBuZXcgRm9sZE1hcmtlcihmdWxsQ29uZmlnLCB0cnVlKSwgY2FuVW5mb2xkID0gbmV3IEZvbGRNYXJrZXIoZnVsbENvbmZpZywgZmFsc2UpO1xuICAgIGxldCBtYXJrZXJzID0gVmlld1BsdWdpbi5mcm9tQ2xhc3MoY2xhc3Mge1xuICAgICAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgICAgICB0aGlzLmZyb20gPSB2aWV3LnZpZXdwb3J0LmZyb207XG4gICAgICAgICAgICB0aGlzLm1hcmtlcnMgPSB0aGlzLmJ1aWxkTWFya2Vycyh2aWV3KTtcbiAgICAgICAgfVxuICAgICAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgICAgICBpZiAodXBkYXRlLmRvY0NoYW5nZWQgfHwgdXBkYXRlLnZpZXdwb3J0Q2hhbmdlZCB8fFxuICAgICAgICAgICAgICAgIHVwZGF0ZS5zdGFydFN0YXRlLmZhY2V0KGxhbmd1YWdlKSAhPSB1cGRhdGUuc3RhdGUuZmFjZXQobGFuZ3VhZ2UpIHx8XG4gICAgICAgICAgICAgICAgdXBkYXRlLnN0YXJ0U3RhdGUuZmllbGQoZm9sZFN0YXRlLCBmYWxzZSkgIT0gdXBkYXRlLnN0YXRlLmZpZWxkKGZvbGRTdGF0ZSwgZmFsc2UpIHx8XG4gICAgICAgICAgICAgICAgc3ludGF4VHJlZSh1cGRhdGUuc3RhcnRTdGF0ZSkgIT0gc3ludGF4VHJlZSh1cGRhdGUuc3RhdGUpIHx8XG4gICAgICAgICAgICAgICAgZnVsbENvbmZpZy5mb2xkaW5nQ2hhbmdlZCh1cGRhdGUpKVxuICAgICAgICAgICAgICAgIHRoaXMubWFya2VycyA9IHRoaXMuYnVpbGRNYXJrZXJzKHVwZGF0ZS52aWV3KTtcbiAgICAgICAgfVxuICAgICAgICBidWlsZE1hcmtlcnModmlldykge1xuICAgICAgICAgICAgbGV0IGJ1aWxkZXIgPSBuZXcgUmFuZ2VTZXRCdWlsZGVyKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBsaW5lIG9mIHZpZXcudmlld3BvcnRMaW5lQmxvY2tzKSB7XG4gICAgICAgICAgICAgICAgbGV0IG1hcmsgPSBmaW5kRm9sZCh2aWV3LnN0YXRlLCBsaW5lLmZyb20sIGxpbmUudG8pID8gY2FuVW5mb2xkXG4gICAgICAgICAgICAgICAgICAgIDogZm9sZGFibGUodmlldy5zdGF0ZSwgbGluZS5mcm9tLCBsaW5lLnRvKSA/IGNhbkZvbGQgOiBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChtYXJrKVxuICAgICAgICAgICAgICAgICAgICBidWlsZGVyLmFkZChsaW5lLmZyb20sIGxpbmUuZnJvbSwgbWFyayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYnVpbGRlci5maW5pc2goKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGxldCB7IGRvbUV2ZW50SGFuZGxlcnMgfSA9IGZ1bGxDb25maWc7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgbWFya2VycyxcbiAgICAgICAgZ3V0dGVyKHtcbiAgICAgICAgICAgIGNsYXNzOiBcImNtLWZvbGRHdXR0ZXJcIixcbiAgICAgICAgICAgIG1hcmtlcnModmlldykgeyB2YXIgX2E7IHJldHVybiAoKF9hID0gdmlldy5wbHVnaW4obWFya2VycykpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXJrZXJzKSB8fCBSYW5nZVNldC5lbXB0eTsgfSxcbiAgICAgICAgICAgIGluaXRpYWxTcGFjZXIoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBGb2xkTWFya2VyKGZ1bGxDb25maWcsIGZhbHNlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkb21FdmVudEhhbmRsZXJzOiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRvbUV2ZW50SGFuZGxlcnMpLCB7IGNsaWNrOiAodmlldywgbGluZSwgZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbUV2ZW50SGFuZGxlcnMuY2xpY2sgJiYgZG9tRXZlbnRIYW5kbGVycy5jbGljayh2aWV3LCBsaW5lLCBldmVudCkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGZvbGRlZCA9IGZpbmRGb2xkKHZpZXcuc3RhdGUsIGxpbmUuZnJvbSwgbGluZS50byk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb2xkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZpZXcuZGlzcGF0Y2goeyBlZmZlY3RzOiB1bmZvbGRFZmZlY3Qub2YoZm9sZGVkKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxldCByYW5nZSA9IGZvbGRhYmxlKHZpZXcuc3RhdGUsIGxpbmUuZnJvbSwgbGluZS50byk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh7IGVmZmVjdHM6IGZvbGRFZmZlY3Qub2YocmFuZ2UpIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0gfSlcbiAgICAgICAgfSksXG4gICAgICAgIGNvZGVGb2xkaW5nKClcbiAgICBdO1xufVxuY29uc3QgYmFzZVRoZW1lJDEgPSAvKkBfX1BVUkVfXyovRWRpdG9yVmlldy5iYXNlVGhlbWUoe1xuICAgIFwiLmNtLWZvbGRQbGFjZWhvbGRlclwiOiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIjZWVlXCIsXG4gICAgICAgIGJvcmRlcjogXCIxcHggc29saWQgI2RkZFwiLFxuICAgICAgICBjb2xvcjogXCIjODg4XCIsXG4gICAgICAgIGJvcmRlclJhZGl1czogXCIuMmVtXCIsXG4gICAgICAgIG1hcmdpbjogXCIwIDFweFwiLFxuICAgICAgICBwYWRkaW5nOiBcIjAgMXB4XCIsXG4gICAgICAgIGN1cnNvcjogXCJwb2ludGVyXCJcbiAgICB9LFxuICAgIFwiLmNtLWZvbGRHdXR0ZXIgc3BhblwiOiB7XG4gICAgICAgIHBhZGRpbmc6IFwiMCAxcHhcIixcbiAgICAgICAgY3Vyc29yOiBcInBvaW50ZXJcIlxuICAgIH1cbn0pO1xuXG4vKipcbkEgaGlnaGxpZ2h0IHN0eWxlIGFzc29jaWF0ZXMgQ1NTIHN0eWxlcyB3aXRoIGhpZ2xpZ2h0aW5nXG5bdGFnc10oaHR0cHM6Ly9sZXplci5jb2RlbWlycm9yLm5ldC9kb2NzL3JlZiNoaWdobGlnaHQuVGFnKS5cbiovXG5jbGFzcyBIaWdobGlnaHRTdHlsZSB7XG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHRhZyBzdHlsZXMgdXNlZCB0byBjcmVhdGUgdGhpcyBoaWdobGlnaHQgc3R5bGUuXG4gICAgKi9cbiAgICBzcGVjcywgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnNwZWNzID0gc3BlY3M7XG4gICAgICAgIGxldCBtb2RTcGVjO1xuICAgICAgICBmdW5jdGlvbiBkZWYoc3BlYykge1xuICAgICAgICAgICAgbGV0IGNscyA9IFN0eWxlTW9kdWxlLm5ld05hbWUoKTtcbiAgICAgICAgICAgIChtb2RTcGVjIHx8IChtb2RTcGVjID0gT2JqZWN0LmNyZWF0ZShudWxsKSkpW1wiLlwiICsgY2xzXSA9IHNwZWM7XG4gICAgICAgICAgICByZXR1cm4gY2xzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFsbCA9IHR5cGVvZiBvcHRpb25zLmFsbCA9PSBcInN0cmluZ1wiID8gb3B0aW9ucy5hbGwgOiBvcHRpb25zLmFsbCA/IGRlZihvcHRpb25zLmFsbCkgOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHNjb3BlT3B0ID0gb3B0aW9ucy5zY29wZTtcbiAgICAgICAgdGhpcy5zY29wZSA9IHNjb3BlT3B0IGluc3RhbmNlb2YgTGFuZ3VhZ2UgPyAodHlwZSkgPT4gdHlwZS5wcm9wKGxhbmd1YWdlRGF0YVByb3ApID09IHNjb3BlT3B0LmRhdGFcbiAgICAgICAgICAgIDogc2NvcGVPcHQgPyAodHlwZSkgPT4gdHlwZSA9PSBzY29wZU9wdCA6IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5zdHlsZSA9IHRhZ0hpZ2hsaWdodGVyKHNwZWNzLm1hcChzdHlsZSA9PiAoe1xuICAgICAgICAgICAgdGFnOiBzdHlsZS50YWcsXG4gICAgICAgICAgICBjbGFzczogc3R5bGUuY2xhc3MgfHwgZGVmKE9iamVjdC5hc3NpZ24oe30sIHN0eWxlLCB7IHRhZzogbnVsbCB9KSlcbiAgICAgICAgfSkpLCB7XG4gICAgICAgICAgICBhbGwsXG4gICAgICAgIH0pLnN0eWxlO1xuICAgICAgICB0aGlzLm1vZHVsZSA9IG1vZFNwZWMgPyBuZXcgU3R5bGVNb2R1bGUobW9kU3BlYykgOiBudWxsO1xuICAgICAgICB0aGlzLnRoZW1lVHlwZSA9IG9wdGlvbnMudGhlbWVUeXBlO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBoaWdobGlnaHRlciBzdHlsZSB0aGF0IGFzc29jaWF0ZXMgdGhlIGdpdmVuIHN0eWxlcyB0b1xuICAgIHRoZSBnaXZlbiB0YWdzLiBUaGUgc3BlY3MgbXVzdCBiZSBvYmplY3RzIHRoYXQgaG9sZCBhIHN0eWxlIHRhZ1xuICAgIG9yIGFycmF5IG9mIHRhZ3MgaW4gdGhlaXIgYHRhZ2AgcHJvcGVydHksIGFuZCBlaXRoZXIgYSBzaW5nbGVcbiAgICBgY2xhc3NgIHByb3BlcnR5IHByb3ZpZGluZyBhIHN0YXRpYyBDU1MgY2xhc3MgKGZvciBoaWdobGlnaHRlclxuICAgIHRoYXQgcmVseSBvbiBleHRlcm5hbCBzdHlsaW5nKSwgb3IgYVxuICAgIFtgc3R5bGUtbW9kYF0oaHR0cHM6Ly9naXRodWIuY29tL21hcmlqbmgvc3R5bGUtbW9kI2RvY3VtZW50YXRpb24pLXN0eWxlXG4gICAgc2V0IG9mIENTUyBwcm9wZXJ0aWVzICh3aGljaCBkZWZpbmUgdGhlIHN0eWxpbmcgZm9yIHRob3NlIHRhZ3MpLlxuICAgIFxuICAgIFRoZSBDU1MgcnVsZXMgY3JlYXRlZCBmb3IgYSBoaWdobGlnaHRlciB3aWxsIGJlIGVtaXR0ZWQgaW4gdGhlXG4gICAgb3JkZXIgb2YgdGhlIHNwZWMncyBwcm9wZXJ0aWVzLiBUaGF0IG1lYW5zIHRoYXQgZm9yIGVsZW1lbnRzIHRoYXRcbiAgICBoYXZlIG11bHRpcGxlIHRhZ3MgYXNzb2NpYXRlZCB3aXRoIHRoZW0sIHN0eWxlcyBkZWZpbmVkIGZ1cnRoZXJcbiAgICBkb3duIGluIHRoZSBsaXN0IHdpbGwgaGF2ZSBhIGhpZ2hlciBDU1MgcHJlY2VkZW5jZSB0aGFuIHN0eWxlc1xuICAgIGRlZmluZWQgZWFybGllci5cbiAgICAqL1xuICAgIHN0YXRpYyBkZWZpbmUoc3BlY3MsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBIaWdobGlnaHRTdHlsZShzcGVjcywgb3B0aW9ucyB8fCB7fSk7XG4gICAgfVxufVxuY29uc3QgaGlnaGxpZ2h0ZXJGYWNldCA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoKTtcbmNvbnN0IGZhbGxiYWNrSGlnaGxpZ2h0ZXIgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHtcbiAgICBjb21iaW5lKHZhbHVlcykgeyByZXR1cm4gdmFsdWVzLmxlbmd0aCA/IFt2YWx1ZXNbMF1dIDogbnVsbDsgfVxufSk7XG5mdW5jdGlvbiBnZXRIaWdobGlnaHRlcnMoc3RhdGUpIHtcbiAgICBsZXQgbWFpbiA9IHN0YXRlLmZhY2V0KGhpZ2hsaWdodGVyRmFjZXQpO1xuICAgIHJldHVybiBtYWluLmxlbmd0aCA/IG1haW4gOiBzdGF0ZS5mYWNldChmYWxsYmFja0hpZ2hsaWdodGVyKTtcbn1cbi8qKlxuV3JhcCBhIGhpZ2hsaWdodGVyIGluIGFuIGVkaXRvciBleHRlbnNpb24gdGhhdCB1c2VzIGl0IHRvIGFwcGx5XG5zeW50YXggaGlnaGxpZ2h0aW5nIHRvIHRoZSBlZGl0b3IgY29udGVudC5cblxuV2hlbiBtdWx0aXBsZSAobm9uLWZhbGxiYWNrKSBzdHlsZXMgYXJlIHByb3ZpZGVkLCB0aGUgc3R5bGluZ1xuYXBwbGllZCBpcyB0aGUgdW5pb24gb2YgdGhlIGNsYXNzZXMgdGhleSBlbWl0LlxuKi9cbmZ1bmN0aW9uIHN5bnRheEhpZ2hsaWdodGluZyhoaWdobGlnaHRlciwgb3B0aW9ucykge1xuICAgIGxldCBleHQgPSBbdHJlZUhpZ2hsaWdodGVyXSwgdGhlbWVUeXBlO1xuICAgIGlmIChoaWdobGlnaHRlciBpbnN0YW5jZW9mIEhpZ2hsaWdodFN0eWxlKSB7XG4gICAgICAgIGlmIChoaWdobGlnaHRlci5tb2R1bGUpXG4gICAgICAgICAgICBleHQucHVzaChFZGl0b3JWaWV3LnN0eWxlTW9kdWxlLm9mKGhpZ2hsaWdodGVyLm1vZHVsZSkpO1xuICAgICAgICB0aGVtZVR5cGUgPSBoaWdobGlnaHRlci50aGVtZVR5cGU7XG4gICAgfVxuICAgIGlmIChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZmFsbGJhY2spXG4gICAgICAgIGV4dC5wdXNoKGZhbGxiYWNrSGlnaGxpZ2h0ZXIub2YoaGlnaGxpZ2h0ZXIpKTtcbiAgICBlbHNlIGlmICh0aGVtZVR5cGUpXG4gICAgICAgIGV4dC5wdXNoKGhpZ2hsaWdodGVyRmFjZXQuY29tcHV0ZU4oW0VkaXRvclZpZXcuZGFya1RoZW1lXSwgc3RhdGUgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlLmZhY2V0KEVkaXRvclZpZXcuZGFya1RoZW1lKSA9PSAodGhlbWVUeXBlID09IFwiZGFya1wiKSA/IFtoaWdobGlnaHRlcl0gOiBbXTtcbiAgICAgICAgfSkpO1xuICAgIGVsc2VcbiAgICAgICAgZXh0LnB1c2goaGlnaGxpZ2h0ZXJGYWNldC5vZihoaWdobGlnaHRlcikpO1xuICAgIHJldHVybiBleHQ7XG59XG4vKipcblJldHVybnMgdGhlIENTUyBjbGFzc2VzIChpZiBhbnkpIHRoYXQgdGhlIGhpZ2hsaWdodGVycyBhY3RpdmUgaW5cbnRoZSBzdGF0ZSB3b3VsZCBhc3NpZ24gdG8gdGhlIGdpdmVuIHN0eWxlXG5bdGFnc10oaHR0cHM6Ly9sZXplci5jb2RlbWlycm9yLm5ldC9kb2NzL3JlZiNoaWdobGlnaHQuVGFnKSBhbmRcbihvcHRpb25hbCkgbGFuZ3VhZ2VcbltzY29wZV0oaHR0cHM6Ly9jb2RlbWlycm9yLm5ldC82L2RvY3MvcmVmLyNsYW5ndWFnZS5IaWdobGlnaHRTdHlsZV5kZWZpbmVeb3B0aW9ucy5zY29wZSkuXG4qL1xuZnVuY3Rpb24gaGlnaGxpZ2h0aW5nRm9yKHN0YXRlLCB0YWdzLCBzY29wZSkge1xuICAgIGxldCBoaWdobGlnaHRlcnMgPSBnZXRIaWdobGlnaHRlcnMoc3RhdGUpO1xuICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgIGlmIChoaWdobGlnaHRlcnMpXG4gICAgICAgIGZvciAobGV0IGhpZ2hsaWdodGVyIG9mIGhpZ2hsaWdodGVycykge1xuICAgICAgICAgICAgaWYgKCFoaWdobGlnaHRlci5zY29wZSB8fCBzY29wZSAmJiBoaWdobGlnaHRlci5zY29wZShzY29wZSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgY2xzID0gaGlnaGxpZ2h0ZXIuc3R5bGUodGFncyk7XG4gICAgICAgICAgICAgICAgaWYgKGNscylcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0ID8gcmVzdWx0ICsgXCIgXCIgKyBjbHMgOiBjbHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuY2xhc3MgVHJlZUhpZ2hsaWdodGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih2aWV3KSB7XG4gICAgICAgIHRoaXMubWFya0NhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgdGhpcy50cmVlID0gc3ludGF4VHJlZSh2aWV3LnN0YXRlKTtcbiAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuYnVpbGREZWNvKHZpZXcsIGdldEhpZ2hsaWdodGVycyh2aWV3LnN0YXRlKSk7XG4gICAgICAgIHRoaXMuZGVjb3JhdGVkVG8gPSB2aWV3LnZpZXdwb3J0LnRvO1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGxldCB0cmVlID0gc3ludGF4VHJlZSh1cGRhdGUuc3RhdGUpLCBoaWdobGlnaHRlcnMgPSBnZXRIaWdobGlnaHRlcnModXBkYXRlLnN0YXRlKTtcbiAgICAgICAgbGV0IHN0eWxlQ2hhbmdlID0gaGlnaGxpZ2h0ZXJzICE9IGdldEhpZ2hsaWdodGVycyh1cGRhdGUuc3RhcnRTdGF0ZSk7XG4gICAgICAgIGxldCB7IHZpZXdwb3J0IH0gPSB1cGRhdGUudmlldywgZGVjb3JhdGVkVG9NYXBwZWQgPSB1cGRhdGUuY2hhbmdlcy5tYXBQb3ModGhpcy5kZWNvcmF0ZWRUbywgMSk7XG4gICAgICAgIGlmICh0cmVlLmxlbmd0aCA8IHZpZXdwb3J0LnRvICYmICFzdHlsZUNoYW5nZSAmJiB0cmVlLnR5cGUgPT0gdGhpcy50cmVlLnR5cGUgJiYgZGVjb3JhdGVkVG9NYXBwZWQgPj0gdmlld3BvcnQudG8pIHtcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmRlY29yYXRpb25zLm1hcCh1cGRhdGUuY2hhbmdlcyk7XG4gICAgICAgICAgICB0aGlzLmRlY29yYXRlZFRvID0gZGVjb3JhdGVkVG9NYXBwZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHJlZSAhPSB0aGlzLnRyZWUgfHwgdXBkYXRlLnZpZXdwb3J0Q2hhbmdlZCB8fCBzdHlsZUNoYW5nZSkge1xuICAgICAgICAgICAgdGhpcy50cmVlID0gdHJlZTtcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmJ1aWxkRGVjbyh1cGRhdGUudmlldywgaGlnaGxpZ2h0ZXJzKTtcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdGVkVG8gPSB2aWV3cG9ydC50bztcbiAgICAgICAgfVxuICAgIH1cbiAgICBidWlsZERlY28odmlldywgaGlnaGxpZ2h0ZXJzKSB7XG4gICAgICAgIGlmICghaGlnaGxpZ2h0ZXJzIHx8ICF0aGlzLnRyZWUubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIERlY29yYXRpb24ubm9uZTtcbiAgICAgICAgbGV0IGJ1aWxkZXIgPSBuZXcgUmFuZ2VTZXRCdWlsZGVyKCk7XG4gICAgICAgIGZvciAobGV0IHsgZnJvbSwgdG8gfSBvZiB2aWV3LnZpc2libGVSYW5nZXMpIHtcbiAgICAgICAgICAgIGhpZ2hsaWdodFRyZWUodGhpcy50cmVlLCBoaWdobGlnaHRlcnMsIChmcm9tLCB0bywgc3R5bGUpID0+IHtcbiAgICAgICAgICAgICAgICBidWlsZGVyLmFkZChmcm9tLCB0bywgdGhpcy5tYXJrQ2FjaGVbc3R5bGVdIHx8ICh0aGlzLm1hcmtDYWNoZVtzdHlsZV0gPSBEZWNvcmF0aW9uLm1hcmsoeyBjbGFzczogc3R5bGUgfSkpKTtcbiAgICAgICAgICAgIH0sIGZyb20sIHRvKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnVpbGRlci5maW5pc2goKTtcbiAgICB9XG59XG5jb25zdCB0cmVlSGlnaGxpZ2h0ZXIgPSAvKkBfX1BVUkVfXyovUHJlYy5oaWdoKC8qQF9fUFVSRV9fKi9WaWV3UGx1Z2luLmZyb21DbGFzcyhUcmVlSGlnaGxpZ2h0ZXIsIHtcbiAgICBkZWNvcmF0aW9uczogdiA9PiB2LmRlY29yYXRpb25zXG59KSk7XG4vKipcbkEgZGVmYXVsdCBoaWdobGlnaHQgc3R5bGUgKHdvcmtzIHdlbGwgd2l0aCBsaWdodCB0aGVtZXMpLlxuKi9cbmNvbnN0IGRlZmF1bHRIaWdobGlnaHRTdHlsZSA9IC8qQF9fUFVSRV9fKi9IaWdobGlnaHRTdHlsZS5kZWZpbmUoW1xuICAgIHsgdGFnOiB0YWdzLm1ldGEsXG4gICAgICAgIGNvbG9yOiBcIiM0MDQ3NDBcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmxpbmssXG4gICAgICAgIHRleHREZWNvcmF0aW9uOiBcInVuZGVybGluZVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuaGVhZGluZyxcbiAgICAgICAgdGV4dERlY29yYXRpb246IFwidW5kZXJsaW5lXCIsXG4gICAgICAgIGZvbnRXZWlnaHQ6IFwiYm9sZFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuZW1waGFzaXMsXG4gICAgICAgIGZvbnRTdHlsZTogXCJpdGFsaWNcIiB9LFxuICAgIHsgdGFnOiB0YWdzLnN0cm9uZyxcbiAgICAgICAgZm9udFdlaWdodDogXCJib2xkXCIgfSxcbiAgICB7IHRhZzogdGFncy5zdHJpa2V0aHJvdWdoLFxuICAgICAgICB0ZXh0RGVjb3JhdGlvbjogXCJsaW5lLXRocm91Z2hcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmtleXdvcmQsXG4gICAgICAgIGNvbG9yOiBcIiM3MDhcIiB9LFxuICAgIHsgdGFnOiBbdGFncy5hdG9tLCB0YWdzLmJvb2wsIHRhZ3MudXJsLCB0YWdzLmNvbnRlbnRTZXBhcmF0b3IsIHRhZ3MubGFiZWxOYW1lXSxcbiAgICAgICAgY29sb3I6IFwiIzIxOVwiIH0sXG4gICAgeyB0YWc6IFt0YWdzLmxpdGVyYWwsIHRhZ3MuaW5zZXJ0ZWRdLFxuICAgICAgICBjb2xvcjogXCIjMTY0XCIgfSxcbiAgICB7IHRhZzogW3RhZ3Muc3RyaW5nLCB0YWdzLmRlbGV0ZWRdLFxuICAgICAgICBjb2xvcjogXCIjYTExXCIgfSxcbiAgICB7IHRhZzogW3RhZ3MucmVnZXhwLCB0YWdzLmVzY2FwZSwgLypAX19QVVJFX18qL3RhZ3Muc3BlY2lhbCh0YWdzLnN0cmluZyldLFxuICAgICAgICBjb2xvcjogXCIjZTQwXCIgfSxcbiAgICB7IHRhZzogLypAX19QVVJFX18qL3RhZ3MuZGVmaW5pdGlvbih0YWdzLnZhcmlhYmxlTmFtZSksXG4gICAgICAgIGNvbG9yOiBcIiMwMGZcIiB9LFxuICAgIHsgdGFnOiAvKkBfX1BVUkVfXyovdGFncy5sb2NhbCh0YWdzLnZhcmlhYmxlTmFtZSksXG4gICAgICAgIGNvbG9yOiBcIiMzMGFcIiB9LFxuICAgIHsgdGFnOiBbdGFncy50eXBlTmFtZSwgdGFncy5uYW1lc3BhY2VdLFxuICAgICAgICBjb2xvcjogXCIjMDg1XCIgfSxcbiAgICB7IHRhZzogdGFncy5jbGFzc05hbWUsXG4gICAgICAgIGNvbG9yOiBcIiMxNjdcIiB9LFxuICAgIHsgdGFnOiBbLypAX19QVVJFX18qL3RhZ3Muc3BlY2lhbCh0YWdzLnZhcmlhYmxlTmFtZSksIHRhZ3MubWFjcm9OYW1lXSxcbiAgICAgICAgY29sb3I6IFwiIzI1NlwiIH0sXG4gICAgeyB0YWc6IC8qQF9fUFVSRV9fKi90YWdzLmRlZmluaXRpb24odGFncy5wcm9wZXJ0eU5hbWUpLFxuICAgICAgICBjb2xvcjogXCIjMDBjXCIgfSxcbiAgICB7IHRhZzogdGFncy5jb21tZW50LFxuICAgICAgICBjb2xvcjogXCIjOTQwXCIgfSxcbiAgICB7IHRhZzogdGFncy5pbnZhbGlkLFxuICAgICAgICBjb2xvcjogXCIjZjAwXCIgfVxuXSk7XG5cbmNvbnN0IGJhc2VUaGVtZSA9IC8qQF9fUFVSRV9fKi9FZGl0b3JWaWV3LmJhc2VUaGVtZSh7XG4gICAgXCImLmNtLWZvY3VzZWQgLmNtLW1hdGNoaW5nQnJhY2tldFwiOiB7IGJhY2tncm91bmRDb2xvcjogXCIjMzI4YzgyNTJcIiB9LFxuICAgIFwiJi5jbS1mb2N1c2VkIC5jbS1ub25tYXRjaGluZ0JyYWNrZXRcIjogeyBiYWNrZ3JvdW5kQ29sb3I6IFwiI2JiNTU1NTQ0XCIgfVxufSk7XG5jb25zdCBEZWZhdWx0U2NhbkRpc3QgPSAxMDAwMCwgRGVmYXVsdEJyYWNrZXRzID0gXCIoKVtde31cIjtcbmNvbnN0IGJyYWNrZXRNYXRjaGluZ0NvbmZpZyA9IC8qQF9fUFVSRV9fKi9GYWNldC5kZWZpbmUoe1xuICAgIGNvbWJpbmUoY29uZmlncykge1xuICAgICAgICByZXR1cm4gY29tYmluZUNvbmZpZyhjb25maWdzLCB7XG4gICAgICAgICAgICBhZnRlckN1cnNvcjogdHJ1ZSxcbiAgICAgICAgICAgIGJyYWNrZXRzOiBEZWZhdWx0QnJhY2tldHMsXG4gICAgICAgICAgICBtYXhTY2FuRGlzdGFuY2U6IERlZmF1bHRTY2FuRGlzdCxcbiAgICAgICAgICAgIHJlbmRlck1hdGNoOiBkZWZhdWx0UmVuZGVyTWF0Y2hcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5jb25zdCBtYXRjaGluZ01hcmsgPSAvKkBfX1BVUkVfXyovRGVjb3JhdGlvbi5tYXJrKHsgY2xhc3M6IFwiY20tbWF0Y2hpbmdCcmFja2V0XCIgfSksIG5vbm1hdGNoaW5nTWFyayA9IC8qQF9fUFVSRV9fKi9EZWNvcmF0aW9uLm1hcmsoeyBjbGFzczogXCJjbS1ub25tYXRjaGluZ0JyYWNrZXRcIiB9KTtcbmZ1bmN0aW9uIGRlZmF1bHRSZW5kZXJNYXRjaChtYXRjaCkge1xuICAgIGxldCBkZWNvcmF0aW9ucyA9IFtdO1xuICAgIGxldCBtYXJrID0gbWF0Y2gubWF0Y2hlZCA/IG1hdGNoaW5nTWFyayA6IG5vbm1hdGNoaW5nTWFyaztcbiAgICBkZWNvcmF0aW9ucy5wdXNoKG1hcmsucmFuZ2UobWF0Y2guc3RhcnQuZnJvbSwgbWF0Y2guc3RhcnQudG8pKTtcbiAgICBpZiAobWF0Y2guZW5kKVxuICAgICAgICBkZWNvcmF0aW9ucy5wdXNoKG1hcmsucmFuZ2UobWF0Y2guZW5kLmZyb20sIG1hdGNoLmVuZC50bykpO1xuICAgIHJldHVybiBkZWNvcmF0aW9ucztcbn1cbmNvbnN0IGJyYWNrZXRNYXRjaGluZ1N0YXRlID0gLypAX19QVVJFX18qL1N0YXRlRmllbGQuZGVmaW5lKHtcbiAgICBjcmVhdGUoKSB7IHJldHVybiBEZWNvcmF0aW9uLm5vbmU7IH0sXG4gICAgdXBkYXRlKGRlY28sIHRyKSB7XG4gICAgICAgIGlmICghdHIuZG9jQ2hhbmdlZCAmJiAhdHIuc2VsZWN0aW9uKVxuICAgICAgICAgICAgcmV0dXJuIGRlY287XG4gICAgICAgIGxldCBkZWNvcmF0aW9ucyA9IFtdO1xuICAgICAgICBsZXQgY29uZmlnID0gdHIuc3RhdGUuZmFjZXQoYnJhY2tldE1hdGNoaW5nQ29uZmlnKTtcbiAgICAgICAgZm9yIChsZXQgcmFuZ2Ugb2YgdHIuc3RhdGUuc2VsZWN0aW9uLnJhbmdlcykge1xuICAgICAgICAgICAgaWYgKCFyYW5nZS5lbXB0eSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGxldCBtYXRjaCA9IG1hdGNoQnJhY2tldHModHIuc3RhdGUsIHJhbmdlLmhlYWQsIC0xLCBjb25maWcpXG4gICAgICAgICAgICAgICAgfHwgKHJhbmdlLmhlYWQgPiAwICYmIG1hdGNoQnJhY2tldHModHIuc3RhdGUsIHJhbmdlLmhlYWQgLSAxLCAxLCBjb25maWcpKVxuICAgICAgICAgICAgICAgIHx8IChjb25maWcuYWZ0ZXJDdXJzb3IgJiZcbiAgICAgICAgICAgICAgICAgICAgKG1hdGNoQnJhY2tldHModHIuc3RhdGUsIHJhbmdlLmhlYWQsIDEsIGNvbmZpZykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIChyYW5nZS5oZWFkIDwgdHIuc3RhdGUuZG9jLmxlbmd0aCAmJiBtYXRjaEJyYWNrZXRzKHRyLnN0YXRlLCByYW5nZS5oZWFkICsgMSwgLTEsIGNvbmZpZykpKSk7XG4gICAgICAgICAgICBpZiAobWF0Y2gpXG4gICAgICAgICAgICAgICAgZGVjb3JhdGlvbnMgPSBkZWNvcmF0aW9ucy5jb25jYXQoY29uZmlnLnJlbmRlck1hdGNoKG1hdGNoLCB0ci5zdGF0ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBEZWNvcmF0aW9uLnNldChkZWNvcmF0aW9ucywgdHJ1ZSk7XG4gICAgfSxcbiAgICBwcm92aWRlOiBmID0+IEVkaXRvclZpZXcuZGVjb3JhdGlvbnMuZnJvbShmKVxufSk7XG5jb25zdCBicmFja2V0TWF0Y2hpbmdVbmlxdWUgPSBbXG4gICAgYnJhY2tldE1hdGNoaW5nU3RhdGUsXG4gICAgYmFzZVRoZW1lXG5dO1xuLyoqXG5DcmVhdGUgYW4gZXh0ZW5zaW9uIHRoYXQgZW5hYmxlcyBicmFja2V0IG1hdGNoaW5nLiBXaGVuZXZlciB0aGVcbmN1cnNvciBpcyBuZXh0IHRvIGEgYnJhY2tldCwgdGhhdCBicmFja2V0IGFuZCB0aGUgb25lIGl0IG1hdGNoZXNcbmFyZSBoaWdobGlnaHRlZC4gT3IsIHdoZW4gbm8gbWF0Y2hpbmcgYnJhY2tldCBpcyBmb3VuZCwgYW5vdGhlclxuaGlnaGxpZ2h0aW5nIHN0eWxlIGlzIHVzZWQgdG8gaW5kaWNhdGUgdGhpcy5cbiovXG5mdW5jdGlvbiBicmFja2V0TWF0Y2hpbmcoY29uZmlnID0ge30pIHtcbiAgICByZXR1cm4gW2JyYWNrZXRNYXRjaGluZ0NvbmZpZy5vZihjb25maWcpLCBicmFja2V0TWF0Y2hpbmdVbmlxdWVdO1xufVxuLyoqXG5XaGVuIGxhcmdlciBzeW50YXggbm9kZXMsIHN1Y2ggYXMgSFRNTCB0YWdzLCBhcmUgbWFya2VkIGFzXG5vcGVuaW5nL2Nsb3NpbmcsIGl0IGNhbiBiZSBhIGJpdCBtZXNzeSB0byB0cmVhdCB0aGUgd2hvbGUgbm9kZSBhc1xuYSBtYXRjaGFibGUgYnJhY2tldC4gVGhpcyBub2RlIHByb3AgYWxsb3dzIHlvdSB0byBkZWZpbmUsIGZvciBzdWNoXG5hIG5vZGUsIGEg4oCYaGFuZGxl4oCZ4oCUdGhlIHBhcnQgb2YgdGhlIG5vZGUgdGhhdCBpcyBoaWdobGlnaHRlZCwgYW5kXG50aGF0IHRoZSBjdXJzb3IgbXVzdCBiZSBvbiB0byBhY3RpdmF0ZSBoaWdobGlnaHRpbmcgaW4gdGhlIGZpcnN0XG5wbGFjZS5cbiovXG5jb25zdCBicmFja2V0TWF0Y2hpbmdIYW5kbGUgPSAvKkBfX1BVUkVfXyovbmV3IE5vZGVQcm9wKCk7XG5mdW5jdGlvbiBtYXRjaGluZ05vZGVzKG5vZGUsIGRpciwgYnJhY2tldHMpIHtcbiAgICBsZXQgYnlQcm9wID0gbm9kZS5wcm9wKGRpciA8IDAgPyBOb2RlUHJvcC5vcGVuZWRCeSA6IE5vZGVQcm9wLmNsb3NlZEJ5KTtcbiAgICBpZiAoYnlQcm9wKVxuICAgICAgICByZXR1cm4gYnlQcm9wO1xuICAgIGlmIChub2RlLm5hbWUubGVuZ3RoID09IDEpIHtcbiAgICAgICAgbGV0IGluZGV4ID0gYnJhY2tldHMuaW5kZXhPZihub2RlLm5hbWUpO1xuICAgICAgICBpZiAoaW5kZXggPiAtMSAmJiBpbmRleCAlIDIgPT0gKGRpciA8IDAgPyAxIDogMCkpXG4gICAgICAgICAgICByZXR1cm4gW2JyYWNrZXRzW2luZGV4ICsgZGlyXV07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZmluZEhhbmRsZShub2RlKSB7XG4gICAgbGV0IGhhc0hhbmRsZSA9IG5vZGUudHlwZS5wcm9wKGJyYWNrZXRNYXRjaGluZ0hhbmRsZSk7XG4gICAgcmV0dXJuIGhhc0hhbmRsZSA/IGhhc0hhbmRsZShub2RlLm5vZGUpIDogbm9kZTtcbn1cbi8qKlxuRmluZCB0aGUgbWF0Y2hpbmcgYnJhY2tldCBmb3IgdGhlIHRva2VuIGF0IGBwb3NgLCBzY2FubmluZ1xuZGlyZWN0aW9uIGBkaXJgLiBPbmx5IHRoZSBgYnJhY2tldHNgIGFuZCBgbWF4U2NhbkRpc3RhbmNlYFxucHJvcGVydGllcyBhcmUgdXNlZCBmcm9tIGBjb25maWdgLCBpZiBnaXZlbi4gUmV0dXJucyBudWxsIGlmIG5vXG5icmFja2V0IHdhcyBmb3VuZCBhdCBgcG9zYCwgb3IgYSBtYXRjaCByZXN1bHQgb3RoZXJ3aXNlLlxuKi9cbmZ1bmN0aW9uIG1hdGNoQnJhY2tldHMoc3RhdGUsIHBvcywgZGlyLCBjb25maWcgPSB7fSkge1xuICAgIGxldCBtYXhTY2FuRGlzdGFuY2UgPSBjb25maWcubWF4U2NhbkRpc3RhbmNlIHx8IERlZmF1bHRTY2FuRGlzdCwgYnJhY2tldHMgPSBjb25maWcuYnJhY2tldHMgfHwgRGVmYXVsdEJyYWNrZXRzO1xuICAgIGxldCB0cmVlID0gc3ludGF4VHJlZShzdGF0ZSksIG5vZGUgPSB0cmVlLnJlc29sdmVJbm5lcihwb3MsIGRpcik7XG4gICAgZm9yIChsZXQgY3VyID0gbm9kZTsgY3VyOyBjdXIgPSBjdXIucGFyZW50KSB7XG4gICAgICAgIGxldCBtYXRjaGVzID0gbWF0Y2hpbmdOb2RlcyhjdXIudHlwZSwgZGlyLCBicmFja2V0cyk7XG4gICAgICAgIGlmIChtYXRjaGVzICYmIGN1ci5mcm9tIDwgY3VyLnRvKSB7XG4gICAgICAgICAgICBsZXQgaGFuZGxlID0gZmluZEhhbmRsZShjdXIpO1xuICAgICAgICAgICAgaWYgKGhhbmRsZSAmJiAoZGlyID4gMCA/IHBvcyA+PSBoYW5kbGUuZnJvbSAmJiBwb3MgPCBoYW5kbGUudG8gOiBwb3MgPiBoYW5kbGUuZnJvbSAmJiBwb3MgPD0gaGFuZGxlLnRvKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2hNYXJrZWRCcmFja2V0cyhzdGF0ZSwgcG9zLCBkaXIsIGN1ciwgaGFuZGxlLCBtYXRjaGVzLCBicmFja2V0cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hdGNoUGxhaW5CcmFja2V0cyhzdGF0ZSwgcG9zLCBkaXIsIHRyZWUsIG5vZGUudHlwZSwgbWF4U2NhbkRpc3RhbmNlLCBicmFja2V0cyk7XG59XG5mdW5jdGlvbiBtYXRjaE1hcmtlZEJyYWNrZXRzKF9zdGF0ZSwgX3BvcywgZGlyLCB0b2tlbiwgaGFuZGxlLCBtYXRjaGluZywgYnJhY2tldHMpIHtcbiAgICBsZXQgcGFyZW50ID0gdG9rZW4ucGFyZW50LCBmaXJzdFRva2VuID0geyBmcm9tOiBoYW5kbGUuZnJvbSwgdG86IGhhbmRsZS50byB9O1xuICAgIGxldCBkZXB0aCA9IDAsIGN1cnNvciA9IHBhcmVudCA9PT0gbnVsbCB8fCBwYXJlbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcmVudC5jdXJzb3IoKTtcbiAgICBpZiAoY3Vyc29yICYmIChkaXIgPCAwID8gY3Vyc29yLmNoaWxkQmVmb3JlKHRva2VuLmZyb20pIDogY3Vyc29yLmNoaWxkQWZ0ZXIodG9rZW4udG8pKSlcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaWYgKGRpciA8IDAgPyBjdXJzb3IudG8gPD0gdG9rZW4uZnJvbSA6IGN1cnNvci5mcm9tID49IHRva2VuLnRvKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlcHRoID09IDAgJiYgbWF0Y2hpbmcuaW5kZXhPZihjdXJzb3IudHlwZS5uYW1lKSA+IC0xICYmIGN1cnNvci5mcm9tIDwgY3Vyc29yLnRvKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBlbmRIYW5kbGUgPSBmaW5kSGFuZGxlKGN1cnNvcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHN0YXJ0OiBmaXJzdFRva2VuLCBlbmQ6IGVuZEhhbmRsZSA/IHsgZnJvbTogZW5kSGFuZGxlLmZyb20sIHRvOiBlbmRIYW5kbGUudG8gfSA6IHVuZGVmaW5lZCwgbWF0Y2hlZDogdHJ1ZSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtYXRjaGluZ05vZGVzKGN1cnNvci50eXBlLCBkaXIsIGJyYWNrZXRzKSkge1xuICAgICAgICAgICAgICAgICAgICBkZXB0aCsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtYXRjaGluZ05vZGVzKGN1cnNvci50eXBlLCAtZGlyLCBicmFja2V0cykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlcHRoID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBlbmRIYW5kbGUgPSBmaW5kSGFuZGxlKGN1cnNvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0OiBmaXJzdFRva2VuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZDogZW5kSGFuZGxlICYmIGVuZEhhbmRsZS5mcm9tIDwgZW5kSGFuZGxlLnRvID8geyBmcm9tOiBlbmRIYW5kbGUuZnJvbSwgdG86IGVuZEhhbmRsZS50byB9IDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWQ6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlcHRoLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChkaXIgPCAwID8gY3Vyc29yLnByZXZTaWJsaW5nKCkgOiBjdXJzb3IubmV4dFNpYmxpbmcoKSk7XG4gICAgcmV0dXJuIHsgc3RhcnQ6IGZpcnN0VG9rZW4sIG1hdGNoZWQ6IGZhbHNlIH07XG59XG5mdW5jdGlvbiBtYXRjaFBsYWluQnJhY2tldHMoc3RhdGUsIHBvcywgZGlyLCB0cmVlLCB0b2tlblR5cGUsIG1heFNjYW5EaXN0YW5jZSwgYnJhY2tldHMpIHtcbiAgICBsZXQgc3RhcnRDaCA9IGRpciA8IDAgPyBzdGF0ZS5zbGljZURvYyhwb3MgLSAxLCBwb3MpIDogc3RhdGUuc2xpY2VEb2MocG9zLCBwb3MgKyAxKTtcbiAgICBsZXQgYnJhY2tldCA9IGJyYWNrZXRzLmluZGV4T2Yoc3RhcnRDaCk7XG4gICAgaWYgKGJyYWNrZXQgPCAwIHx8IChicmFja2V0ICUgMiA9PSAwKSAhPSAoZGlyID4gMCkpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGxldCBzdGFydFRva2VuID0geyBmcm9tOiBkaXIgPCAwID8gcG9zIC0gMSA6IHBvcywgdG86IGRpciA+IDAgPyBwb3MgKyAxIDogcG9zIH07XG4gICAgbGV0IGl0ZXIgPSBzdGF0ZS5kb2MuaXRlclJhbmdlKHBvcywgZGlyID4gMCA/IHN0YXRlLmRvYy5sZW5ndGggOiAwKSwgZGVwdGggPSAwO1xuICAgIGZvciAobGV0IGRpc3RhbmNlID0gMDsgIShpdGVyLm5leHQoKSkuZG9uZSAmJiBkaXN0YW5jZSA8PSBtYXhTY2FuRGlzdGFuY2U7KSB7XG4gICAgICAgIGxldCB0ZXh0ID0gaXRlci52YWx1ZTtcbiAgICAgICAgaWYgKGRpciA8IDApXG4gICAgICAgICAgICBkaXN0YW5jZSArPSB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgbGV0IGJhc2VQb3MgPSBwb3MgKyBkaXN0YW5jZSAqIGRpcjtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gZGlyID4gMCA/IDAgOiB0ZXh0Lmxlbmd0aCAtIDEsIGVuZCA9IGRpciA+IDAgPyB0ZXh0Lmxlbmd0aCA6IC0xOyBwb3MgIT0gZW5kOyBwb3MgKz0gZGlyKSB7XG4gICAgICAgICAgICBsZXQgZm91bmQgPSBicmFja2V0cy5pbmRleE9mKHRleHRbcG9zXSk7XG4gICAgICAgICAgICBpZiAoZm91bmQgPCAwIHx8IHRyZWUucmVzb2x2ZUlubmVyKGJhc2VQb3MgKyBwb3MsIDEpLnR5cGUgIT0gdG9rZW5UeXBlKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKChmb3VuZCAlIDIgPT0gMCkgPT0gKGRpciA+IDApKSB7XG4gICAgICAgICAgICAgICAgZGVwdGgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGRlcHRoID09IDEpIHsgLy8gQ2xvc2luZ1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHN0YXJ0OiBzdGFydFRva2VuLCBlbmQ6IHsgZnJvbTogYmFzZVBvcyArIHBvcywgdG86IGJhc2VQb3MgKyBwb3MgKyAxIH0sIG1hdGNoZWQ6IChmb3VuZCA+PiAxKSA9PSAoYnJhY2tldCA+PiAxKSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVwdGgtLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlyID4gMClcbiAgICAgICAgICAgIGRpc3RhbmNlICs9IHRleHQubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gaXRlci5kb25lID8geyBzdGFydDogc3RhcnRUb2tlbiwgbWF0Y2hlZDogZmFsc2UgfSA6IG51bGw7XG59XG5cbi8vIENvdW50cyB0aGUgY29sdW1uIG9mZnNldCBpbiBhIHN0cmluZywgdGFraW5nIHRhYnMgaW50byBhY2NvdW50LlxuLy8gVXNlZCBtb3N0bHkgdG8gZmluZCBpbmRlbnRhdGlvbi5cbmZ1bmN0aW9uIGNvdW50Q29sKHN0cmluZywgZW5kLCB0YWJTaXplLCBzdGFydEluZGV4ID0gMCwgc3RhcnRWYWx1ZSA9IDApIHtcbiAgICBpZiAoZW5kID09IG51bGwpIHtcbiAgICAgICAgZW5kID0gc3RyaW5nLnNlYXJjaCgvW15cXHNcXHUwMGEwXS8pO1xuICAgICAgICBpZiAoZW5kID09IC0xKVxuICAgICAgICAgICAgZW5kID0gc3RyaW5nLmxlbmd0aDtcbiAgICB9XG4gICAgbGV0IG4gPSBzdGFydFZhbHVlO1xuICAgIGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpIDwgZW5kOyBpKyspIHtcbiAgICAgICAgaWYgKHN0cmluZy5jaGFyQ29kZUF0KGkpID09IDkpXG4gICAgICAgICAgICBuICs9IHRhYlNpemUgLSAobiAlIHRhYlNpemUpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBuKys7XG4gICAgfVxuICAgIHJldHVybiBuO1xufVxuLyoqXG5FbmNhcHN1bGF0ZXMgYSBzaW5nbGUgbGluZSBvZiBpbnB1dC4gR2l2ZW4gdG8gc3RyZWFtIHN5bnRheCBjb2RlLFxud2hpY2ggdXNlcyBpdCB0byB0b2tlbml6ZSB0aGUgY29udGVudC5cbiovXG5jbGFzcyBTdHJpbmdTdHJlYW0ge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHN0cmVhbS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBsaW5lLlxuICAgICovXG4gICAgc3RyaW5nLCB0YWJTaXplLCBcbiAgICAvKipcbiAgICBUaGUgY3VycmVudCBpbmRlbnQgdW5pdCBzaXplLlxuICAgICovXG4gICAgaW5kZW50VW5pdCwgb3ZlcnJpZGVJbmRlbnQpIHtcbiAgICAgICAgdGhpcy5zdHJpbmcgPSBzdHJpbmc7XG4gICAgICAgIHRoaXMudGFiU2l6ZSA9IHRhYlNpemU7XG4gICAgICAgIHRoaXMuaW5kZW50VW5pdCA9IGluZGVudFVuaXQ7XG4gICAgICAgIHRoaXMub3ZlcnJpZGVJbmRlbnQgPSBvdmVycmlkZUluZGVudDtcbiAgICAgICAgLyoqXG4gICAgICAgIFRoZSBjdXJyZW50IHBvc2l0aW9uIG9uIHRoZSBsaW5lLlxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIC8qKlxuICAgICAgICBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIGN1cnJlbnQgdG9rZW4uXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhcnQgPSAwO1xuICAgICAgICB0aGlzLmxhc3RDb2x1bW5Qb3MgPSAwO1xuICAgICAgICB0aGlzLmxhc3RDb2x1bW5WYWx1ZSA9IDA7XG4gICAgfVxuICAgIC8qKlxuICAgIFRydWUgaWYgd2UgYXJlIGF0IHRoZSBlbmQgb2YgdGhlIGxpbmUuXG4gICAgKi9cbiAgICBlb2woKSB7IHJldHVybiB0aGlzLnBvcyA+PSB0aGlzLnN0cmluZy5sZW5ndGg7IH1cbiAgICAvKipcbiAgICBUcnVlIGlmIHdlIGFyZSBhdCB0aGUgc3RhcnQgb2YgdGhlIGxpbmUuXG4gICAgKi9cbiAgICBzb2woKSB7IHJldHVybiB0aGlzLnBvcyA9PSAwOyB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBuZXh0IGNvZGUgdW5pdCBhZnRlciB0aGUgY3VycmVudCBwb3NpdGlvbiwgb3IgdW5kZWZpbmVkXG4gICAgaWYgd2UncmUgYXQgdGhlIGVuZCBvZiB0aGUgbGluZS5cbiAgICAqL1xuICAgIHBlZWsoKSB7IHJldHVybiB0aGlzLnN0cmluZy5jaGFyQXQodGhpcy5wb3MpIHx8IHVuZGVmaW5lZDsgfVxuICAgIC8qKlxuICAgIFJlYWQgdGhlIG5leHQgY29kZSB1bml0IGFuZCBhZHZhbmNlIGB0aGlzLnBvc2AuXG4gICAgKi9cbiAgICBuZXh0KCkge1xuICAgICAgICBpZiAodGhpcy5wb3MgPCB0aGlzLnN0cmluZy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zdHJpbmcuY2hhckF0KHRoaXMucG9zKyspO1xuICAgIH1cbiAgICAvKipcbiAgICBNYXRjaCB0aGUgbmV4dCBjaGFyYWN0ZXIgYWdhaW5zdCB0aGUgZ2l2ZW4gc3RyaW5nLCByZWd1bGFyXG4gICAgZXhwcmVzc2lvbiwgb3IgcHJlZGljYXRlLiBDb25zdW1lIGFuZCByZXR1cm4gaXQgaWYgaXQgbWF0Y2hlcy5cbiAgICAqL1xuICAgIGVhdChtYXRjaCkge1xuICAgICAgICBsZXQgY2ggPSB0aGlzLnN0cmluZy5jaGFyQXQodGhpcy5wb3MpO1xuICAgICAgICBsZXQgb2s7XG4gICAgICAgIGlmICh0eXBlb2YgbWF0Y2ggPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIG9rID0gY2ggPT0gbWF0Y2g7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIG9rID0gY2ggJiYgKG1hdGNoIGluc3RhbmNlb2YgUmVnRXhwID8gbWF0Y2gudGVzdChjaCkgOiBtYXRjaChjaCkpO1xuICAgICAgICBpZiAob2spIHtcbiAgICAgICAgICAgICsrdGhpcy5wb3M7XG4gICAgICAgICAgICByZXR1cm4gY2g7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgQ29udGludWUgbWF0Y2hpbmcgY2hhcmFjdGVycyB0aGF0IG1hdGNoIHRoZSBnaXZlbiBzdHJpbmcsXG4gICAgcmVndWxhciBleHByZXNzaW9uLCBvciBwcmVkaWNhdGUgZnVuY3Rpb24uIFJldHVybiB0cnVlIGlmIGFueVxuICAgIGNoYXJhY3RlcnMgd2VyZSBjb25zdW1lZC5cbiAgICAqL1xuICAgIGVhdFdoaWxlKG1hdGNoKSB7XG4gICAgICAgIGxldCBzdGFydCA9IHRoaXMucG9zO1xuICAgICAgICB3aGlsZSAodGhpcy5lYXQobWF0Y2gpKSB7IH1cbiAgICAgICAgcmV0dXJuIHRoaXMucG9zID4gc3RhcnQ7XG4gICAgfVxuICAgIC8qKlxuICAgIENvbnN1bWUgd2hpdGVzcGFjZSBhaGVhZCBvZiBgdGhpcy5wb3NgLiBSZXR1cm4gdHJ1ZSBpZiBhbnkgd2FzXG4gICAgZm91bmQuXG4gICAgKi9cbiAgICBlYXRTcGFjZSgpIHtcbiAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5wb3M7XG4gICAgICAgIHdoaWxlICgvW1xcc1xcdTAwYTBdLy50ZXN0KHRoaXMuc3RyaW5nLmNoYXJBdCh0aGlzLnBvcykpKVxuICAgICAgICAgICAgKyt0aGlzLnBvcztcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zID4gc3RhcnQ7XG4gICAgfVxuICAgIC8qKlxuICAgIE1vdmUgdG8gdGhlIGVuZCBvZiB0aGUgbGluZS5cbiAgICAqL1xuICAgIHNraXBUb0VuZCgpIHsgdGhpcy5wb3MgPSB0aGlzLnN0cmluZy5sZW5ndGg7IH1cbiAgICAvKipcbiAgICBNb3ZlIHRvIGRpcmVjdGx5IGJlZm9yZSB0aGUgZ2l2ZW4gY2hhcmFjdGVyLCBpZiBmb3VuZCBvbiB0aGVcbiAgICBjdXJyZW50IGxpbmUuXG4gICAgKi9cbiAgICBza2lwVG8oY2gpIHtcbiAgICAgICAgbGV0IGZvdW5kID0gdGhpcy5zdHJpbmcuaW5kZXhPZihjaCwgdGhpcy5wb3MpO1xuICAgICAgICBpZiAoZm91bmQgPiAtMSkge1xuICAgICAgICAgICAgdGhpcy5wb3MgPSBmb3VuZDtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIE1vdmUgYmFjayBgbmAgY2hhcmFjdGVycy5cbiAgICAqL1xuICAgIGJhY2tVcChuKSB7IHRoaXMucG9zIC09IG47IH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGNvbHVtbiBwb3NpdGlvbiBhdCBgdGhpcy5wb3NgLlxuICAgICovXG4gICAgY29sdW1uKCkge1xuICAgICAgICBpZiAodGhpcy5sYXN0Q29sdW1uUG9zIDwgdGhpcy5zdGFydCkge1xuICAgICAgICAgICAgdGhpcy5sYXN0Q29sdW1uVmFsdWUgPSBjb3VudENvbCh0aGlzLnN0cmluZywgdGhpcy5zdGFydCwgdGhpcy50YWJTaXplLCB0aGlzLmxhc3RDb2x1bW5Qb3MsIHRoaXMubGFzdENvbHVtblZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMubGFzdENvbHVtblBvcyA9IHRoaXMuc3RhcnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdENvbHVtblZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIGluZGVudGF0aW9uIGNvbHVtbiBvZiB0aGUgY3VycmVudCBsaW5lLlxuICAgICovXG4gICAgaW5kZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMub3ZlcnJpZGVJbmRlbnQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNvdW50Q29sKHRoaXMuc3RyaW5nLCBudWxsLCB0aGlzLnRhYlNpemUpO1xuICAgIH1cbiAgICAvKipcbiAgICBNYXRjaCB0aGUgaW5wdXQgYWdhaW5zdCB0aGUgZ2l2ZW4gc3RyaW5nIG9yIHJlZ3VsYXIgZXhwcmVzc2lvblxuICAgICh3aGljaCBzaG91bGQgc3RhcnQgd2l0aCBhIGBeYCkuIFJldHVybiB0cnVlIG9yIHRoZSByZWdleHAgbWF0Y2hcbiAgICBpZiBpdCBtYXRjaGVzLlxuICAgIFxuICAgIFVubGVzcyBgY29uc3VtZWAgaXMgc2V0IHRvIGBmYWxzZWAsIHRoaXMgd2lsbCBtb3ZlIGB0aGlzLnBvc2BcbiAgICBwYXN0IHRoZSBtYXRjaGVkIHRleHQuXG4gICAgXG4gICAgV2hlbiBtYXRjaGluZyBhIHN0cmluZyBgY2FzZUluc2Vuc2l0aXZlYCBjYW4gYmUgc2V0IHRvIHRydWUgdG9cbiAgICBtYWtlIHRoZSBtYXRjaCBjYXNlLWluc2Vuc2l0aXZlLlxuICAgICovXG4gICAgbWF0Y2gocGF0dGVybiwgY29uc3VtZSwgY2FzZUluc2Vuc2l0aXZlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcGF0dGVybiA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBsZXQgY2FzZWQgPSAoc3RyKSA9PiBjYXNlSW5zZW5zaXRpdmUgPyBzdHIudG9Mb3dlckNhc2UoKSA6IHN0cjtcbiAgICAgICAgICAgIGxldCBzdWJzdHIgPSB0aGlzLnN0cmluZy5zdWJzdHIodGhpcy5wb3MsIHBhdHRlcm4ubGVuZ3RoKTtcbiAgICAgICAgICAgIGlmIChjYXNlZChzdWJzdHIpID09IGNhc2VkKHBhdHRlcm4pKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnN1bWUgIT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvcyArPSBwYXR0ZXJuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBtYXRjaCA9IHRoaXMuc3RyaW5nLnNsaWNlKHRoaXMucG9zKS5tYXRjaChwYXR0ZXJuKTtcbiAgICAgICAgICAgIGlmIChtYXRjaCAmJiBtYXRjaC5pbmRleCA+IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBpZiAobWF0Y2ggJiYgY29uc3VtZSAhPT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgKz0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgY3VycmVudCB0b2tlbi5cbiAgICAqL1xuICAgIGN1cnJlbnQoKSB7IHJldHVybiB0aGlzLnN0cmluZy5zbGljZSh0aGlzLnN0YXJ0LCB0aGlzLnBvcyk7IH1cbn1cblxuZnVuY3Rpb24gZnVsbFBhcnNlcihzcGVjKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogc3BlYy5uYW1lIHx8IFwiXCIsXG4gICAgICAgIHRva2VuOiBzcGVjLnRva2VuLFxuICAgICAgICBibGFua0xpbmU6IHNwZWMuYmxhbmtMaW5lIHx8ICgoKSA9PiB7IH0pLFxuICAgICAgICBzdGFydFN0YXRlOiBzcGVjLnN0YXJ0U3RhdGUgfHwgKCgpID0+IHRydWUpLFxuICAgICAgICBjb3B5U3RhdGU6IHNwZWMuY29weVN0YXRlIHx8IGRlZmF1bHRDb3B5U3RhdGUsXG4gICAgICAgIGluZGVudDogc3BlYy5pbmRlbnQgfHwgKCgpID0+IG51bGwpLFxuICAgICAgICBsYW5ndWFnZURhdGE6IHNwZWMubGFuZ3VhZ2VEYXRhIHx8IHt9LFxuICAgICAgICB0b2tlblRhYmxlOiBzcGVjLnRva2VuVGFibGUgfHwgbm9Ub2tlbnNcbiAgICB9O1xufVxuZnVuY3Rpb24gZGVmYXVsdENvcHlTdGF0ZShzdGF0ZSkge1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgIT0gXCJvYmplY3RcIilcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIGxldCBuZXdTdGF0ZSA9IHt9O1xuICAgIGZvciAobGV0IHByb3AgaW4gc3RhdGUpIHtcbiAgICAgICAgbGV0IHZhbCA9IHN0YXRlW3Byb3BdO1xuICAgICAgICBuZXdTdGF0ZVtwcm9wXSA9ICh2YWwgaW5zdGFuY2VvZiBBcnJheSA/IHZhbC5zbGljZSgpIDogdmFsKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld1N0YXRlO1xufVxuY29uc3QgSW5kZW50ZWRGcm9tID0gLypAX19QVVJFX18qL25ldyBXZWFrTWFwKCk7XG4vKipcbkEgW2xhbmd1YWdlXShodHRwczovL2NvZGVtaXJyb3IubmV0LzYvZG9jcy9yZWYvI2xhbmd1YWdlLkxhbmd1YWdlKSBjbGFzcyBiYXNlZCBvbiBhIENvZGVNaXJyb3JcbjUtc3R5bGUgW3N0cmVhbWluZyBwYXJzZXJdKGh0dHBzOi8vY29kZW1pcnJvci5uZXQvNi9kb2NzL3JlZi8jbGFuZ3VhZ2UuU3RyZWFtUGFyc2VyKS5cbiovXG5jbGFzcyBTdHJlYW1MYW5ndWFnZSBleHRlbmRzIExhbmd1YWdlIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIpIHtcbiAgICAgICAgbGV0IGRhdGEgPSBkZWZpbmVMYW5ndWFnZUZhY2V0KHBhcnNlci5sYW5ndWFnZURhdGEpO1xuICAgICAgICBsZXQgcCA9IGZ1bGxQYXJzZXIocGFyc2VyKSwgc2VsZjtcbiAgICAgICAgbGV0IGltcGwgPSBuZXcgY2xhc3MgZXh0ZW5kcyBQYXJzZXIge1xuICAgICAgICAgICAgY3JlYXRlUGFyc2UoaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQYXJzZShzZWxmLCBpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBzdXBlcihkYXRhLCBpbXBsLCBbaW5kZW50U2VydmljZS5vZigoY3gsIHBvcykgPT4gdGhpcy5nZXRJbmRlbnQoY3gsIHBvcykpXSwgcGFyc2VyLm5hbWUpO1xuICAgICAgICB0aGlzLnRvcE5vZGUgPSBkb2NJRChkYXRhKTtcbiAgICAgICAgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMuc3RyZWFtUGFyc2VyID0gcDtcbiAgICAgICAgdGhpcy5zdGF0ZUFmdGVyID0gbmV3IE5vZGVQcm9wKHsgcGVyTm9kZTogdHJ1ZSB9KTtcbiAgICAgICAgdGhpcy50b2tlblRhYmxlID0gcGFyc2VyLnRva2VuVGFibGUgPyBuZXcgVG9rZW5UYWJsZShwLnRva2VuVGFibGUpIDogZGVmYXVsdFRva2VuVGFibGU7XG4gICAgfVxuICAgIC8qKlxuICAgIERlZmluZSBhIHN0cmVhbSBsYW5ndWFnZS5cbiAgICAqL1xuICAgIHN0YXRpYyBkZWZpbmUoc3BlYykgeyByZXR1cm4gbmV3IFN0cmVhbUxhbmd1YWdlKHNwZWMpOyB9XG4gICAgZ2V0SW5kZW50KGN4LCBwb3MpIHtcbiAgICAgICAgbGV0IHRyZWUgPSBzeW50YXhUcmVlKGN4LnN0YXRlKSwgYXQgPSB0cmVlLnJlc29sdmUocG9zKTtcbiAgICAgICAgd2hpbGUgKGF0ICYmIGF0LnR5cGUgIT0gdGhpcy50b3BOb2RlKVxuICAgICAgICAgICAgYXQgPSBhdC5wYXJlbnQ7XG4gICAgICAgIGlmICghYXQpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgbGV0IGZyb20gPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCB7IG92ZXJyaWRlSW5kZW50YXRpb24gfSA9IGN4Lm9wdGlvbnM7XG4gICAgICAgIGlmIChvdmVycmlkZUluZGVudGF0aW9uKSB7XG4gICAgICAgICAgICBmcm9tID0gSW5kZW50ZWRGcm9tLmdldChjeC5zdGF0ZSk7XG4gICAgICAgICAgICBpZiAoZnJvbSAhPSBudWxsICYmIGZyb20gPCBwb3MgLSAxZTQpXG4gICAgICAgICAgICAgICAgZnJvbSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhcnQgPSBmaW5kU3RhdGUodGhpcywgdHJlZSwgMCwgYXQuZnJvbSwgZnJvbSAhPT0gbnVsbCAmJiBmcm9tICE9PSB2b2lkIDAgPyBmcm9tIDogcG9zKSwgc3RhdGVQb3MsIHN0YXRlO1xuICAgICAgICBpZiAoc3RhcnQpIHtcbiAgICAgICAgICAgIHN0YXRlID0gc3RhcnQuc3RhdGU7XG4gICAgICAgICAgICBzdGF0ZVBvcyA9IHN0YXJ0LnBvcyArIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdGF0ZSA9IHRoaXMuc3RyZWFtUGFyc2VyLnN0YXJ0U3RhdGUoY3gudW5pdCk7XG4gICAgICAgICAgICBzdGF0ZVBvcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvcyAtIHN0YXRlUG9zID4gMTAwMDAgLyogQy5NYXhJbmRlbnRTY2FuRGlzdCAqLylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB3aGlsZSAoc3RhdGVQb3MgPCBwb3MpIHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gY3guc3RhdGUuZG9jLmxpbmVBdChzdGF0ZVBvcyksIGVuZCA9IE1hdGgubWluKHBvcywgbGluZS50byk7XG4gICAgICAgICAgICBpZiAobGluZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsZXQgaW5kZW50YXRpb24gPSBvdmVycmlkZUluZGVudGF0aW9uID8gb3ZlcnJpZGVJbmRlbnRhdGlvbihsaW5lLmZyb20pIDogLTE7XG4gICAgICAgICAgICAgICAgbGV0IHN0cmVhbSA9IG5ldyBTdHJpbmdTdHJlYW0obGluZS50ZXh0LCBjeC5zdGF0ZS50YWJTaXplLCBjeC51bml0LCBpbmRlbnRhdGlvbiA8IDAgPyB1bmRlZmluZWQgOiBpbmRlbnRhdGlvbik7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHN0cmVhbS5wb3MgPCBlbmQgLSBsaW5lLmZyb20pXG4gICAgICAgICAgICAgICAgICAgIHJlYWRUb2tlbih0aGlzLnN0cmVhbVBhcnNlci50b2tlbiwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbVBhcnNlci5ibGFua0xpbmUoc3RhdGUsIGN4LnVuaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVuZCA9PSBwb3MpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBzdGF0ZVBvcyA9IGxpbmUudG8gKyAxO1xuICAgICAgICB9XG4gICAgICAgIGxldCBsaW5lID0gY3gubGluZUF0KHBvcyk7XG4gICAgICAgIGlmIChvdmVycmlkZUluZGVudGF0aW9uICYmIGZyb20gPT0gbnVsbClcbiAgICAgICAgICAgIEluZGVudGVkRnJvbS5zZXQoY3guc3RhdGUsIGxpbmUuZnJvbSk7XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmVhbVBhcnNlci5pbmRlbnQoc3RhdGUsIC9eXFxzKiguKikvLmV4ZWMobGluZS50ZXh0KVsxXSwgY3gpO1xuICAgIH1cbiAgICBnZXQgYWxsb3dzTmVzdGluZygpIHsgcmV0dXJuIGZhbHNlOyB9XG59XG5mdW5jdGlvbiBmaW5kU3RhdGUobGFuZywgdHJlZSwgb2ZmLCBzdGFydFBvcywgYmVmb3JlKSB7XG4gICAgbGV0IHN0YXRlID0gb2ZmID49IHN0YXJ0UG9zICYmIG9mZiArIHRyZWUubGVuZ3RoIDw9IGJlZm9yZSAmJiB0cmVlLnByb3AobGFuZy5zdGF0ZUFmdGVyKTtcbiAgICBpZiAoc3RhdGUpXG4gICAgICAgIHJldHVybiB7IHN0YXRlOiBsYW5nLnN0cmVhbVBhcnNlci5jb3B5U3RhdGUoc3RhdGUpLCBwb3M6IG9mZiArIHRyZWUubGVuZ3RoIH07XG4gICAgZm9yIChsZXQgaSA9IHRyZWUuY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgbGV0IGNoaWxkID0gdHJlZS5jaGlsZHJlbltpXSwgcG9zID0gb2ZmICsgdHJlZS5wb3NpdGlvbnNbaV07XG4gICAgICAgIGxldCBmb3VuZCA9IGNoaWxkIGluc3RhbmNlb2YgVHJlZSAmJiBwb3MgPCBiZWZvcmUgJiYgZmluZFN0YXRlKGxhbmcsIGNoaWxkLCBwb3MsIHN0YXJ0UG9zLCBiZWZvcmUpO1xuICAgICAgICBpZiAoZm91bmQpXG4gICAgICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gY3V0VHJlZShsYW5nLCB0cmVlLCBmcm9tLCB0bywgaW5zaWRlKSB7XG4gICAgaWYgKGluc2lkZSAmJiBmcm9tIDw9IDAgJiYgdG8gPj0gdHJlZS5sZW5ndGgpXG4gICAgICAgIHJldHVybiB0cmVlO1xuICAgIGlmICghaW5zaWRlICYmIHRyZWUudHlwZSA9PSBsYW5nLnRvcE5vZGUpXG4gICAgICAgIGluc2lkZSA9IHRydWU7XG4gICAgZm9yIChsZXQgaSA9IHRyZWUuY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgbGV0IHBvcyA9IHRyZWUucG9zaXRpb25zW2ldLCBjaGlsZCA9IHRyZWUuY2hpbGRyZW5baV0sIGlubmVyO1xuICAgICAgICBpZiAocG9zIDwgdG8gJiYgY2hpbGQgaW5zdGFuY2VvZiBUcmVlKSB7XG4gICAgICAgICAgICBpZiAoIShpbm5lciA9IGN1dFRyZWUobGFuZywgY2hpbGQsIGZyb20gLSBwb3MsIHRvIC0gcG9zLCBpbnNpZGUpKSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHJldHVybiAhaW5zaWRlID8gaW5uZXJcbiAgICAgICAgICAgICAgICA6IG5ldyBUcmVlKHRyZWUudHlwZSwgdHJlZS5jaGlsZHJlbi5zbGljZSgwLCBpKS5jb25jYXQoaW5uZXIpLCB0cmVlLnBvc2l0aW9ucy5zbGljZSgwLCBpICsgMSksIHBvcyArIGlubmVyLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBmaW5kU3RhcnRJbkZyYWdtZW50cyhsYW5nLCBmcmFnbWVudHMsIHN0YXJ0UG9zLCBlZGl0b3JTdGF0ZSkge1xuICAgIGZvciAobGV0IGYgb2YgZnJhZ21lbnRzKSB7XG4gICAgICAgIGxldCBmcm9tID0gZi5mcm9tICsgKGYub3BlblN0YXJ0ID8gMjUgOiAwKSwgdG8gPSBmLnRvIC0gKGYub3BlbkVuZCA/IDI1IDogMCk7XG4gICAgICAgIGxldCBmb3VuZCA9IGZyb20gPD0gc3RhcnRQb3MgJiYgdG8gPiBzdGFydFBvcyAmJiBmaW5kU3RhdGUobGFuZywgZi50cmVlLCAwIC0gZi5vZmZzZXQsIHN0YXJ0UG9zLCB0byksIHRyZWU7XG4gICAgICAgIGlmIChmb3VuZCAmJiAodHJlZSA9IGN1dFRyZWUobGFuZywgZi50cmVlLCBzdGFydFBvcyArIGYub2Zmc2V0LCBmb3VuZC5wb3MgKyBmLm9mZnNldCwgZmFsc2UpKSlcbiAgICAgICAgICAgIHJldHVybiB7IHN0YXRlOiBmb3VuZC5zdGF0ZSwgdHJlZSB9O1xuICAgIH1cbiAgICByZXR1cm4geyBzdGF0ZTogbGFuZy5zdHJlYW1QYXJzZXIuc3RhcnRTdGF0ZShlZGl0b3JTdGF0ZSA/IGdldEluZGVudFVuaXQoZWRpdG9yU3RhdGUpIDogNCksIHRyZWU6IFRyZWUuZW1wdHkgfTtcbn1cbmNsYXNzIFBhcnNlIHtcbiAgICBjb25zdHJ1Y3RvcihsYW5nLCBpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpIHtcbiAgICAgICAgdGhpcy5sYW5nID0gbGFuZztcbiAgICAgICAgdGhpcy5pbnB1dCA9IGlucHV0O1xuICAgICAgICB0aGlzLmZyYWdtZW50cyA9IGZyYWdtZW50cztcbiAgICAgICAgdGhpcy5yYW5nZXMgPSByYW5nZXM7XG4gICAgICAgIHRoaXMuc3RvcHBlZEF0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5jaHVua3MgPSBbXTtcbiAgICAgICAgdGhpcy5jaHVua1BvcyA9IFtdO1xuICAgICAgICB0aGlzLmNodW5rID0gW107XG4gICAgICAgIHRoaXMuY2h1bmtSZXVzZWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucmFuZ2VJbmRleCA9IDA7XG4gICAgICAgIHRoaXMudG8gPSByYW5nZXNbcmFuZ2VzLmxlbmd0aCAtIDFdLnRvO1xuICAgICAgICBsZXQgY29udGV4dCA9IFBhcnNlQ29udGV4dC5nZXQoKSwgZnJvbSA9IHJhbmdlc1swXS5mcm9tO1xuICAgICAgICBsZXQgeyBzdGF0ZSwgdHJlZSB9ID0gZmluZFN0YXJ0SW5GcmFnbWVudHMobGFuZywgZnJhZ21lbnRzLCBmcm9tLCBjb250ZXh0ID09PSBudWxsIHx8IGNvbnRleHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbnRleHQuc3RhdGUpO1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHRoaXMucGFyc2VkUG9zID0gdGhpcy5jaHVua1N0YXJ0ID0gZnJvbSArIHRyZWUubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRyZWUuY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuY2h1bmtzLnB1c2godHJlZS5jaGlsZHJlbltpXSk7XG4gICAgICAgICAgICB0aGlzLmNodW5rUG9zLnB1c2godHJlZS5wb3NpdGlvbnNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb250ZXh0ICYmIHRoaXMucGFyc2VkUG9zIDwgY29udGV4dC52aWV3cG9ydC5mcm9tIC0gMTAwMDAwIC8qIEMuTWF4RGlzdGFuY2VCZWZvcmVWaWV3cG9ydCAqLykge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IHRoaXMubGFuZy5zdHJlYW1QYXJzZXIuc3RhcnRTdGF0ZShnZXRJbmRlbnRVbml0KGNvbnRleHQuc3RhdGUpKTtcbiAgICAgICAgICAgIGNvbnRleHQuc2tpcFVudGlsSW5WaWV3KHRoaXMucGFyc2VkUG9zLCBjb250ZXh0LnZpZXdwb3J0LmZyb20pO1xuICAgICAgICAgICAgdGhpcy5wYXJzZWRQb3MgPSBjb250ZXh0LnZpZXdwb3J0LmZyb207XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb3ZlUmFuZ2VJbmRleCgpO1xuICAgIH1cbiAgICBhZHZhbmNlKCkge1xuICAgICAgICBsZXQgY29udGV4dCA9IFBhcnNlQ29udGV4dC5nZXQoKTtcbiAgICAgICAgbGV0IHBhcnNlRW5kID0gdGhpcy5zdG9wcGVkQXQgPT0gbnVsbCA/IHRoaXMudG8gOiBNYXRoLm1pbih0aGlzLnRvLCB0aGlzLnN0b3BwZWRBdCk7XG4gICAgICAgIGxldCBlbmQgPSBNYXRoLm1pbihwYXJzZUVuZCwgdGhpcy5jaHVua1N0YXJ0ICsgMjA0OCAvKiBDLkNodW5rU2l6ZSAqLyk7XG4gICAgICAgIGlmIChjb250ZXh0KVxuICAgICAgICAgICAgZW5kID0gTWF0aC5taW4oZW5kLCBjb250ZXh0LnZpZXdwb3J0LnRvKTtcbiAgICAgICAgd2hpbGUgKHRoaXMucGFyc2VkUG9zIDwgZW5kKVxuICAgICAgICAgICAgdGhpcy5wYXJzZUxpbmUoY29udGV4dCk7XG4gICAgICAgIGlmICh0aGlzLmNodW5rU3RhcnQgPCB0aGlzLnBhcnNlZFBvcylcbiAgICAgICAgICAgIHRoaXMuZmluaXNoQ2h1bmsoKTtcbiAgICAgICAgaWYgKHRoaXMucGFyc2VkUG9zID49IHBhcnNlRW5kKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmluaXNoKCk7XG4gICAgICAgIGlmIChjb250ZXh0ICYmIHRoaXMucGFyc2VkUG9zID49IGNvbnRleHQudmlld3BvcnQudG8pIHtcbiAgICAgICAgICAgIGNvbnRleHQuc2tpcFVudGlsSW5WaWV3KHRoaXMucGFyc2VkUG9zLCBwYXJzZUVuZCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maW5pc2goKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgc3RvcEF0KHBvcykge1xuICAgICAgICB0aGlzLnN0b3BwZWRBdCA9IHBvcztcbiAgICB9XG4gICAgbGluZUFmdGVyKHBvcykge1xuICAgICAgICBsZXQgY2h1bmsgPSB0aGlzLmlucHV0LmNodW5rKHBvcyk7XG4gICAgICAgIGlmICghdGhpcy5pbnB1dC5saW5lQ2h1bmtzKSB7XG4gICAgICAgICAgICBsZXQgZW9sID0gY2h1bmsuaW5kZXhPZihcIlxcblwiKTtcbiAgICAgICAgICAgIGlmIChlb2wgPiAtMSlcbiAgICAgICAgICAgICAgICBjaHVuayA9IGNodW5rLnNsaWNlKDAsIGVvbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2h1bmsgPT0gXCJcXG5cIikge1xuICAgICAgICAgICAgY2h1bmsgPSBcIlwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb3MgKyBjaHVuay5sZW5ndGggPD0gdGhpcy50byA/IGNodW5rIDogY2h1bmsuc2xpY2UoMCwgdGhpcy50byAtIHBvcyk7XG4gICAgfVxuICAgIG5leHRMaW5lKCkge1xuICAgICAgICBsZXQgZnJvbSA9IHRoaXMucGFyc2VkUG9zLCBsaW5lID0gdGhpcy5saW5lQWZ0ZXIoZnJvbSksIGVuZCA9IGZyb20gKyBsaW5lLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSB0aGlzLnJhbmdlSW5kZXg7Oykge1xuICAgICAgICAgICAgbGV0IHJhbmdlRW5kID0gdGhpcy5yYW5nZXNbaW5kZXhdLnRvO1xuICAgICAgICAgICAgaWYgKHJhbmdlRW5kID49IGVuZClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxpbmUgPSBsaW5lLnNsaWNlKDAsIHJhbmdlRW5kIC0gKGVuZCAtIGxpbmUubGVuZ3RoKSk7XG4gICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgaWYgKGluZGV4ID09IHRoaXMucmFuZ2VzLmxlbmd0aClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxldCByYW5nZVN0YXJ0ID0gdGhpcy5yYW5nZXNbaW5kZXhdLmZyb207XG4gICAgICAgICAgICBsZXQgYWZ0ZXIgPSB0aGlzLmxpbmVBZnRlcihyYW5nZVN0YXJ0KTtcbiAgICAgICAgICAgIGxpbmUgKz0gYWZ0ZXI7XG4gICAgICAgICAgICBlbmQgPSByYW5nZVN0YXJ0ICsgYWZ0ZXIubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGxpbmUsIGVuZCB9O1xuICAgIH1cbiAgICBza2lwR2Fwc1RvKHBvcywgb2Zmc2V0LCBzaWRlKSB7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBlbmQgPSB0aGlzLnJhbmdlc1t0aGlzLnJhbmdlSW5kZXhdLnRvLCBvZmZQb3MgPSBwb3MgKyBvZmZzZXQ7XG4gICAgICAgICAgICBpZiAoc2lkZSA+IDAgPyBlbmQgPiBvZmZQb3MgOiBlbmQgPj0gb2ZmUG9zKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gdGhpcy5yYW5nZXNbKyt0aGlzLnJhbmdlSW5kZXhdLmZyb207XG4gICAgICAgICAgICBvZmZzZXQgKz0gc3RhcnQgLSBlbmQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG4gICAgbW92ZVJhbmdlSW5kZXgoKSB7XG4gICAgICAgIHdoaWxlICh0aGlzLnJhbmdlc1t0aGlzLnJhbmdlSW5kZXhdLnRvIDwgdGhpcy5wYXJzZWRQb3MpXG4gICAgICAgICAgICB0aGlzLnJhbmdlSW5kZXgrKztcbiAgICB9XG4gICAgZW1pdFRva2VuKGlkLCBmcm9tLCB0bywgc2l6ZSwgb2Zmc2V0KSB7XG4gICAgICAgIGlmICh0aGlzLnJhbmdlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBvZmZzZXQgPSB0aGlzLnNraXBHYXBzVG8oZnJvbSwgb2Zmc2V0LCAxKTtcbiAgICAgICAgICAgIGZyb20gKz0gb2Zmc2V0O1xuICAgICAgICAgICAgbGV0IGxlbjAgPSB0aGlzLmNodW5rLmxlbmd0aDtcbiAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuc2tpcEdhcHNUbyh0bywgb2Zmc2V0LCAtMSk7XG4gICAgICAgICAgICB0byArPSBvZmZzZXQ7XG4gICAgICAgICAgICBzaXplICs9IHRoaXMuY2h1bmsubGVuZ3RoIC0gbGVuMDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNodW5rLnB1c2goaWQsIGZyb20sIHRvLCBzaXplKTtcbiAgICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG4gICAgcGFyc2VMaW5lKGNvbnRleHQpIHtcbiAgICAgICAgbGV0IHsgbGluZSwgZW5kIH0gPSB0aGlzLm5leHRMaW5lKCksIG9mZnNldCA9IDAsIHsgc3RyZWFtUGFyc2VyIH0gPSB0aGlzLmxhbmc7XG4gICAgICAgIGxldCBzdHJlYW0gPSBuZXcgU3RyaW5nU3RyZWFtKGxpbmUsIGNvbnRleHQgPyBjb250ZXh0LnN0YXRlLnRhYlNpemUgOiA0LCBjb250ZXh0ID8gZ2V0SW5kZW50VW5pdChjb250ZXh0LnN0YXRlKSA6IDIpO1xuICAgICAgICBpZiAoc3RyZWFtLmVvbCgpKSB7XG4gICAgICAgICAgICBzdHJlYW1QYXJzZXIuYmxhbmtMaW5lKHRoaXMuc3RhdGUsIHN0cmVhbS5pbmRlbnRVbml0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdoaWxlICghc3RyZWFtLmVvbCgpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRva2VuID0gcmVhZFRva2VuKHN0cmVhbVBhcnNlci50b2tlbiwgc3RyZWFtLCB0aGlzLnN0YXRlKTtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4pXG4gICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IHRoaXMuZW1pdFRva2VuKHRoaXMubGFuZy50b2tlblRhYmxlLnJlc29sdmUodG9rZW4pLCB0aGlzLnBhcnNlZFBvcyArIHN0cmVhbS5zdGFydCwgdGhpcy5wYXJzZWRQb3MgKyBzdHJlYW0ucG9zLCA0LCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIGlmIChzdHJlYW0uc3RhcnQgPiAxMDAwMCAvKiBDLk1heExpbmVMZW5ndGggKi8pXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucGFyc2VkUG9zID0gZW5kO1xuICAgICAgICB0aGlzLm1vdmVSYW5nZUluZGV4KCk7XG4gICAgICAgIGlmICh0aGlzLnBhcnNlZFBvcyA8IHRoaXMudG8pXG4gICAgICAgICAgICB0aGlzLnBhcnNlZFBvcysrO1xuICAgIH1cbiAgICBmaW5pc2hDaHVuaygpIHtcbiAgICAgICAgbGV0IHRyZWUgPSBUcmVlLmJ1aWxkKHtcbiAgICAgICAgICAgIGJ1ZmZlcjogdGhpcy5jaHVuayxcbiAgICAgICAgICAgIHN0YXJ0OiB0aGlzLmNodW5rU3RhcnQsXG4gICAgICAgICAgICBsZW5ndGg6IHRoaXMucGFyc2VkUG9zIC0gdGhpcy5jaHVua1N0YXJ0LFxuICAgICAgICAgICAgbm9kZVNldCxcbiAgICAgICAgICAgIHRvcElEOiAwLFxuICAgICAgICAgICAgbWF4QnVmZmVyTGVuZ3RoOiAyMDQ4IC8qIEMuQ2h1bmtTaXplICovLFxuICAgICAgICAgICAgcmV1c2VkOiB0aGlzLmNodW5rUmV1c2VkXG4gICAgICAgIH0pO1xuICAgICAgICB0cmVlID0gbmV3IFRyZWUodHJlZS50eXBlLCB0cmVlLmNoaWxkcmVuLCB0cmVlLnBvc2l0aW9ucywgdHJlZS5sZW5ndGgsIFtbdGhpcy5sYW5nLnN0YXRlQWZ0ZXIsIHRoaXMubGFuZy5zdHJlYW1QYXJzZXIuY29weVN0YXRlKHRoaXMuc3RhdGUpXV0pO1xuICAgICAgICB0aGlzLmNodW5rcy5wdXNoKHRyZWUpO1xuICAgICAgICB0aGlzLmNodW5rUG9zLnB1c2godGhpcy5jaHVua1N0YXJ0IC0gdGhpcy5yYW5nZXNbMF0uZnJvbSk7XG4gICAgICAgIHRoaXMuY2h1bmsgPSBbXTtcbiAgICAgICAgdGhpcy5jaHVua1JldXNlZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5jaHVua1N0YXJ0ID0gdGhpcy5wYXJzZWRQb3M7XG4gICAgfVxuICAgIGZpbmlzaCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlKHRoaXMubGFuZy50b3BOb2RlLCB0aGlzLmNodW5rcywgdGhpcy5jaHVua1BvcywgdGhpcy5wYXJzZWRQb3MgLSB0aGlzLnJhbmdlc1swXS5mcm9tKS5iYWxhbmNlKCk7XG4gICAgfVxufVxuZnVuY3Rpb24gcmVhZFRva2VuKHRva2VuLCBzdHJlYW0sIHN0YXRlKSB7XG4gICAgc3RyZWFtLnN0YXJ0ID0gc3RyZWFtLnBvcztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHRva2VuKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICBpZiAoc3RyZWFtLnBvcyA+IHN0cmVhbS5zdGFydClcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihcIlN0cmVhbSBwYXJzZXIgZmFpbGVkIHRvIGFkdmFuY2Ugc3RyZWFtLlwiKTtcbn1cbmNvbnN0IG5vVG9rZW5zID0gLypAX19QVVJFX18qL09iamVjdC5jcmVhdGUobnVsbCk7XG5jb25zdCB0eXBlQXJyYXkgPSBbTm9kZVR5cGUubm9uZV07XG5jb25zdCBub2RlU2V0ID0gLypAX19QVVJFX18qL25ldyBOb2RlU2V0KHR5cGVBcnJheSk7XG5jb25zdCB3YXJuZWQgPSBbXTtcbi8vIENhY2hlIG9mIG5vZGUgdHlwZXMgYnkgbmFtZSBhbmQgdGFnc1xuY29uc3QgYnlUYWcgPSAvKkBfX1BVUkVfXyovT2JqZWN0LmNyZWF0ZShudWxsKTtcbmNvbnN0IGRlZmF1bHRUYWJsZSA9IC8qQF9fUFVSRV9fKi9PYmplY3QuY3JlYXRlKG51bGwpO1xuZm9yIChsZXQgW2xlZ2FjeU5hbWUsIG5hbWVdIG9mIFtcbiAgICBbXCJ2YXJpYWJsZVwiLCBcInZhcmlhYmxlTmFtZVwiXSxcbiAgICBbXCJ2YXJpYWJsZS0yXCIsIFwidmFyaWFibGVOYW1lLnNwZWNpYWxcIl0sXG4gICAgW1wic3RyaW5nLTJcIiwgXCJzdHJpbmcuc3BlY2lhbFwiXSxcbiAgICBbXCJkZWZcIiwgXCJ2YXJpYWJsZU5hbWUuZGVmaW5pdGlvblwiXSxcbiAgICBbXCJ0YWdcIiwgXCJ0YWdOYW1lXCJdLFxuICAgIFtcImF0dHJpYnV0ZVwiLCBcImF0dHJpYnV0ZU5hbWVcIl0sXG4gICAgW1widHlwZVwiLCBcInR5cGVOYW1lXCJdLFxuICAgIFtcImJ1aWx0aW5cIiwgXCJ2YXJpYWJsZU5hbWUuc3RhbmRhcmRcIl0sXG4gICAgW1wicXVhbGlmaWVyXCIsIFwibW9kaWZpZXJcIl0sXG4gICAgW1wiZXJyb3JcIiwgXCJpbnZhbGlkXCJdLFxuICAgIFtcImhlYWRlclwiLCBcImhlYWRpbmdcIl0sXG4gICAgW1wicHJvcGVydHlcIiwgXCJwcm9wZXJ0eU5hbWVcIl1cbl0pXG4gICAgZGVmYXVsdFRhYmxlW2xlZ2FjeU5hbWVdID0gLypAX19QVVJFX18qL2NyZWF0ZVRva2VuVHlwZShub1Rva2VucywgbmFtZSk7XG5jbGFzcyBUb2tlblRhYmxlIHtcbiAgICBjb25zdHJ1Y3RvcihleHRyYSkge1xuICAgICAgICB0aGlzLmV4dHJhID0gZXh0cmE7XG4gICAgICAgIHRoaXMudGFibGUgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIGRlZmF1bHRUYWJsZSk7XG4gICAgfVxuICAgIHJlc29sdmUodGFnKSB7XG4gICAgICAgIHJldHVybiAhdGFnID8gMCA6IHRoaXMudGFibGVbdGFnXSB8fCAodGhpcy50YWJsZVt0YWddID0gY3JlYXRlVG9rZW5UeXBlKHRoaXMuZXh0cmEsIHRhZykpO1xuICAgIH1cbn1cbmNvbnN0IGRlZmF1bHRUb2tlblRhYmxlID0gLypAX19QVVJFX18qL25ldyBUb2tlblRhYmxlKG5vVG9rZW5zKTtcbmZ1bmN0aW9uIHdhcm5Gb3JQYXJ0KHBhcnQsIG1zZykge1xuICAgIGlmICh3YXJuZWQuaW5kZXhPZihwYXJ0KSA+IC0xKVxuICAgICAgICByZXR1cm47XG4gICAgd2FybmVkLnB1c2gocGFydCk7XG4gICAgY29uc29sZS53YXJuKG1zZyk7XG59XG5mdW5jdGlvbiBjcmVhdGVUb2tlblR5cGUoZXh0cmEsIHRhZ1N0cikge1xuICAgIGxldCB0YWdzJDEgPSBbXTtcbiAgICBmb3IgKGxldCBuYW1lIG9mIHRhZ1N0ci5zcGxpdChcIiBcIikpIHtcbiAgICAgICAgbGV0IGZvdW5kID0gW107XG4gICAgICAgIGZvciAobGV0IHBhcnQgb2YgbmFtZS5zcGxpdChcIi5cIikpIHtcbiAgICAgICAgICAgIGxldCB2YWx1ZSA9IChleHRyYVtwYXJ0XSB8fCB0YWdzW3BhcnRdKTtcbiAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB3YXJuRm9yUGFydChwYXJ0LCBgVW5rbm93biBoaWdobGlnaHRpbmcgdGFnICR7cGFydH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWZvdW5kLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgd2FybkZvclBhcnQocGFydCwgYE1vZGlmaWVyICR7cGFydH0gdXNlZCBhdCBzdGFydCBvZiB0YWdgKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGZvdW5kID0gZm91bmQubWFwKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHdhcm5Gb3JQYXJ0KHBhcnQsIGBUYWcgJHtwYXJ0fSB1c2VkIGFzIG1vZGlmaWVyYCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBmb3VuZCA9IEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IHRhZyBvZiBmb3VuZClcbiAgICAgICAgICAgIHRhZ3MkMS5wdXNoKHRhZyk7XG4gICAgfVxuICAgIGlmICghdGFncyQxLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgbGV0IG5hbWUgPSB0YWdTdHIucmVwbGFjZSgvIC9nLCBcIl9cIiksIGtleSA9IG5hbWUgKyBcIiBcIiArIHRhZ3MkMS5tYXAodCA9PiB0LmlkKTtcbiAgICBsZXQga25vd24gPSBieVRhZ1trZXldO1xuICAgIGlmIChrbm93bilcbiAgICAgICAgcmV0dXJuIGtub3duLmlkO1xuICAgIGxldCB0eXBlID0gYnlUYWdba2V5XSA9IE5vZGVUeXBlLmRlZmluZSh7XG4gICAgICAgIGlkOiB0eXBlQXJyYXkubGVuZ3RoLFxuICAgICAgICBuYW1lLFxuICAgICAgICBwcm9wczogW3N0eWxlVGFncyh7IFtuYW1lXTogdGFncyQxIH0pXVxuICAgIH0pO1xuICAgIHR5cGVBcnJheS5wdXNoKHR5cGUpO1xuICAgIHJldHVybiB0eXBlLmlkO1xufVxuZnVuY3Rpb24gZG9jSUQoZGF0YSkge1xuICAgIGxldCB0eXBlID0gTm9kZVR5cGUuZGVmaW5lKHsgaWQ6IHR5cGVBcnJheS5sZW5ndGgsIG5hbWU6IFwiRG9jdW1lbnRcIiwgcHJvcHM6IFtsYW5ndWFnZURhdGFQcm9wLmFkZCgoKSA9PiBkYXRhKV0sIHRvcDogdHJ1ZSB9KTtcbiAgICB0eXBlQXJyYXkucHVzaCh0eXBlKTtcbiAgICByZXR1cm4gdHlwZTtcbn1cblxuZnVuY3Rpb24gYnVpbGRGb3JMaW5lKGxpbmUpIHtcbiAgICByZXR1cm4gbGluZS5sZW5ndGggPD0gNDA5NiAmJiAvW1xcdTA1OTAtXFx1MDVmNFxcdTA2MDAtXFx1MDZmZlxcdTA3MDAtXFx1MDhhY1xcdWZiNTAtXFx1ZmRmZl0vLnRlc3QobGluZSk7XG59XG5mdW5jdGlvbiB0ZXh0SGFzUlRMKHRleHQpIHtcbiAgICBmb3IgKGxldCBpID0gdGV4dC5pdGVyKCk7ICFpLm5leHQoKS5kb25lOylcbiAgICAgICAgaWYgKGJ1aWxkRm9yTGluZShpLnZhbHVlKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNoYW5nZUFkZHNSVEwoY2hhbmdlKSB7XG4gICAgbGV0IGFkZGVkID0gZmFsc2U7XG4gICAgY2hhbmdlLml0ZXJDaGFuZ2VzKChmQSwgdEEsIGZCLCB0QiwgaW5zKSA9PiB7XG4gICAgICAgIGlmICghYWRkZWQgJiYgdGV4dEhhc1JUTChpbnMpKVxuICAgICAgICAgICAgYWRkZWQgPSB0cnVlO1xuICAgIH0pO1xuICAgIHJldHVybiBhZGRlZDtcbn1cbmNvbnN0IGFsd2F5c0lzb2xhdGUgPSAvKkBfX1BVUkVfXyovRmFjZXQuZGVmaW5lKHsgY29tYmluZTogdmFsdWVzID0+IHZhbHVlcy5zb21lKHggPT4geCkgfSk7XG4vKipcbk1ha2Ugc3VyZSBub2Rlc1xuW21hcmtlZF0oaHR0cHM6Ly9sZXplci5jb2RlbWlycm9yLm5ldC9kb2NzL3JlZi8jY29tbW9uLk5vZGVQcm9wXmlzb2xhdGUpXG5hcyBpc29sYXRpbmcgZm9yIGJpZGlyZWN0aW9uYWwgdGV4dCBhcmUgcmVuZGVyZWQgaW4gYSB3YXkgdGhhdFxuaXNvbGF0ZXMgdGhlbSBmcm9tIHRoZSBzdXJyb3VuZGluZyB0ZXh0LlxuKi9cbmZ1bmN0aW9uIGJpZGlJc29sYXRlcyhvcHRpb25zID0ge30pIHtcbiAgICBsZXQgZXh0ZW5zaW9ucyA9IFtpc29sYXRlTWFya3NdO1xuICAgIGlmIChvcHRpb25zLmFsd2F5c0lzb2xhdGUpXG4gICAgICAgIGV4dGVuc2lvbnMucHVzaChhbHdheXNJc29sYXRlLm9mKHRydWUpKTtcbiAgICByZXR1cm4gZXh0ZW5zaW9ucztcbn1cbmNvbnN0IGlzb2xhdGVNYXJrcyA9IC8qQF9fUFVSRV9fKi9WaWV3UGx1Z2luLmZyb21DbGFzcyhjbGFzcyB7XG4gICAgY29uc3RydWN0b3Iodmlldykge1xuICAgICAgICB0aGlzLmFsd2F5cyA9IHZpZXcuc3RhdGUuZmFjZXQoYWx3YXlzSXNvbGF0ZSkgfHxcbiAgICAgICAgICAgIHZpZXcudGV4dERpcmVjdGlvbiAhPSBEaXJlY3Rpb24uTFRSIHx8XG4gICAgICAgICAgICB2aWV3LnN0YXRlLmZhY2V0KEVkaXRvclZpZXcucGVyTGluZVRleHREaXJlY3Rpb24pO1xuICAgICAgICB0aGlzLmhhc1JUTCA9ICF0aGlzLmFsd2F5cyAmJiB0ZXh0SGFzUlRMKHZpZXcuc3RhdGUuZG9jKTtcbiAgICAgICAgdGhpcy50cmVlID0gc3ludGF4VHJlZSh2aWV3LnN0YXRlKTtcbiAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IHRoaXMuYWx3YXlzIHx8IHRoaXMuaGFzUlRMID8gYnVpbGREZWNvKHZpZXcsIHRoaXMudHJlZSwgdGhpcy5hbHdheXMpIDogRGVjb3JhdGlvbi5ub25lO1xuICAgIH1cbiAgICB1cGRhdGUodXBkYXRlKSB7XG4gICAgICAgIGxldCBhbHdheXMgPSB1cGRhdGUuc3RhdGUuZmFjZXQoYWx3YXlzSXNvbGF0ZSkgfHxcbiAgICAgICAgICAgIHVwZGF0ZS52aWV3LnRleHREaXJlY3Rpb24gIT0gRGlyZWN0aW9uLkxUUiB8fFxuICAgICAgICAgICAgdXBkYXRlLnN0YXRlLmZhY2V0KEVkaXRvclZpZXcucGVyTGluZVRleHREaXJlY3Rpb24pO1xuICAgICAgICBpZiAoIWFsd2F5cyAmJiAhdGhpcy5oYXNSVEwgJiYgY2hhbmdlQWRkc1JUTCh1cGRhdGUuY2hhbmdlcykpXG4gICAgICAgICAgICB0aGlzLmhhc1JUTCA9IHRydWU7XG4gICAgICAgIGlmICghYWx3YXlzICYmICF0aGlzLmhhc1JUTClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IHRyZWUgPSBzeW50YXhUcmVlKHVwZGF0ZS5zdGF0ZSk7XG4gICAgICAgIGlmIChhbHdheXMgIT0gdGhpcy5hbHdheXMgfHwgdHJlZSAhPSB0aGlzLnRyZWUgfHwgdXBkYXRlLmRvY0NoYW5nZWQgfHwgdXBkYXRlLnZpZXdwb3J0Q2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy50cmVlID0gdHJlZTtcbiAgICAgICAgICAgIHRoaXMuYWx3YXlzID0gYWx3YXlzO1xuICAgICAgICAgICAgdGhpcy5kZWNvcmF0aW9ucyA9IGJ1aWxkRGVjbyh1cGRhdGUudmlldywgdHJlZSwgYWx3YXlzKTtcbiAgICAgICAgfVxuICAgIH1cbn0sIHtcbiAgICBwcm92aWRlOiBwbHVnaW4gPT4ge1xuICAgICAgICBmdW5jdGlvbiBhY2Nlc3Modmlldykge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB2aWV3LnBsdWdpbihwbHVnaW4pKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGVjb3JhdGlvbnMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IERlY29yYXRpb24ubm9uZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW0VkaXRvclZpZXcub3V0ZXJEZWNvcmF0aW9ucy5vZihhY2Nlc3MpLFxuICAgICAgICAgICAgUHJlYy5sb3dlc3QoRWRpdG9yVmlldy5iaWRpSXNvbGF0ZWRSYW5nZXMub2YoYWNjZXNzKSldO1xuICAgIH1cbn0pO1xuZnVuY3Rpb24gYnVpbGREZWNvKHZpZXcsIHRyZWUsIGFsd2F5cykge1xuICAgIGxldCBkZWNvID0gbmV3IFJhbmdlU2V0QnVpbGRlcigpO1xuICAgIGxldCByYW5nZXMgPSB2aWV3LnZpc2libGVSYW5nZXM7XG4gICAgaWYgKCFhbHdheXMpXG4gICAgICAgIHJhbmdlcyA9IGNsaXBSVExMaW5lcyhyYW5nZXMsIHZpZXcuc3RhdGUuZG9jKTtcbiAgICBmb3IgKGxldCB7IGZyb20sIHRvIH0gb2YgcmFuZ2VzKSB7XG4gICAgICAgIHRyZWUuaXRlcmF0ZSh7XG4gICAgICAgICAgICBlbnRlcjogbm9kZSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGlzbyA9IG5vZGUudHlwZS5wcm9wKE5vZGVQcm9wLmlzb2xhdGUpO1xuICAgICAgICAgICAgICAgIGlmIChpc28pXG4gICAgICAgICAgICAgICAgICAgIGRlY28uYWRkKG5vZGUuZnJvbSwgbm9kZS50bywgbWFya3NbaXNvXSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnJvbSwgdG9cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBkZWNvLmZpbmlzaCgpO1xufVxuZnVuY3Rpb24gY2xpcFJUTExpbmVzKHJhbmdlcywgZG9jKSB7XG4gICAgbGV0IGN1ciA9IGRvYy5pdGVyKCksIHBvcyA9IDAsIHJlc3VsdCA9IFtdLCBsYXN0ID0gbnVsbDtcbiAgICBmb3IgKGxldCB7IGZyb20sIHRvIH0gb2YgcmFuZ2VzKSB7XG4gICAgICAgIGlmIChsYXN0ICYmIGxhc3QudG8gPiBmcm9tKSB7XG4gICAgICAgICAgICBmcm9tID0gbGFzdC50bztcbiAgICAgICAgICAgIGlmIChmcm9tID49IHRvKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3MgKyBjdXIudmFsdWUubGVuZ3RoIDwgZnJvbSkge1xuICAgICAgICAgICAgY3VyLm5leHQoZnJvbSAtIChwb3MgKyBjdXIudmFsdWUubGVuZ3RoKSk7XG4gICAgICAgICAgICBwb3MgPSBmcm9tO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IHBvcywgZW5kID0gcG9zICsgY3VyLnZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgIGlmICghY3VyLmxpbmVCcmVhayAmJiBidWlsZEZvckxpbmUoY3VyLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGlmIChsYXN0ICYmIGxhc3QudG8gPiBzdGFydCAtIDEwKVxuICAgICAgICAgICAgICAgICAgICBsYXN0LnRvID0gTWF0aC5taW4odG8sIGVuZCk7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChsYXN0ID0geyBmcm9tOiBzdGFydCwgdG86IE1hdGgubWluKHRvLCBlbmQpIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGVuZCA+PSB0bylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHBvcyA9IGVuZDtcbiAgICAgICAgICAgIGN1ci5uZXh0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IG1hcmtzID0ge1xuICAgIHJ0bDogLypAX19QVVJFX18qL0RlY29yYXRpb24ubWFyayh7IGNsYXNzOiBcImNtLWlzb1wiLCBpbmNsdXNpdmU6IHRydWUsIGF0dHJpYnV0ZXM6IHsgZGlyOiBcInJ0bFwiIH0sIGJpZGlJc29sYXRlOiBEaXJlY3Rpb24uUlRMIH0pLFxuICAgIGx0cjogLypAX19QVVJFX18qL0RlY29yYXRpb24ubWFyayh7IGNsYXNzOiBcImNtLWlzb1wiLCBpbmNsdXNpdmU6IHRydWUsIGF0dHJpYnV0ZXM6IHsgZGlyOiBcImx0clwiIH0sIGJpZGlJc29sYXRlOiBEaXJlY3Rpb24uTFRSIH0pLFxuICAgIGF1dG86IC8qQF9fUFVSRV9fKi9EZWNvcmF0aW9uLm1hcmsoeyBjbGFzczogXCJjbS1pc29cIiwgaW5jbHVzaXZlOiB0cnVlLCBhdHRyaWJ1dGVzOiB7IGRpcjogXCJhdXRvXCIgfSwgYmlkaUlzb2xhdGU6IG51bGwgfSlcbn07XG5cbmV4cG9ydCB7IERvY0lucHV0LCBIaWdobGlnaHRTdHlsZSwgSW5kZW50Q29udGV4dCwgTFJMYW5ndWFnZSwgTGFuZ3VhZ2UsIExhbmd1YWdlRGVzY3JpcHRpb24sIExhbmd1YWdlU3VwcG9ydCwgUGFyc2VDb250ZXh0LCBTdHJlYW1MYW5ndWFnZSwgU3RyaW5nU3RyZWFtLCBUcmVlSW5kZW50Q29udGV4dCwgYmlkaUlzb2xhdGVzLCBicmFja2V0TWF0Y2hpbmcsIGJyYWNrZXRNYXRjaGluZ0hhbmRsZSwgY29kZUZvbGRpbmcsIGNvbnRpbnVlZEluZGVudCwgZGVmYXVsdEhpZ2hsaWdodFN0eWxlLCBkZWZpbmVMYW5ndWFnZUZhY2V0LCBkZWxpbWl0ZWRJbmRlbnQsIGVuc3VyZVN5bnRheFRyZWUsIGZsYXRJbmRlbnQsIGZvbGRBbGwsIGZvbGRDb2RlLCBmb2xkRWZmZWN0LCBmb2xkR3V0dGVyLCBmb2xkSW5zaWRlLCBmb2xkS2V5bWFwLCBmb2xkTm9kZVByb3AsIGZvbGRTZXJ2aWNlLCBmb2xkU3RhdGUsIGZvbGRhYmxlLCBmb2xkZWRSYW5nZXMsIGZvcmNlUGFyc2luZywgZ2V0SW5kZW50VW5pdCwgZ2V0SW5kZW50YXRpb24sIGhpZ2hsaWdodGluZ0ZvciwgaW5kZW50Tm9kZVByb3AsIGluZGVudE9uSW5wdXQsIGluZGVudFJhbmdlLCBpbmRlbnRTZXJ2aWNlLCBpbmRlbnRTdHJpbmcsIGluZGVudFVuaXQsIGxhbmd1YWdlLCBsYW5ndWFnZURhdGFQcm9wLCBtYXRjaEJyYWNrZXRzLCBzdWJsYW5ndWFnZVByb3AsIHN5bnRheEhpZ2hsaWdodGluZywgc3ludGF4UGFyc2VyUnVubmluZywgc3ludGF4VHJlZSwgc3ludGF4VHJlZUF2YWlsYWJsZSwgdG9nZ2xlRm9sZCwgdW5mb2xkQWxsLCB1bmZvbGRDb2RlLCB1bmZvbGRFZmZlY3QgfTtcbiJdLCJuYW1lcyI6WyJOb2RlUHJvcCIsIkl0ZXJNb2RlIiwiVHJlZSIsIlRyZWVGcmFnbWVudCIsIlBhcnNlciIsIk5vZGVUeXBlIiwiTm9kZVNldCIsIlN0YXRlRWZmZWN0IiwiU3RhdGVGaWVsZCIsIkZhY2V0IiwiRWRpdG9yU3RhdGUiLCJjb3VudENvbHVtbiIsImNvbWJpbmVDb25maWciLCJSYW5nZVNldCIsIlJhbmdlU2V0QnVpbGRlciIsIlByZWMiLCJWaWV3UGx1Z2luIiwibG9nRXhjZXB0aW9uIiwiRWRpdG9yVmlldyIsIkRlY29yYXRpb24iLCJXaWRnZXRUeXBlIiwiZ3V0dGVyIiwiR3V0dGVyTWFya2VyIiwiRGlyZWN0aW9uIiwidGFncyIsInRhZ0hpZ2hsaWdodGVyIiwiaGlnaGxpZ2h0VHJlZSIsInN0eWxlVGFncyIsIlN0eWxlTW9kdWxlIiwiX2EiLCJsYW5ndWFnZURhdGFQcm9wIiwiZGVmaW5lTGFuZ3VhZ2VGYWNldCIsImJhc2VEYXRhIiwiZGVmaW5lIiwiY29tYmluZSIsInZhbHVlcyIsImNvbmNhdCIsInVuZGVmaW5lZCIsInN1Ymxhbmd1YWdlUHJvcCIsIkxhbmd1YWdlIiwiY29uc3RydWN0b3IiLCJkYXRhIiwicGFyc2VyIiwiZXh0cmFFeHRlbnNpb25zIiwibmFtZSIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJnZXQiLCJzeW50YXhUcmVlIiwiZXh0ZW5zaW9uIiwibGFuZ3VhZ2UiLCJvZiIsImxhbmd1YWdlRGF0YSIsInN0YXRlIiwicG9zIiwic2lkZSIsInRvcCIsInRvcE5vZGVBdCIsInR5cGUiLCJwcm9wIiwiYmFzZSIsImZhY2V0Iiwic3ViIiwiaW5uZXJOb2RlIiwicmVzb2x2ZSIsImZyb20iLCJzdWJsYW5nIiwidGVzdCIsImlzQWN0aXZlQXQiLCJmaW5kUmVnaW9ucyIsImxhbmciLCJ0byIsImRvYyIsImxlbmd0aCIsImFsbG93c05lc3RpbmciLCJyZXN1bHQiLCJleHBsb3JlIiwidHJlZSIsInB1c2giLCJtb3VudCIsIm1vdW50ZWQiLCJvdmVybGF5IiwiciIsInNpemUiLCJpIiwiY2hpbGRyZW4iLCJjaCIsInBvc2l0aW9ucyIsInNldFN0YXRlIiwidG9wTGFuZyIsInRvcE5vZGUiLCJub2RlIiwiZW50ZXIiLCJFeGNsdWRlQnVmZmVycyIsImlzVG9wIiwiTFJMYW5ndWFnZSIsInNwZWMiLCJjb25maWd1cmUiLCJwcm9wcyIsImFkZCIsIm9wdGlvbnMiLCJoYXNXcmFwcGVycyIsImZpZWxkIiwiZW1wdHkiLCJlbnN1cmVTeW50YXhUcmVlIiwidXB0byIsInRpbWVvdXQiLCJwYXJzZSIsImNvbnRleHQiLCJvbGRWaWVwb3J0Iiwidmlld3BvcnQiLCJ1cGRhdGVWaWV3cG9ydCIsImlzRG9uZSIsIndvcmsiLCJzeW50YXhUcmVlQXZhaWxhYmxlIiwiZm9yY2VQYXJzaW5nIiwidmlldyIsInN1Y2Nlc3MiLCJkaXNwYXRjaCIsInN5bnRheFBhcnNlclJ1bm5pbmciLCJwbHVnaW4iLCJwYXJzZVdvcmtlciIsImlzV29ya2luZyIsIkRvY0lucHV0IiwiY3Vyc29yUG9zIiwic3RyaW5nIiwiY3Vyc29yIiwiaXRlciIsInN5bmNUbyIsIm5leHQiLCJ2YWx1ZSIsImNodW5rIiwibGluZUNodW5rcyIsInJlYWQiLCJzdHJpbmdTdGFydCIsInNsaWNlU3RyaW5nIiwic2xpY2UiLCJjdXJyZW50Q29udGV4dCIsIlBhcnNlQ29udGV4dCIsImZyYWdtZW50cyIsInRyZWVMZW4iLCJza2lwcGVkIiwic2NoZWR1bGVPbiIsInRlbXBTa2lwcGVkIiwiY3JlYXRlIiwic3RhcnRQYXJzZSIsInVudGlsIiwidGFrZVRyZWUiLCJ3aXRoQ29udGV4dCIsImVuZFRpbWUiLCJEYXRlIiwibm93Iiwic3RvcHBlZEF0Iiwic3RvcEF0IiwiZG9uZSIsImFkdmFuY2UiLCJ3aXRob3V0VGVtcFNraXBwZWQiLCJhZGRUcmVlIiwicGFyc2VkUG9zIiwiZiIsInByZXYiLCJwb3AiLCJjdXRGcmFnbWVudHMiLCJjaGFuZ2VzIiwibmV3U3RhdGUiLCJyYW5nZXMiLCJpdGVyQ2hhbmdlZFJhbmdlcyIsImZyb21BIiwidG9BIiwiZnJvbUIiLCJ0b0IiLCJhcHBseUNoYW5nZXMiLCJtYXBQb3MiLCJzdGFydExlbiIsInNwbGljZSIsInJlc2V0Iiwic2tpcFVudGlsSW5WaWV3IiwiZ2V0U2tpcHBpbmdQYXJzZXIiLCJjcmVhdGVQYXJzZSIsImlucHV0IiwiY3giLCJQcm9taXNlIiwiYWxsIiwibm9uZSIsIk1hdGgiLCJtaW4iLCJmcmFncyIsIkxhbmd1YWdlU3RhdGUiLCJhcHBseSIsInRyIiwiZG9jQ2hhbmdlZCIsIm5ld0N4Iiwic3RhcnRTdGF0ZSIsIm1heCIsImluaXQiLCJ2cFRvIiwicGFyc2VTdGF0ZSIsInVwZGF0ZSIsImUiLCJlZmZlY3RzIiwiaXMiLCJyZXF1ZXN0SWRsZSIsImNhbGxiYWNrIiwic2V0VGltZW91dCIsImNsZWFyVGltZW91dCIsInJlcXVlc3RJZGxlQ2FsbGJhY2siLCJpZGxlIiwiY2FuY2VsSWRsZUNhbGxiYWNrIiwiaXNJbnB1dFBlbmRpbmciLCJuYXZpZ2F0b3IiLCJzY2hlZHVsaW5nIiwiZnJvbUNsYXNzIiwiUGFyc2VXb3JrZXIiLCJ3b3JraW5nIiwid29ya1NjaGVkdWxlZCIsImNodW5rRW5kIiwiY2h1bmtCdWRnZXQiLCJiaW5kIiwic2NoZWR1bGVXb3JrIiwic2VsZWN0aW9uU2V0IiwiaGFzRm9jdXMiLCJjaGVja0FzeW5jU2NoZWR1bGUiLCJkZWFkbGluZSIsInRpbWVSZW1haW5pbmciLCJ2aWV3cG9ydEZpcnN0IiwidGhlbiIsImNhdGNoIiwiZXJyIiwiZGVzdHJveSIsImV2ZW50SGFuZGxlcnMiLCJmb2N1cyIsImxhbmd1YWdlcyIsImVuYWJsZXMiLCJjb250ZW50QXR0cmlidXRlcyIsImNvbXB1dGUiLCJMYW5ndWFnZVN1cHBvcnQiLCJzdXBwb3J0IiwiTGFuZ3VhZ2VEZXNjcmlwdGlvbiIsImFsaWFzIiwiZXh0ZW5zaW9ucyIsImZpbGVuYW1lIiwibG9hZEZ1bmMiLCJsb2FkaW5nIiwibG9hZCIsIlJhbmdlRXJyb3IiLCJtYXAiLCJzIiwidG9Mb3dlckNhc2UiLCJtYXRjaEZpbGVuYW1lIiwiZGVzY3MiLCJkIiwiZXh0IiwiZXhlYyIsImluZGV4T2YiLCJtYXRjaExhbmd1YWdlTmFtZSIsImZ1enp5Iiwic29tZSIsImEiLCJmb3VuZCIsImluZGVudFNlcnZpY2UiLCJpbmRlbnRVbml0IiwidW5pdCIsIkFycmF5IiwiRXJyb3IiLCJKU09OIiwic3RyaW5naWZ5IiwiZ2V0SW5kZW50VW5pdCIsImNoYXJDb2RlQXQiLCJ0YWJTaXplIiwiaW5kZW50U3RyaW5nIiwiY29scyIsInRzIiwiZ2V0SW5kZW50YXRpb24iLCJJbmRlbnRDb250ZXh0Iiwic2VydmljZSIsInN5bnRheEluZGVudGF0aW9uIiwiaW5kZW50UmFuZ2UiLCJ1cGRhdGVkIiwib3ZlcnJpZGVJbmRlbnRhdGlvbiIsInN0YXJ0IiwibGluZSIsImxpbmVBdCIsImluZGVudCIsInRleHQiLCJjdXIiLCJub3JtIiwiaW5zZXJ0IiwiYmlhcyIsInNpbXVsYXRlQnJlYWsiLCJzaW11bGF0ZURvdWJsZUJyZWFrIiwidGV4dEFmdGVyUG9zIiwiY29sdW1uIiwib3ZlcnJpZGUiLCJzZWFyY2giLCJsaW5lSW5kZW50Iiwib3ZlcnJpZGVuIiwic2ltdWxhdGVkQnJlYWsiLCJpbmRlbnROb2RlUHJvcCIsImFzdCIsInN0YWNrIiwicmVzb2x2ZVN0YWNrIiwiaW5uZXIiLCJlbnRlclVuZmluaXNoZWROb2Rlc0JlZm9yZSIsInBhcmVudCIsImluZGVudEZvciIsInN0cmF0ZWd5IiwiaW5kZW50U3RyYXRlZ3kiLCJUcmVlSW5kZW50Q29udGV4dCIsImlnbm9yZUNsb3NlZCIsImZpcnN0IiwiZmlyc3RDaGlsZCIsImNsb3NlIiwiY2xvc2VkQnkiLCJsYXN0IiwibGFzdENoaWxkIiwiY2xvc2VkIiwiZGVsaW1pdGVkU3RyYXRlZ3kiLCJ0b3BJbmRlbnQiLCJ0ZXh0QWZ0ZXIiLCJiYXNlSW5kZW50IiwiYmFzZUluZGVudEZvciIsImF0QnJlYWsiLCJpc1BhcmVudCIsImNvbnRpbnVlIiwiYnJhY2tldGVkQWxpZ25lZCIsIm9wZW5Ub2tlbiIsImNoaWxkQWZ0ZXIiLCJzaW0iLCJvcGVuTGluZSIsImxpbmVFbmQiLCJpc1NraXBwZWQiLCJkZWxpbWl0ZWRJbmRlbnQiLCJjbG9zaW5nIiwiYWxpZ24iLCJ1bml0cyIsImNsb3NlZEF0IiwiYWZ0ZXIiLCJzcGFjZSIsIm1hdGNoIiwiYWxpZ25lZCIsImZsYXRJbmRlbnQiLCJjb250aW51ZWRJbmRlbnQiLCJleGNlcHQiLCJtYXRjaEV4Y2VwdCIsIkRvbnRJbmRlbnRCZXlvbmQiLCJpbmRlbnRPbklucHV0IiwidHJhbnNhY3Rpb25GaWx0ZXIiLCJpc1VzZXJFdmVudCIsInJ1bGVzIiwibGFuZ3VhZ2VEYXRhQXQiLCJzZWxlY3Rpb24iLCJtYWluIiwiaGVhZCIsIm5ld0RvYyIsIm5ld1NlbGVjdGlvbiIsImxpbmVTdGFydCIsInNlcXVlbnRpYWwiLCJmb2xkU2VydmljZSIsImZvbGROb2RlUHJvcCIsImZvbGRJbnNpZGUiLCJpc0Vycm9yIiwic3ludGF4Rm9sZGluZyIsImVuZCIsImlzVW5maW5pc2hlZCIsImZvbGRhYmxlIiwibWFwUmFuZ2UiLCJyYW5nZSIsIm1hcHBpbmciLCJmb2xkRWZmZWN0IiwidW5mb2xkRWZmZWN0Iiwic2VsZWN0ZWRMaW5lcyIsImxpbmVzIiwibCIsImxpbmVCbG9ja0F0IiwiZm9sZFN0YXRlIiwiZm9sZGVkIiwiZm9sZEV4aXN0cyIsInByZXBhcmVQbGFjZWhvbGRlciIsImZvbGRDb25maWciLCJ3aWRnZXQiLCJmb2xkV2lkZ2V0IiwicmVwbGFjZSIsIlByZXBhcmVkRm9sZFdpZGdldCIsImZpbHRlciIsImZpbHRlckZyb20iLCJmaWx0ZXJUbyIsIm9uU2VsZWN0aW9uIiwiYmV0d2VlbiIsImIiLCJwcm92aWRlIiwiZGVjb3JhdGlvbnMiLCJ0b0pTT04iLCJmcm9tSlNPTiIsImlzQXJyYXkiLCJzZXQiLCJmb2xkZWRSYW5nZXMiLCJmaW5kRm9sZCIsIm1heWJlRW5hYmxlIiwib3RoZXIiLCJhcHBlbmRDb25maWciLCJjb2RlRm9sZGluZyIsImZvbGRDb2RlIiwiYW5ub3VuY2VGb2xkIiwidW5mb2xkQ29kZSIsImZvbGQiLCJsaW5lRnJvbSIsIm51bWJlciIsImxpbmVUbyIsImFubm91bmNlIiwicGhyYXNlIiwiZm9sZEFsbCIsInVuZm9sZEFsbCIsImZvbGRhYmxlQ29udGFpbmVyIiwibGluZUJsb2NrIiwiZm9sZGFibGVSZWdpb24iLCJ0b2dnbGVGb2xkIiwiZm9sZFJhbmdlIiwiZm9sZEtleW1hcCIsImtleSIsIm1hYyIsInJ1biIsImRlZmF1bHRDb25maWciLCJwbGFjZWhvbGRlckRPTSIsInBsYWNlaG9sZGVyVGV4dCIsImNvbmZpZyIsImJhc2VUaGVtZSQxIiwid2lkZ2V0VG9ET00iLCJwcmVwYXJlZCIsImNvbmYiLCJvbmNsaWNrIiwiZXZlbnQiLCJwb3NBdERPTSIsInRhcmdldCIsInByZXZlbnREZWZhdWx0IiwiZWxlbWVudCIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsInRleHRDb250ZW50Iiwic2V0QXR0cmlidXRlIiwidGl0bGUiLCJjbGFzc05hbWUiLCJ0b0RPTSIsImVxIiwiZm9sZEd1dHRlckRlZmF1bHRzIiwib3BlblRleHQiLCJjbG9zZWRUZXh0IiwibWFya2VyRE9NIiwiZG9tRXZlbnRIYW5kbGVycyIsImZvbGRpbmdDaGFuZ2VkIiwiRm9sZE1hcmtlciIsIm9wZW4iLCJzcGFuIiwiZm9sZEd1dHRlciIsImZ1bGxDb25maWciLCJhc3NpZ24iLCJjYW5Gb2xkIiwiY2FuVW5mb2xkIiwibWFya2VycyIsImJ1aWxkTWFya2VycyIsInZpZXdwb3J0Q2hhbmdlZCIsImJ1aWxkZXIiLCJ2aWV3cG9ydExpbmVCbG9ja3MiLCJtYXJrIiwiZmluaXNoIiwiY2xhc3MiLCJpbml0aWFsU3BhY2VyIiwiY2xpY2siLCJiYXNlVGhlbWUiLCJiYWNrZ3JvdW5kQ29sb3IiLCJib3JkZXIiLCJjb2xvciIsImJvcmRlclJhZGl1cyIsIm1hcmdpbiIsInBhZGRpbmciLCJIaWdobGlnaHRTdHlsZSIsInNwZWNzIiwibW9kU3BlYyIsImRlZiIsImNscyIsIm5ld05hbWUiLCJzY29wZU9wdCIsInNjb3BlIiwic3R5bGUiLCJ0YWciLCJtb2R1bGUiLCJ0aGVtZVR5cGUiLCJoaWdobGlnaHRlckZhY2V0IiwiZmFsbGJhY2tIaWdobGlnaHRlciIsImdldEhpZ2hsaWdodGVycyIsInN5bnRheEhpZ2hsaWdodGluZyIsImhpZ2hsaWdodGVyIiwidHJlZUhpZ2hsaWdodGVyIiwic3R5bGVNb2R1bGUiLCJmYWxsYmFjayIsImNvbXB1dGVOIiwiZGFya1RoZW1lIiwiaGlnaGxpZ2h0aW5nRm9yIiwiaGlnaGxpZ2h0ZXJzIiwiVHJlZUhpZ2hsaWdodGVyIiwibWFya0NhY2hlIiwiYnVpbGREZWNvIiwiZGVjb3JhdGVkVG8iLCJzdHlsZUNoYW5nZSIsImRlY29yYXRlZFRvTWFwcGVkIiwidmlzaWJsZVJhbmdlcyIsImhpZ2giLCJ2IiwiZGVmYXVsdEhpZ2hsaWdodFN0eWxlIiwibWV0YSIsImxpbmsiLCJ0ZXh0RGVjb3JhdGlvbiIsImhlYWRpbmciLCJmb250V2VpZ2h0IiwiZW1waGFzaXMiLCJmb250U3R5bGUiLCJzdHJvbmciLCJzdHJpa2V0aHJvdWdoIiwia2V5d29yZCIsImF0b20iLCJib29sIiwidXJsIiwiY29udGVudFNlcGFyYXRvciIsImxhYmVsTmFtZSIsImxpdGVyYWwiLCJpbnNlcnRlZCIsImRlbGV0ZWQiLCJyZWdleHAiLCJlc2NhcGUiLCJzcGVjaWFsIiwiZGVmaW5pdGlvbiIsInZhcmlhYmxlTmFtZSIsImxvY2FsIiwidHlwZU5hbWUiLCJuYW1lc3BhY2UiLCJtYWNyb05hbWUiLCJwcm9wZXJ0eU5hbWUiLCJjb21tZW50IiwiaW52YWxpZCIsIkRlZmF1bHRTY2FuRGlzdCIsIkRlZmF1bHRCcmFja2V0cyIsImJyYWNrZXRNYXRjaGluZ0NvbmZpZyIsImNvbmZpZ3MiLCJhZnRlckN1cnNvciIsImJyYWNrZXRzIiwibWF4U2NhbkRpc3RhbmNlIiwicmVuZGVyTWF0Y2giLCJkZWZhdWx0UmVuZGVyTWF0Y2giLCJtYXRjaGluZ01hcmsiLCJub25tYXRjaGluZ01hcmsiLCJtYXRjaGVkIiwiYnJhY2tldE1hdGNoaW5nU3RhdGUiLCJkZWNvIiwibWF0Y2hCcmFja2V0cyIsImJyYWNrZXRNYXRjaGluZ1VuaXF1ZSIsImJyYWNrZXRNYXRjaGluZyIsImJyYWNrZXRNYXRjaGluZ0hhbmRsZSIsIm1hdGNoaW5nTm9kZXMiLCJkaXIiLCJieVByb3AiLCJvcGVuZWRCeSIsImluZGV4IiwiZmluZEhhbmRsZSIsImhhc0hhbmRsZSIsInJlc29sdmVJbm5lciIsIm1hdGNoZXMiLCJoYW5kbGUiLCJtYXRjaE1hcmtlZEJyYWNrZXRzIiwibWF0Y2hQbGFpbkJyYWNrZXRzIiwiX3N0YXRlIiwiX3BvcyIsInRva2VuIiwibWF0Y2hpbmciLCJmaXJzdFRva2VuIiwiZGVwdGgiLCJjaGlsZEJlZm9yZSIsImVuZEhhbmRsZSIsInByZXZTaWJsaW5nIiwibmV4dFNpYmxpbmciLCJ0b2tlblR5cGUiLCJzdGFydENoIiwic2xpY2VEb2MiLCJicmFja2V0Iiwic3RhcnRUb2tlbiIsIml0ZXJSYW5nZSIsImRpc3RhbmNlIiwiYmFzZVBvcyIsImNvdW50Q29sIiwic3RhcnRJbmRleCIsInN0YXJ0VmFsdWUiLCJuIiwiU3RyaW5nU3RyZWFtIiwib3ZlcnJpZGVJbmRlbnQiLCJsYXN0Q29sdW1uUG9zIiwibGFzdENvbHVtblZhbHVlIiwiZW9sIiwic29sIiwicGVlayIsImNoYXJBdCIsImVhdCIsIm9rIiwiUmVnRXhwIiwiZWF0V2hpbGUiLCJlYXRTcGFjZSIsInNraXBUb0VuZCIsInNraXBUbyIsImJhY2tVcCIsImluZGVudGF0aW9uIiwicGF0dGVybiIsImNvbnN1bWUiLCJjYXNlSW5zZW5zaXRpdmUiLCJjYXNlZCIsInN0ciIsInN1YnN0ciIsImN1cnJlbnQiLCJmdWxsUGFyc2VyIiwiYmxhbmtMaW5lIiwiY29weVN0YXRlIiwiZGVmYXVsdENvcHlTdGF0ZSIsInRva2VuVGFibGUiLCJub1Rva2VucyIsInZhbCIsIkluZGVudGVkRnJvbSIsIldlYWtNYXAiLCJTdHJlYW1MYW5ndWFnZSIsInAiLCJzZWxmIiwiaW1wbCIsIlBhcnNlIiwiZ2V0SW5kZW50IiwiZG9jSUQiLCJzdHJlYW1QYXJzZXIiLCJzdGF0ZUFmdGVyIiwicGVyTm9kZSIsIlRva2VuVGFibGUiLCJkZWZhdWx0VG9rZW5UYWJsZSIsImF0IiwiZmluZFN0YXRlIiwic3RhdGVQb3MiLCJzdHJlYW0iLCJyZWFkVG9rZW4iLCJvZmYiLCJzdGFydFBvcyIsImJlZm9yZSIsImNoaWxkIiwiY3V0VHJlZSIsImluc2lkZSIsImZpbmRTdGFydEluRnJhZ21lbnRzIiwiZWRpdG9yU3RhdGUiLCJvcGVuU3RhcnQiLCJvcGVuRW5kIiwib2Zmc2V0IiwiY2h1bmtzIiwiY2h1bmtQb3MiLCJjaHVua1JldXNlZCIsInJhbmdlSW5kZXgiLCJjaHVua1N0YXJ0IiwibW92ZVJhbmdlSW5kZXgiLCJwYXJzZUVuZCIsInBhcnNlTGluZSIsImZpbmlzaENodW5rIiwibGluZUFmdGVyIiwibmV4dExpbmUiLCJyYW5nZUVuZCIsInJhbmdlU3RhcnQiLCJza2lwR2Fwc1RvIiwib2ZmUG9zIiwiZW1pdFRva2VuIiwiaWQiLCJsZW4wIiwiYnVpbGQiLCJidWZmZXIiLCJub2RlU2V0IiwidG9wSUQiLCJtYXhCdWZmZXJMZW5ndGgiLCJyZXVzZWQiLCJiYWxhbmNlIiwidHlwZUFycmF5Iiwid2FybmVkIiwiYnlUYWciLCJkZWZhdWx0VGFibGUiLCJsZWdhY3lOYW1lIiwiY3JlYXRlVG9rZW5UeXBlIiwiZXh0cmEiLCJ0YWJsZSIsIndhcm5Gb3JQYXJ0IiwicGFydCIsIm1zZyIsImNvbnNvbGUiLCJ3YXJuIiwidGFnU3RyIiwidGFncyQxIiwic3BsaXQiLCJ0Iiwia25vd24iLCJidWlsZEZvckxpbmUiLCJ0ZXh0SGFzUlRMIiwiY2hhbmdlQWRkc1JUTCIsImNoYW5nZSIsImFkZGVkIiwiaXRlckNoYW5nZXMiLCJmQSIsInRBIiwiZkIiLCJ0QiIsImlucyIsImFsd2F5c0lzb2xhdGUiLCJ4IiwiYmlkaUlzb2xhdGVzIiwiaXNvbGF0ZU1hcmtzIiwiYWx3YXlzIiwidGV4dERpcmVjdGlvbiIsIkxUUiIsInBlckxpbmVUZXh0RGlyZWN0aW9uIiwiaGFzUlRMIiwiYWNjZXNzIiwiX2IiLCJvdXRlckRlY29yYXRpb25zIiwibG93ZXN0IiwiYmlkaUlzb2xhdGVkUmFuZ2VzIiwiY2xpcFJUTExpbmVzIiwiaXRlcmF0ZSIsImlzbyIsImlzb2xhdGUiLCJtYXJrcyIsImxpbmVCcmVhayIsInJ0bCIsImluY2x1c2l2ZSIsImF0dHJpYnV0ZXMiLCJiaWRpSXNvbGF0ZSIsIlJUTCIsImx0ciIsImF1dG8iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/@codemirror/language/dist/index.js\n");

/***/ }),

/***/ "../../node_modules/@lezer/common/dist/index.js":
/*!******************************************************!*\
  !*** ../../node_modules/@lezer/common/dist/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultBufferLength: () => (/* binding */ DefaultBufferLength),\n/* harmony export */   IterMode: () => (/* binding */ IterMode),\n/* harmony export */   MountedTree: () => (/* binding */ MountedTree),\n/* harmony export */   NodeProp: () => (/* binding */ NodeProp),\n/* harmony export */   NodeSet: () => (/* binding */ NodeSet),\n/* harmony export */   NodeType: () => (/* binding */ NodeType),\n/* harmony export */   NodeWeakMap: () => (/* binding */ NodeWeakMap),\n/* harmony export */   Parser: () => (/* binding */ Parser),\n/* harmony export */   Tree: () => (/* binding */ Tree),\n/* harmony export */   TreeBuffer: () => (/* binding */ TreeBuffer),\n/* harmony export */   TreeCursor: () => (/* binding */ TreeCursor),\n/* harmony export */   TreeFragment: () => (/* binding */ TreeFragment),\n/* harmony export */   parseMixed: () => (/* binding */ parseMixed)\n/* harmony export */ });\n/**\nThe default maximum length of a `TreeBuffer` node.\n*/\nconst DefaultBufferLength = 1024;\nlet nextPropID = 0;\nclass Range {\n  constructor(from, to) {\n    this.from = from;\n    this.to = to;\n  }\n}\n/**\nEach [node type](#common.NodeType) or [individual tree](#common.Tree)\ncan have metadata associated with it in props. Instances of this\nclass represent prop names.\n*/\nclass NodeProp {\n  /**\n  Create a new node prop type.\n  */\n  constructor(config = {}) {\n    this.id = nextPropID++;\n    this.perNode = !!config.perNode;\n    this.deserialize = config.deserialize || (() => {\n      throw new Error(\"This node type doesn't define a deserialize function\");\n    });\n  }\n  /**\n  This is meant to be used with\n  [`NodeSet.extend`](#common.NodeSet.extend) or\n  [`LRParser.configure`](#lr.ParserConfig.props) to compute\n  prop values for each node type in the set. Takes a [match\n  object](#common.NodeType^match) or function that returns undefined\n  if the node type doesn't get this prop, and the prop's value if\n  it does.\n  */\n  add(match) {\n    if (this.perNode) throw new RangeError(\"Can't add per-node props to node types\");\n    if (typeof match != \"function\") match = NodeType.match(match);\n    return type => {\n      let result = match(type);\n      return result === undefined ? null : [this, result];\n    };\n  }\n}\n/**\nProp that is used to describe matching delimiters. For opening\ndelimiters, this holds an array of node names (written as a\nspace-separated string when declaring this prop in a grammar)\nfor the node types of closing delimiters that match it.\n*/\nNodeProp.closedBy = new NodeProp({\n  deserialize: str => str.split(\" \")\n});\n/**\nThe inverse of [`closedBy`](#common.NodeProp^closedBy). This is\nattached to closing delimiters, holding an array of node names\nof types of matching opening delimiters.\n*/\nNodeProp.openedBy = new NodeProp({\n  deserialize: str => str.split(\" \")\n});\n/**\nUsed to assign node types to groups (for example, all node\ntypes that represent an expression could be tagged with an\n`\"Expression\"` group).\n*/\nNodeProp.group = new NodeProp({\n  deserialize: str => str.split(\" \")\n});\n/**\nAttached to nodes to indicate these should be\n[displayed](https://codemirror.net/docs/ref/#language.syntaxTree)\nin a bidirectional text isolate, so that direction-neutral\ncharacters on their sides don't incorrectly get associated with\nsurrounding text. You'll generally want to set this for nodes\nthat contain arbitrary text, like strings and comments, and for\nnodes that appear _inside_ arbitrary text, like HTML tags. When\nnot given a value, in a grammar declaration, defaults to\n`\"auto\"`.\n*/\nNodeProp.isolate = new NodeProp({\n  deserialize: value => {\n    if (value && value != \"rtl\" && value != \"ltr\" && value != \"auto\") throw new RangeError(\"Invalid value for isolate: \" + value);\n    return value || \"auto\";\n  }\n});\n/**\nThe hash of the [context](#lr.ContextTracker.constructor)\nthat the node was parsed in, if any. Used to limit reuse of\ncontextual nodes.\n*/\nNodeProp.contextHash = new NodeProp({\n  perNode: true\n});\n/**\nThe distance beyond the end of the node that the tokenizer\nlooked ahead for any of the tokens inside the node. (The LR\nparser only stores this when it is larger than 25, for\nefficiency reasons.)\n*/\nNodeProp.lookAhead = new NodeProp({\n  perNode: true\n});\n/**\nThis per-node prop is used to replace a given node, or part of a\nnode, with another tree. This is useful to include trees from\ndifferent languages in mixed-language parsers.\n*/\nNodeProp.mounted = new NodeProp({\n  perNode: true\n});\n/**\nA mounted tree, which can be [stored](#common.NodeProp^mounted) on\na tree node to indicate that parts of its content are\nrepresented by another tree.\n*/\nclass MountedTree {\n  constructor(\n  /**\n  The inner tree.\n  */\n  tree,\n  /**\n  If this is null, this tree replaces the entire node (it will\n  be included in the regular iteration instead of its host\n  node). If not, only the given ranges are considered to be\n  covered by this tree. This is used for trees that are mixed in\n  a way that isn't strictly hierarchical. Such mounted trees are\n  only entered by [`resolveInner`](#common.Tree.resolveInner)\n  and [`enter`](#common.SyntaxNode.enter).\n  */\n  overlay,\n  /**\n  The parser used to create this subtree.\n  */\n  parser) {\n    this.tree = tree;\n    this.overlay = overlay;\n    this.parser = parser;\n  }\n  /**\n  @internal\n  */\n  static get(tree) {\n    return tree && tree.props && tree.props[NodeProp.mounted.id];\n  }\n}\nconst noProps = Object.create(null);\n/**\nEach node in a syntax tree has a node type associated with it.\n*/\nclass NodeType {\n  /**\n  @internal\n  */\n  constructor(\n  /**\n  The name of the node type. Not necessarily unique, but if the\n  grammar was written properly, different node types with the\n  same name within a node set should play the same semantic\n  role.\n  */\n  name,\n  /**\n  @internal\n  */\n  props,\n  /**\n  The id of this node in its set. Corresponds to the term ids\n  used in the parser.\n  */\n  id,\n  /**\n  @internal\n  */\n  flags = 0) {\n    this.name = name;\n    this.props = props;\n    this.id = id;\n    this.flags = flags;\n  }\n  /**\n  Define a node type.\n  */\n  static define(spec) {\n    let props = spec.props && spec.props.length ? Object.create(null) : noProps;\n    let flags = (spec.top ? 1 /* NodeFlag.Top */ : 0) | (spec.skipped ? 2 /* NodeFlag.Skipped */ : 0) | (spec.error ? 4 /* NodeFlag.Error */ : 0) | (spec.name == null ? 8 /* NodeFlag.Anonymous */ : 0);\n    let type = new NodeType(spec.name || \"\", props, spec.id, flags);\n    if (spec.props) for (let src of spec.props) {\n      if (!Array.isArray(src)) src = src(type);\n      if (src) {\n        if (src[0].perNode) throw new RangeError(\"Can't store a per-node prop on a node type\");\n        props[src[0].id] = src[1];\n      }\n    }\n    return type;\n  }\n  /**\n  Retrieves a node prop for this type. Will return `undefined` if\n  the prop isn't present on this node.\n  */\n  prop(prop) {\n    return this.props[prop.id];\n  }\n  /**\n  True when this is the top node of a grammar.\n  */\n  get isTop() {\n    return (this.flags & 1 /* NodeFlag.Top */) > 0;\n  }\n  /**\n  True when this node is produced by a skip rule.\n  */\n  get isSkipped() {\n    return (this.flags & 2 /* NodeFlag.Skipped */) > 0;\n  }\n  /**\n  Indicates whether this is an error node.\n  */\n  get isError() {\n    return (this.flags & 4 /* NodeFlag.Error */) > 0;\n  }\n  /**\n  When true, this node type doesn't correspond to a user-declared\n  named node, for example because it is used to cache repetition.\n  */\n  get isAnonymous() {\n    return (this.flags & 8 /* NodeFlag.Anonymous */) > 0;\n  }\n  /**\n  Returns true when this node's name or one of its\n  [groups](#common.NodeProp^group) matches the given string.\n  */\n  is(name) {\n    if (typeof name == 'string') {\n      if (this.name == name) return true;\n      let group = this.prop(NodeProp.group);\n      return group ? group.indexOf(name) > -1 : false;\n    }\n    return this.id == name;\n  }\n  /**\n  Create a function from node types to arbitrary values by\n  specifying an object whose property names are node or\n  [group](#common.NodeProp^group) names. Often useful with\n  [`NodeProp.add`](#common.NodeProp.add). You can put multiple\n  names, separated by spaces, in a single property name to map\n  multiple node names to a single value.\n  */\n  static match(map) {\n    let direct = Object.create(null);\n    for (let prop in map) for (let name of prop.split(\" \")) direct[name] = map[prop];\n    return node => {\n      for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {\n        let found = direct[i < 0 ? node.name : groups[i]];\n        if (found) return found;\n      }\n    };\n  }\n}\n/**\nAn empty dummy node type to use when no actual type is available.\n*/\nNodeType.none = new NodeType(\"\", Object.create(null), 0, 8 /* NodeFlag.Anonymous */);\n/**\nA node set holds a collection of node types. It is used to\ncompactly represent trees by storing their type ids, rather than a\nfull pointer to the type object, in a numeric array. Each parser\n[has](#lr.LRParser.nodeSet) a node set, and [tree\nbuffers](#common.TreeBuffer) can only store collections of nodes\nfrom the same set. A set can have a maximum of 2**16 (65536) node\ntypes in it, so that the ids fit into 16-bit typed array slots.\n*/\nclass NodeSet {\n  /**\n  Create a set with the given types. The `id` property of each\n  type should correspond to its position within the array.\n  */\n  constructor(\n  /**\n  The node types in this set, by id.\n  */\n  types) {\n    this.types = types;\n    for (let i = 0; i < types.length; i++) if (types[i].id != i) throw new RangeError(\"Node type ids should correspond to array positions when creating a node set\");\n  }\n  /**\n  Create a copy of this set with some node properties added. The\n  arguments to this method can be created with\n  [`NodeProp.add`](#common.NodeProp.add).\n  */\n  extend(...props) {\n    let newTypes = [];\n    for (let type of this.types) {\n      let newProps = null;\n      for (let source of props) {\n        let add = source(type);\n        if (add) {\n          if (!newProps) newProps = Object.assign({}, type.props);\n          newProps[add[0].id] = add[1];\n        }\n      }\n      newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);\n    }\n    return new NodeSet(newTypes);\n  }\n}\nconst CachedNode = new WeakMap(),\n  CachedInnerNode = new WeakMap();\n/**\nOptions that control iteration. Can be combined with the `|`\noperator to enable multiple ones.\n*/\nvar IterMode;\n(function (IterMode) {\n  /**\n  When enabled, iteration will only visit [`Tree`](#common.Tree)\n  objects, not nodes packed into\n  [`TreeBuffer`](#common.TreeBuffer)s.\n  */\n  IterMode[IterMode[\"ExcludeBuffers\"] = 1] = \"ExcludeBuffers\";\n  /**\n  Enable this to make iteration include anonymous nodes (such as\n  the nodes that wrap repeated grammar constructs into a balanced\n  tree).\n  */\n  IterMode[IterMode[\"IncludeAnonymous\"] = 2] = \"IncludeAnonymous\";\n  /**\n  By default, regular [mounted](#common.NodeProp^mounted) nodes\n  replace their base node in iteration. Enable this to ignore them\n  instead.\n  */\n  IterMode[IterMode[\"IgnoreMounts\"] = 4] = \"IgnoreMounts\";\n  /**\n  This option only applies in\n  [`enter`](#common.SyntaxNode.enter)-style methods. It tells the\n  library to not enter mounted overlays if one covers the given\n  position.\n  */\n  IterMode[IterMode[\"IgnoreOverlays\"] = 8] = \"IgnoreOverlays\";\n})(IterMode || (IterMode = {}));\n/**\nA piece of syntax tree. There are two ways to approach these\ntrees: the way they are actually stored in memory, and the\nconvenient way.\n\nSyntax trees are stored as a tree of `Tree` and `TreeBuffer`\nobjects. By packing detail information into `TreeBuffer` leaf\nnodes, the representation is made a lot more memory-efficient.\n\nHowever, when you want to actually work with tree nodes, this\nrepresentation is very awkward, so most client code will want to\nuse the [`TreeCursor`](#common.TreeCursor) or\n[`SyntaxNode`](#common.SyntaxNode) interface instead, which provides\na view on some part of this data structure, and can be used to\nmove around to adjacent nodes.\n*/\nclass Tree {\n  /**\n  Construct a new tree. See also [`Tree.build`](#common.Tree^build).\n  */\n  constructor(\n  /**\n  The type of the top node.\n  */\n  type,\n  /**\n  This node's child nodes.\n  */\n  children,\n  /**\n  The positions (offsets relative to the start of this tree) of\n  the children.\n  */\n  positions,\n  /**\n  The total length of this tree\n  */\n  length,\n  /**\n  Per-node [node props](#common.NodeProp) to associate with this node.\n  */\n  props) {\n    this.type = type;\n    this.children = children;\n    this.positions = positions;\n    this.length = length;\n    /**\n    @internal\n    */\n    this.props = null;\n    if (props && props.length) {\n      this.props = Object.create(null);\n      for (let [prop, value] of props) this.props[typeof prop == \"number\" ? prop : prop.id] = value;\n    }\n  }\n  /**\n  @internal\n  */\n  toString() {\n    let mounted = MountedTree.get(this);\n    if (mounted && !mounted.overlay) return mounted.tree.toString();\n    let children = \"\";\n    for (let ch of this.children) {\n      let str = ch.toString();\n      if (str) {\n        if (children) children += \",\";\n        children += str;\n      }\n    }\n    return !this.type.name ? children : (/\\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (children.length ? \"(\" + children + \")\" : \"\");\n  }\n  /**\n  Get a [tree cursor](#common.TreeCursor) positioned at the top of\n  the tree. Mode can be used to [control](#common.IterMode) which\n  nodes the cursor visits.\n  */\n  cursor(mode = 0) {\n    return new TreeCursor(this.topNode, mode);\n  }\n  /**\n  Get a [tree cursor](#common.TreeCursor) pointing into this tree\n  at the given position and side (see\n  [`moveTo`](#common.TreeCursor.moveTo).\n  */\n  cursorAt(pos, side = 0, mode = 0) {\n    let scope = CachedNode.get(this) || this.topNode;\n    let cursor = new TreeCursor(scope);\n    cursor.moveTo(pos, side);\n    CachedNode.set(this, cursor._tree);\n    return cursor;\n  }\n  /**\n  Get a [syntax node](#common.SyntaxNode) object for the top of the\n  tree.\n  */\n  get topNode() {\n    return new TreeNode(this, 0, 0, null);\n  }\n  /**\n  Get the [syntax node](#common.SyntaxNode) at the given position.\n  If `side` is -1, this will move into nodes that end at the\n  position. If 1, it'll move into nodes that start at the\n  position. With 0, it'll only enter nodes that cover the position\n  from both sides.\n  \n  Note that this will not enter\n  [overlays](#common.MountedTree.overlay), and you often want\n  [`resolveInner`](#common.Tree.resolveInner) instead.\n  */\n  resolve(pos, side = 0) {\n    let node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);\n    CachedNode.set(this, node);\n    return node;\n  }\n  /**\n  Like [`resolve`](#common.Tree.resolve), but will enter\n  [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node\n  pointing into the innermost overlaid tree at the given position\n  (with parent links going through all parent structure, including\n  the host trees).\n  */\n  resolveInner(pos, side = 0) {\n    let node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);\n    CachedInnerNode.set(this, node);\n    return node;\n  }\n  /**\n  In some situations, it can be useful to iterate through all\n  nodes around a position, including those in overlays that don't\n  directly cover the position. This method gives you an iterator\n  that will produce all nodes, from small to big, around the given\n  position.\n  */\n  resolveStack(pos, side = 0) {\n    return stackIterator(this, pos, side);\n  }\n  /**\n  Iterate over the tree and its children, calling `enter` for any\n  node that touches the `from`/`to` region (if given) before\n  running over such a node's children, and `leave` (if given) when\n  leaving the node. When `enter` returns `false`, that node will\n  not have its children iterated over (or `leave` called).\n  */\n  iterate(spec) {\n    let {\n      enter,\n      leave,\n      from = 0,\n      to = this.length\n    } = spec;\n    let mode = spec.mode || 0,\n      anon = (mode & IterMode.IncludeAnonymous) > 0;\n    for (let c = this.cursor(mode | IterMode.IncludeAnonymous);;) {\n      let entered = false;\n      if (c.from <= to && c.to >= from && (!anon && c.type.isAnonymous || enter(c) !== false)) {\n        if (c.firstChild()) continue;\n        entered = true;\n      }\n      for (;;) {\n        if (entered && leave && (anon || !c.type.isAnonymous)) leave(c);\n        if (c.nextSibling()) break;\n        if (!c.parent()) return;\n        entered = true;\n      }\n    }\n  }\n  /**\n  Get the value of the given [node prop](#common.NodeProp) for this\n  node. Works with both per-node and per-type props.\n  */\n  prop(prop) {\n    return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : undefined;\n  }\n  /**\n  Returns the node's [per-node props](#common.NodeProp.perNode) in a\n  format that can be passed to the [`Tree`](#common.Tree)\n  constructor.\n  */\n  get propValues() {\n    let result = [];\n    if (this.props) for (let id in this.props) result.push([+id, this.props[id]]);\n    return result;\n  }\n  /**\n  Balance the direct children of this tree, producing a copy of\n  which may have children grouped into subtrees with type\n  [`NodeType.none`](#common.NodeType^none).\n  */\n  balance(config = {}) {\n    return this.children.length <= 8 /* Balance.BranchFactor */ ? this : balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length) => new Tree(this.type, children, positions, length, this.propValues), config.makeTree || ((children, positions, length) => new Tree(NodeType.none, children, positions, length)));\n  }\n  /**\n  Build a tree from a postfix-ordered buffer of node information,\n  or a cursor over such a buffer.\n  */\n  static build(data) {\n    return buildTree(data);\n  }\n}\n/**\nThe empty tree\n*/\nTree.empty = new Tree(NodeType.none, [], [], 0);\nclass FlatBufferCursor {\n  constructor(buffer, index) {\n    this.buffer = buffer;\n    this.index = index;\n  }\n  get id() {\n    return this.buffer[this.index - 4];\n  }\n  get start() {\n    return this.buffer[this.index - 3];\n  }\n  get end() {\n    return this.buffer[this.index - 2];\n  }\n  get size() {\n    return this.buffer[this.index - 1];\n  }\n  get pos() {\n    return this.index;\n  }\n  next() {\n    this.index -= 4;\n  }\n  fork() {\n    return new FlatBufferCursor(this.buffer, this.index);\n  }\n}\n/**\nTree buffers contain (type, start, end, endIndex) quads for each\nnode. In such a buffer, nodes are stored in prefix order (parents\nbefore children, with the endIndex of the parent indicating which\nchildren belong to it).\n*/\nclass TreeBuffer {\n  /**\n  Create a tree buffer.\n  */\n  constructor(\n  /**\n  The buffer's content.\n  */\n  buffer,\n  /**\n  The total length of the group of nodes in the buffer.\n  */\n  length,\n  /**\n  The node set used in this buffer.\n  */\n  set) {\n    this.buffer = buffer;\n    this.length = length;\n    this.set = set;\n  }\n  /**\n  @internal\n  */\n  get type() {\n    return NodeType.none;\n  }\n  /**\n  @internal\n  */\n  toString() {\n    let result = [];\n    for (let index = 0; index < this.buffer.length;) {\n      result.push(this.childString(index));\n      index = this.buffer[index + 3];\n    }\n    return result.join(\",\");\n  }\n  /**\n  @internal\n  */\n  childString(index) {\n    let id = this.buffer[index],\n      endIndex = this.buffer[index + 3];\n    let type = this.set.types[id],\n      result = type.name;\n    if (/\\W/.test(result) && !type.isError) result = JSON.stringify(result);\n    index += 4;\n    if (endIndex == index) return result;\n    let children = [];\n    while (index < endIndex) {\n      children.push(this.childString(index));\n      index = this.buffer[index + 3];\n    }\n    return result + \"(\" + children.join(\",\") + \")\";\n  }\n  /**\n  @internal\n  */\n  findChild(startIndex, endIndex, dir, pos, side) {\n    let {\n        buffer\n      } = this,\n      pick = -1;\n    for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {\n      if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {\n        pick = i;\n        if (dir > 0) break;\n      }\n    }\n    return pick;\n  }\n  /**\n  @internal\n  */\n  slice(startI, endI, from) {\n    let b = this.buffer;\n    let copy = new Uint16Array(endI - startI),\n      len = 0;\n    for (let i = startI, j = 0; i < endI;) {\n      copy[j++] = b[i++];\n      copy[j++] = b[i++] - from;\n      let to = copy[j++] = b[i++] - from;\n      copy[j++] = b[i++] - startI;\n      len = Math.max(len, to);\n    }\n    return new TreeBuffer(copy, len, this.set);\n  }\n}\nfunction checkSide(side, pos, from, to) {\n  switch (side) {\n    case -2 /* Side.Before */:\n      return from < pos;\n    case -1 /* Side.AtOrBefore */:\n      return to >= pos && from < pos;\n    case 0 /* Side.Around */:\n      return from < pos && to > pos;\n    case 1 /* Side.AtOrAfter */:\n      return from <= pos && to > pos;\n    case 2 /* Side.After */:\n      return to > pos;\n    case 4 /* Side.DontCare */:\n      return true;\n  }\n}\nfunction resolveNode(node, pos, side, overlays) {\n  var _a;\n  // Move up to a node that actually holds the position, if possible\n  while (node.from == node.to || (side < 1 ? node.from >= pos : node.from > pos) || (side > -1 ? node.to <= pos : node.to < pos)) {\n    let parent = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent;\n    if (!parent) return node;\n    node = parent;\n  }\n  let mode = overlays ? 0 : IterMode.IgnoreOverlays;\n  // Must go up out of overlays when those do not overlap with pos\n  if (overlays) for (let scan = node, parent = scan.parent; parent; scan = parent, parent = scan.parent) {\n    if (scan instanceof TreeNode && scan.index < 0 && ((_a = parent.enter(pos, side, mode)) === null || _a === void 0 ? void 0 : _a.from) != scan.from) node = parent;\n  }\n  for (;;) {\n    let inner = node.enter(pos, side, mode);\n    if (!inner) return node;\n    node = inner;\n  }\n}\nclass BaseNode {\n  cursor(mode = 0) {\n    return new TreeCursor(this, mode);\n  }\n  getChild(type, before = null, after = null) {\n    let r = getChildren(this, type, before, after);\n    return r.length ? r[0] : null;\n  }\n  getChildren(type, before = null, after = null) {\n    return getChildren(this, type, before, after);\n  }\n  resolve(pos, side = 0) {\n    return resolveNode(this, pos, side, false);\n  }\n  resolveInner(pos, side = 0) {\n    return resolveNode(this, pos, side, true);\n  }\n  matchContext(context) {\n    return matchNodeContext(this, context);\n  }\n  enterUnfinishedNodesBefore(pos) {\n    let scan = this.childBefore(pos),\n      node = this;\n    while (scan) {\n      let last = scan.lastChild;\n      if (!last || last.to != scan.to) break;\n      if (last.type.isError && last.from == last.to) {\n        node = scan;\n        scan = last.prevSibling;\n      } else {\n        scan = last;\n      }\n    }\n    return node;\n  }\n  get node() {\n    return this;\n  }\n  get next() {\n    return this.parent;\n  }\n}\nclass TreeNode extends BaseNode {\n  constructor(_tree, from,\n  // Index in parent node, set to -1 if the node is not a direct child of _parent.node (overlay)\n  index, _parent) {\n    super();\n    this._tree = _tree;\n    this.from = from;\n    this.index = index;\n    this._parent = _parent;\n  }\n  get type() {\n    return this._tree.type;\n  }\n  get name() {\n    return this._tree.type.name;\n  }\n  get to() {\n    return this.from + this._tree.length;\n  }\n  nextChild(i, dir, pos, side, mode = 0) {\n    for (let parent = this;;) {\n      for (let {\n          children,\n          positions\n        } = parent._tree, e = dir > 0 ? children.length : -1; i != e; i += dir) {\n        let next = children[i],\n          start = positions[i] + parent.from;\n        if (!checkSide(side, pos, start, start + next.length)) continue;\n        if (next instanceof TreeBuffer) {\n          if (mode & IterMode.ExcludeBuffers) continue;\n          let index = next.findChild(0, next.buffer.length, dir, pos - start, side);\n          if (index > -1) return new BufferNode(new BufferContext(parent, next, i, start), null, index);\n        } else if (mode & IterMode.IncludeAnonymous || !next.type.isAnonymous || hasChild(next)) {\n          let mounted;\n          if (!(mode & IterMode.IgnoreMounts) && (mounted = MountedTree.get(next)) && !mounted.overlay) return new TreeNode(mounted.tree, start, i, parent);\n          let inner = new TreeNode(next, start, i, parent);\n          return mode & IterMode.IncludeAnonymous || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);\n        }\n      }\n      if (mode & IterMode.IncludeAnonymous || !parent.type.isAnonymous) return null;\n      if (parent.index >= 0) i = parent.index + dir;else i = dir < 0 ? -1 : parent._parent._tree.children.length;\n      parent = parent._parent;\n      if (!parent) return null;\n    }\n  }\n  get firstChild() {\n    return this.nextChild(0, 1, 0, 4 /* Side.DontCare */);\n  }\n  get lastChild() {\n    return this.nextChild(this._tree.children.length - 1, -1, 0, 4 /* Side.DontCare */);\n  }\n  childAfter(pos) {\n    return this.nextChild(0, 1, pos, 2 /* Side.After */);\n  }\n  childBefore(pos) {\n    return this.nextChild(this._tree.children.length - 1, -1, pos, -2 /* Side.Before */);\n  }\n  enter(pos, side, mode = 0) {\n    let mounted;\n    if (!(mode & IterMode.IgnoreOverlays) && (mounted = MountedTree.get(this._tree)) && mounted.overlay) {\n      let rPos = pos - this.from;\n      for (let {\n        from,\n        to\n      } of mounted.overlay) {\n        if ((side > 0 ? from <= rPos : from < rPos) && (side < 0 ? to >= rPos : to > rPos)) return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);\n      }\n    }\n    return this.nextChild(0, 1, pos, side, mode);\n  }\n  nextSignificantParent() {\n    let val = this;\n    while (val.type.isAnonymous && val._parent) val = val._parent;\n    return val;\n  }\n  get parent() {\n    return this._parent ? this._parent.nextSignificantParent() : null;\n  }\n  get nextSibling() {\n    return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4 /* Side.DontCare */) : null;\n  }\n  get prevSibling() {\n    return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4 /* Side.DontCare */) : null;\n  }\n  get tree() {\n    return this._tree;\n  }\n  toTree() {\n    return this._tree;\n  }\n  /**\n  @internal\n  */\n  toString() {\n    return this._tree.toString();\n  }\n}\nfunction getChildren(node, type, before, after) {\n  let cur = node.cursor(),\n    result = [];\n  if (!cur.firstChild()) return result;\n  if (before != null) for (let found = false; !found;) {\n    found = cur.type.is(before);\n    if (!cur.nextSibling()) return result;\n  }\n  for (;;) {\n    if (after != null && cur.type.is(after)) return result;\n    if (cur.type.is(type)) result.push(cur.node);\n    if (!cur.nextSibling()) return after == null ? result : [];\n  }\n}\nfunction matchNodeContext(node, context, i = context.length - 1) {\n  for (let p = node.parent; i >= 0; p = p.parent) {\n    if (!p) return false;\n    if (!p.type.isAnonymous) {\n      if (context[i] && context[i] != p.name) return false;\n      i--;\n    }\n  }\n  return true;\n}\nclass BufferContext {\n  constructor(parent, buffer, index, start) {\n    this.parent = parent;\n    this.buffer = buffer;\n    this.index = index;\n    this.start = start;\n  }\n}\nclass BufferNode extends BaseNode {\n  get name() {\n    return this.type.name;\n  }\n  get from() {\n    return this.context.start + this.context.buffer.buffer[this.index + 1];\n  }\n  get to() {\n    return this.context.start + this.context.buffer.buffer[this.index + 2];\n  }\n  constructor(context, _parent, index) {\n    super();\n    this.context = context;\n    this._parent = _parent;\n    this.index = index;\n    this.type = context.buffer.set.types[context.buffer.buffer[index]];\n  }\n  child(dir, pos, side) {\n    let {\n      buffer\n    } = this.context;\n    let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);\n    return index < 0 ? null : new BufferNode(this.context, this, index);\n  }\n  get firstChild() {\n    return this.child(1, 0, 4 /* Side.DontCare */);\n  }\n  get lastChild() {\n    return this.child(-1, 0, 4 /* Side.DontCare */);\n  }\n  childAfter(pos) {\n    return this.child(1, pos, 2 /* Side.After */);\n  }\n  childBefore(pos) {\n    return this.child(-1, pos, -2 /* Side.Before */);\n  }\n  enter(pos, side, mode = 0) {\n    if (mode & IterMode.ExcludeBuffers) return null;\n    let {\n      buffer\n    } = this.context;\n    let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);\n    return index < 0 ? null : new BufferNode(this.context, this, index);\n  }\n  get parent() {\n    return this._parent || this.context.parent.nextSignificantParent();\n  }\n  externalSibling(dir) {\n    return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, 0, 4 /* Side.DontCare */);\n  }\n  get nextSibling() {\n    let {\n      buffer\n    } = this.context;\n    let after = buffer.buffer[this.index + 3];\n    if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length)) return new BufferNode(this.context, this._parent, after);\n    return this.externalSibling(1);\n  }\n  get prevSibling() {\n    let {\n      buffer\n    } = this.context;\n    let parentStart = this._parent ? this._parent.index + 4 : 0;\n    if (this.index == parentStart) return this.externalSibling(-1);\n    return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, 0, 4 /* Side.DontCare */));\n  }\n  get tree() {\n    return null;\n  }\n  toTree() {\n    let children = [],\n      positions = [];\n    let {\n      buffer\n    } = this.context;\n    let startI = this.index + 4,\n      endI = buffer.buffer[this.index + 3];\n    if (endI > startI) {\n      let from = buffer.buffer[this.index + 1];\n      children.push(buffer.slice(startI, endI, from));\n      positions.push(0);\n    }\n    return new Tree(this.type, children, positions, this.to - this.from);\n  }\n  /**\n  @internal\n  */\n  toString() {\n    return this.context.buffer.childString(this.index);\n  }\n}\nfunction iterStack(heads) {\n  if (!heads.length) return null;\n  let pick = 0,\n    picked = heads[0];\n  for (let i = 1; i < heads.length; i++) {\n    let node = heads[i];\n    if (node.from > picked.from || node.to < picked.to) {\n      picked = node;\n      pick = i;\n    }\n  }\n  let next = picked instanceof TreeNode && picked.index < 0 ? null : picked.parent;\n  let newHeads = heads.slice();\n  if (next) newHeads[pick] = next;else newHeads.splice(pick, 1);\n  return new StackIterator(newHeads, picked);\n}\nclass StackIterator {\n  constructor(heads, node) {\n    this.heads = heads;\n    this.node = node;\n  }\n  get next() {\n    return iterStack(this.heads);\n  }\n}\nfunction stackIterator(tree, pos, side) {\n  let inner = tree.resolveInner(pos, side),\n    layers = null;\n  for (let scan = inner instanceof TreeNode ? inner : inner.context.parent; scan; scan = scan.parent) {\n    if (scan.index < 0) {\n      // This is an overlay root\n      let parent = scan.parent;\n      (layers || (layers = [inner])).push(parent.resolve(pos, side));\n      scan = parent;\n    } else {\n      let mount = MountedTree.get(scan.tree);\n      // Relevant overlay branching off\n      if (mount && mount.overlay && mount.overlay[0].from <= pos && mount.overlay[mount.overlay.length - 1].to >= pos) {\n        let root = new TreeNode(mount.tree, mount.overlay[0].from + scan.from, -1, scan);\n        (layers || (layers = [inner])).push(resolveNode(root, pos, side, false));\n      }\n    }\n  }\n  return layers ? iterStack(layers) : inner;\n}\n/**\nA tree cursor object focuses on a given node in a syntax tree, and\nallows you to move to adjacent nodes.\n*/\nclass TreeCursor {\n  /**\n  Shorthand for `.type.name`.\n  */\n  get name() {\n    return this.type.name;\n  }\n  /**\n  @internal\n  */\n  constructor(node,\n  /**\n  @internal\n  */\n  mode = 0) {\n    this.mode = mode;\n    /**\n    @internal\n    */\n    this.buffer = null;\n    this.stack = [];\n    /**\n    @internal\n    */\n    this.index = 0;\n    this.bufferNode = null;\n    if (node instanceof TreeNode) {\n      this.yieldNode(node);\n    } else {\n      this._tree = node.context.parent;\n      this.buffer = node.context;\n      for (let n = node._parent; n; n = n._parent) this.stack.unshift(n.index);\n      this.bufferNode = node;\n      this.yieldBuf(node.index);\n    }\n  }\n  yieldNode(node) {\n    if (!node) return false;\n    this._tree = node;\n    this.type = node.type;\n    this.from = node.from;\n    this.to = node.to;\n    return true;\n  }\n  yieldBuf(index, type) {\n    this.index = index;\n    let {\n      start,\n      buffer\n    } = this.buffer;\n    this.type = type || buffer.set.types[buffer.buffer[index]];\n    this.from = start + buffer.buffer[index + 1];\n    this.to = start + buffer.buffer[index + 2];\n    return true;\n  }\n  /**\n  @internal\n  */\n  yield(node) {\n    if (!node) return false;\n    if (node instanceof TreeNode) {\n      this.buffer = null;\n      return this.yieldNode(node);\n    }\n    this.buffer = node.context;\n    return this.yieldBuf(node.index, node.type);\n  }\n  /**\n  @internal\n  */\n  toString() {\n    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();\n  }\n  /**\n  @internal\n  */\n  enterChild(dir, pos, side) {\n    if (!this.buffer) return this.yield(this._tree.nextChild(dir < 0 ? this._tree._tree.children.length - 1 : 0, dir, pos, side, this.mode));\n    let {\n      buffer\n    } = this.buffer;\n    let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);\n    if (index < 0) return false;\n    this.stack.push(this.index);\n    return this.yieldBuf(index);\n  }\n  /**\n  Move the cursor to this node's first child. When this returns\n  false, the node has no child, and the cursor has not been moved.\n  */\n  firstChild() {\n    return this.enterChild(1, 0, 4 /* Side.DontCare */);\n  }\n  /**\n  Move the cursor to this node's last child.\n  */\n  lastChild() {\n    return this.enterChild(-1, 0, 4 /* Side.DontCare */);\n  }\n  /**\n  Move the cursor to the first child that ends after `pos`.\n  */\n  childAfter(pos) {\n    return this.enterChild(1, pos, 2 /* Side.After */);\n  }\n  /**\n  Move to the last child that starts before `pos`.\n  */\n  childBefore(pos) {\n    return this.enterChild(-1, pos, -2 /* Side.Before */);\n  }\n  /**\n  Move the cursor to the child around `pos`. If side is -1 the\n  child may end at that position, when 1 it may start there. This\n  will also enter [overlaid](#common.MountedTree.overlay)\n  [mounted](#common.NodeProp^mounted) trees unless `overlays` is\n  set to false.\n  */\n  enter(pos, side, mode = this.mode) {\n    if (!this.buffer) return this.yield(this._tree.enter(pos, side, mode));\n    return mode & IterMode.ExcludeBuffers ? false : this.enterChild(1, pos, side);\n  }\n  /**\n  Move to the node's parent node, if this isn't the top node.\n  */\n  parent() {\n    if (!this.buffer) return this.yieldNode(this.mode & IterMode.IncludeAnonymous ? this._tree._parent : this._tree.parent);\n    if (this.stack.length) return this.yieldBuf(this.stack.pop());\n    let parent = this.mode & IterMode.IncludeAnonymous ? this.buffer.parent : this.buffer.parent.nextSignificantParent();\n    this.buffer = null;\n    return this.yieldNode(parent);\n  }\n  /**\n  @internal\n  */\n  sibling(dir) {\n    if (!this.buffer) return !this._tree._parent ? false : this.yield(this._tree.index < 0 ? null : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4 /* Side.DontCare */, this.mode));\n    let {\n        buffer\n      } = this.buffer,\n      d = this.stack.length - 1;\n    if (dir < 0) {\n      let parentStart = d < 0 ? 0 : this.stack[d] + 4;\n      if (this.index != parentStart) return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, 0, 4 /* Side.DontCare */));\n    } else {\n      let after = buffer.buffer[this.index + 3];\n      if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3])) return this.yieldBuf(after);\n    }\n    return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4 /* Side.DontCare */, this.mode)) : false;\n  }\n  /**\n  Move to this node's next sibling, if any.\n  */\n  nextSibling() {\n    return this.sibling(1);\n  }\n  /**\n  Move to this node's previous sibling, if any.\n  */\n  prevSibling() {\n    return this.sibling(-1);\n  }\n  atLastNode(dir) {\n    let index,\n      parent,\n      {\n        buffer\n      } = this;\n    if (buffer) {\n      if (dir > 0) {\n        if (this.index < buffer.buffer.buffer.length) return false;\n      } else {\n        for (let i = 0; i < this.index; i++) if (buffer.buffer.buffer[i + 3] < this.index) return false;\n      }\n      ({\n        index,\n        parent\n      } = buffer);\n    } else {\n      ({\n        index,\n        _parent: parent\n      } = this._tree);\n    }\n    for (; parent; ({\n      index,\n      _parent: parent\n    } = parent)) {\n      if (index > -1) for (let i = index + dir, e = dir < 0 ? -1 : parent._tree.children.length; i != e; i += dir) {\n        let child = parent._tree.children[i];\n        if (this.mode & IterMode.IncludeAnonymous || child instanceof TreeBuffer || !child.type.isAnonymous || hasChild(child)) return false;\n      }\n    }\n    return true;\n  }\n  move(dir, enter) {\n    if (enter && this.enterChild(dir, 0, 4 /* Side.DontCare */)) return true;\n    for (;;) {\n      if (this.sibling(dir)) return true;\n      if (this.atLastNode(dir) || !this.parent()) return false;\n    }\n  }\n  /**\n  Move to the next node in a\n  [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR)\n  traversal, going from a node to its first child or, if the\n  current node is empty or `enter` is false, its next sibling or\n  the next sibling of the first parent node that has one.\n  */\n  next(enter = true) {\n    return this.move(1, enter);\n  }\n  /**\n  Move to the next node in a last-to-first pre-order traveral. A\n  node is followed by its last child or, if it has none, its\n  previous sibling or the previous sibling of the first parent\n  node that has one.\n  */\n  prev(enter = true) {\n    return this.move(-1, enter);\n  }\n  /**\n  Move the cursor to the innermost node that covers `pos`. If\n  `side` is -1, it will enter nodes that end at `pos`. If it is 1,\n  it will enter nodes that start at `pos`.\n  */\n  moveTo(pos, side = 0) {\n    // Move up to a node that actually holds the position, if possible\n    while (this.from == this.to || (side < 1 ? this.from >= pos : this.from > pos) || (side > -1 ? this.to <= pos : this.to < pos)) if (!this.parent()) break;\n    // Then scan down into child nodes as far as possible\n    while (this.enterChild(1, pos, side)) {}\n    return this;\n  }\n  /**\n  Get a [syntax node](#common.SyntaxNode) at the cursor's current\n  position.\n  */\n  get node() {\n    if (!this.buffer) return this._tree;\n    let cache = this.bufferNode,\n      result = null,\n      depth = 0;\n    if (cache && cache.context == this.buffer) {\n      scan: for (let index = this.index, d = this.stack.length; d >= 0;) {\n        for (let c = cache; c; c = c._parent) if (c.index == index) {\n          if (index == this.index) return c;\n          result = c;\n          depth = d + 1;\n          break scan;\n        }\n        index = this.stack[--d];\n      }\n    }\n    for (let i = depth; i < this.stack.length; i++) result = new BufferNode(this.buffer, result, this.stack[i]);\n    return this.bufferNode = new BufferNode(this.buffer, result, this.index);\n  }\n  /**\n  Get the [tree](#common.Tree) that represents the current node, if\n  any. Will return null when the node is in a [tree\n  buffer](#common.TreeBuffer).\n  */\n  get tree() {\n    return this.buffer ? null : this._tree._tree;\n  }\n  /**\n  Iterate over the current node and all its descendants, calling\n  `enter` when entering a node and `leave`, if given, when leaving\n  one. When `enter` returns `false`, any children of that node are\n  skipped, and `leave` isn't called for it.\n  */\n  iterate(enter, leave) {\n    for (let depth = 0;;) {\n      let mustLeave = false;\n      if (this.type.isAnonymous || enter(this) !== false) {\n        if (this.firstChild()) {\n          depth++;\n          continue;\n        }\n        if (!this.type.isAnonymous) mustLeave = true;\n      }\n      for (;;) {\n        if (mustLeave && leave) leave(this);\n        mustLeave = this.type.isAnonymous;\n        if (this.nextSibling()) break;\n        if (!depth) return;\n        this.parent();\n        depth--;\n        mustLeave = true;\n      }\n    }\n  }\n  /**\n  Test whether the current node matches a given context—a sequence\n  of direct parent node names. Empty strings in the context array\n  are treated as wildcards.\n  */\n  matchContext(context) {\n    if (!this.buffer) return matchNodeContext(this.node, context);\n    let {\n        buffer\n      } = this.buffer,\n      {\n        types\n      } = buffer.set;\n    for (let i = context.length - 1, d = this.stack.length - 1; i >= 0; d--) {\n      if (d < 0) return matchNodeContext(this.node, context, i);\n      let type = types[buffer.buffer[this.stack[d]]];\n      if (!type.isAnonymous) {\n        if (context[i] && context[i] != type.name) return false;\n        i--;\n      }\n    }\n    return true;\n  }\n}\nfunction hasChild(tree) {\n  return tree.children.some(ch => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));\n}\nfunction buildTree(data) {\n  var _a;\n  let {\n    buffer,\n    nodeSet,\n    maxBufferLength = DefaultBufferLength,\n    reused = [],\n    minRepeatType = nodeSet.types.length\n  } = data;\n  let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;\n  let types = nodeSet.types;\n  let contextHash = 0,\n    lookAhead = 0;\n  function takeNode(parentStart, minPos, children, positions, inRepeat, depth) {\n    let {\n      id,\n      start,\n      end,\n      size\n    } = cursor;\n    let lookAheadAtStart = lookAhead;\n    while (size < 0) {\n      cursor.next();\n      if (size == -1 /* SpecialRecord.Reuse */) {\n        let node = reused[id];\n        children.push(node);\n        positions.push(start - parentStart);\n        return;\n      } else if (size == -3 /* SpecialRecord.ContextChange */) {\n        // Context change\n        contextHash = id;\n        return;\n      } else if (size == -4 /* SpecialRecord.LookAhead */) {\n        lookAhead = id;\n        return;\n      } else {\n        throw new RangeError(`Unrecognized record size: ${size}`);\n      }\n    }\n    let type = types[id],\n      node,\n      buffer;\n    let startPos = start - parentStart;\n    if (end - start <= maxBufferLength && (buffer = findBufferSize(cursor.pos - minPos, inRepeat))) {\n      // Small enough for a buffer, and no reused nodes inside\n      let data = new Uint16Array(buffer.size - buffer.skip);\n      let endPos = cursor.pos - buffer.size,\n        index = data.length;\n      while (cursor.pos > endPos) index = copyToBuffer(buffer.start, data, index);\n      node = new TreeBuffer(data, end - buffer.start, nodeSet);\n      startPos = buffer.start - parentStart;\n    } else {\n      // Make it a node\n      let endPos = cursor.pos - size;\n      cursor.next();\n      let localChildren = [],\n        localPositions = [];\n      let localInRepeat = id >= minRepeatType ? id : -1;\n      let lastGroup = 0,\n        lastEnd = end;\n      while (cursor.pos > endPos) {\n        if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {\n          if (cursor.end <= lastEnd - maxBufferLength) {\n            makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart);\n            lastGroup = localChildren.length;\n            lastEnd = cursor.end;\n          }\n          cursor.next();\n        } else if (depth > 2500 /* CutOff.Depth */) {\n          takeFlatNode(start, endPos, localChildren, localPositions);\n        } else {\n          takeNode(start, endPos, localChildren, localPositions, localInRepeat, depth + 1);\n        }\n      }\n      if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length) makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart);\n      localChildren.reverse();\n      localPositions.reverse();\n      if (localInRepeat > -1 && lastGroup > 0) {\n        let make = makeBalanced(type);\n        node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);\n      } else {\n        node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end);\n      }\n    }\n    children.push(node);\n    positions.push(startPos);\n  }\n  function takeFlatNode(parentStart, minPos, children, positions) {\n    let nodes = []; // Temporary, inverted array of leaf nodes found, with absolute positions\n    let nodeCount = 0,\n      stopAt = -1;\n    while (cursor.pos > minPos) {\n      let {\n        id,\n        start,\n        end,\n        size\n      } = cursor;\n      if (size > 4) {\n        // Not a leaf\n        cursor.next();\n      } else if (stopAt > -1 && start < stopAt) {\n        break;\n      } else {\n        if (stopAt < 0) stopAt = end - maxBufferLength;\n        nodes.push(id, start, end);\n        nodeCount++;\n        cursor.next();\n      }\n    }\n    if (nodeCount) {\n      let buffer = new Uint16Array(nodeCount * 4);\n      let start = nodes[nodes.length - 2];\n      for (let i = nodes.length - 3, j = 0; i >= 0; i -= 3) {\n        buffer[j++] = nodes[i];\n        buffer[j++] = nodes[i + 1] - start;\n        buffer[j++] = nodes[i + 2] - start;\n        buffer[j++] = j;\n      }\n      children.push(new TreeBuffer(buffer, nodes[2] - start, nodeSet));\n      positions.push(start - parentStart);\n    }\n  }\n  function makeBalanced(type) {\n    return (children, positions, length) => {\n      let lookAhead = 0,\n        lastI = children.length - 1,\n        last,\n        lookAheadProp;\n      if (lastI >= 0 && (last = children[lastI]) instanceof Tree) {\n        if (!lastI && last.type == type && last.length == length) return last;\n        if (lookAheadProp = last.prop(NodeProp.lookAhead)) lookAhead = positions[lastI] + last.length + lookAheadProp;\n      }\n      return makeTree(type, children, positions, length, lookAhead);\n    };\n  }\n  function makeRepeatLeaf(children, positions, base, i, from, to, type, lookAhead) {\n    let localChildren = [],\n      localPositions = [];\n    while (children.length > i) {\n      localChildren.push(children.pop());\n      localPositions.push(positions.pop() + base - from);\n    }\n    children.push(makeTree(nodeSet.types[type], localChildren, localPositions, to - from, lookAhead - to));\n    positions.push(from - base);\n  }\n  function makeTree(type, children, positions, length, lookAhead = 0, props) {\n    if (contextHash) {\n      let pair = [NodeProp.contextHash, contextHash];\n      props = props ? [pair].concat(props) : [pair];\n    }\n    if (lookAhead > 25) {\n      let pair = [NodeProp.lookAhead, lookAhead];\n      props = props ? [pair].concat(props) : [pair];\n    }\n    return new Tree(type, children, positions, length, props);\n  }\n  function findBufferSize(maxSize, inRepeat) {\n    // Scan through the buffer to find previous siblings that fit\n    // together in a TreeBuffer, and don't contain any reused nodes\n    // (which can't be stored in a buffer).\n    // If `inRepeat` is > -1, ignore node boundaries of that type for\n    // nesting, but make sure the end falls either at the start\n    // (`maxSize`) or before such a node.\n    let fork = cursor.fork();\n    let size = 0,\n      start = 0,\n      skip = 0,\n      minStart = fork.end - maxBufferLength;\n    let result = {\n      size: 0,\n      start: 0,\n      skip: 0\n    };\n    scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos;) {\n      let nodeSize = fork.size;\n      // Pretend nested repeat nodes of the same type don't exist\n      if (fork.id == inRepeat && nodeSize >= 0) {\n        // Except that we store the current state as a valid return\n        // value.\n        result.size = size;\n        result.start = start;\n        result.skip = skip;\n        skip += 4;\n        size += 4;\n        fork.next();\n        continue;\n      }\n      let startPos = fork.pos - nodeSize;\n      if (nodeSize < 0 || startPos < minPos || fork.start < minStart) break;\n      let localSkipped = fork.id >= minRepeatType ? 4 : 0;\n      let nodeStart = fork.start;\n      fork.next();\n      while (fork.pos > startPos) {\n        if (fork.size < 0) {\n          if (fork.size == -3 /* SpecialRecord.ContextChange */) localSkipped += 4;else break scan;\n        } else if (fork.id >= minRepeatType) {\n          localSkipped += 4;\n        }\n        fork.next();\n      }\n      start = nodeStart;\n      size += nodeSize;\n      skip += localSkipped;\n    }\n    if (inRepeat < 0 || size == maxSize) {\n      result.size = size;\n      result.start = start;\n      result.skip = skip;\n    }\n    return result.size > 4 ? result : undefined;\n  }\n  function copyToBuffer(bufferStart, buffer, index) {\n    let {\n      id,\n      start,\n      end,\n      size\n    } = cursor;\n    cursor.next();\n    if (size >= 0 && id < minRepeatType) {\n      let startIndex = index;\n      if (size > 4) {\n        let endPos = cursor.pos - (size - 4);\n        while (cursor.pos > endPos) index = copyToBuffer(bufferStart, buffer, index);\n      }\n      buffer[--index] = startIndex;\n      buffer[--index] = end - bufferStart;\n      buffer[--index] = start - bufferStart;\n      buffer[--index] = id;\n    } else if (size == -3 /* SpecialRecord.ContextChange */) {\n      contextHash = id;\n    } else if (size == -4 /* SpecialRecord.LookAhead */) {\n      lookAhead = id;\n    }\n    return index;\n  }\n  let children = [],\n    positions = [];\n  while (cursor.pos > 0) takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1, 0);\n  let length = (_a = data.length) !== null && _a !== void 0 ? _a : children.length ? positions[0] + children[0].length : 0;\n  return new Tree(types[data.topID], children.reverse(), positions.reverse(), length);\n}\nconst nodeSizeCache = new WeakMap();\nfunction nodeSize(balanceType, node) {\n  if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType) return 1;\n  let size = nodeSizeCache.get(node);\n  if (size == null) {\n    size = 1;\n    for (let child of node.children) {\n      if (child.type != balanceType || !(child instanceof Tree)) {\n        size = 1;\n        break;\n      }\n      size += nodeSize(balanceType, child);\n    }\n    nodeSizeCache.set(node, size);\n  }\n  return size;\n}\nfunction balanceRange(\n// The type the balanced tree's inner nodes.\nbalanceType,\n// The direct children and their positions\nchildren, positions,\n// The index range in children/positions to use\nfrom, to,\n// The start position of the nodes, relative to their parent.\nstart,\n// Length of the outer node\nlength,\n// Function to build the top node of the balanced tree\nmkTop,\n// Function to build internal nodes for the balanced tree\nmkTree) {\n  let total = 0;\n  for (let i = from; i < to; i++) total += nodeSize(balanceType, children[i]);\n  let maxChild = Math.ceil(total * 1.5 / 8 /* Balance.BranchFactor */);\n  let localChildren = [],\n    localPositions = [];\n  function divide(children, positions, from, to, offset) {\n    for (let i = from; i < to;) {\n      let groupFrom = i,\n        groupStart = positions[i],\n        groupSize = nodeSize(balanceType, children[i]);\n      i++;\n      for (; i < to; i++) {\n        let nextSize = nodeSize(balanceType, children[i]);\n        if (groupSize + nextSize >= maxChild) break;\n        groupSize += nextSize;\n      }\n      if (i == groupFrom + 1) {\n        if (groupSize > maxChild) {\n          let only = children[groupFrom]; // Only trees can have a size > 1\n          divide(only.children, only.positions, 0, only.children.length, positions[groupFrom] + offset);\n          continue;\n        }\n        localChildren.push(children[groupFrom]);\n      } else {\n        let length = positions[i - 1] + children[i - 1].length - groupStart;\n        localChildren.push(balanceRange(balanceType, children, positions, groupFrom, i, groupStart, length, null, mkTree));\n      }\n      localPositions.push(groupStart + offset - start);\n    }\n  }\n  divide(children, positions, from, to, 0);\n  return (mkTop || mkTree)(localChildren, localPositions, length);\n}\n/**\nProvides a way to associate values with pieces of trees. As long\nas that part of the tree is reused, the associated values can be\nretrieved from an updated tree.\n*/\nclass NodeWeakMap {\n  constructor() {\n    this.map = new WeakMap();\n  }\n  setBuffer(buffer, index, value) {\n    let inner = this.map.get(buffer);\n    if (!inner) this.map.set(buffer, inner = new Map());\n    inner.set(index, value);\n  }\n  getBuffer(buffer, index) {\n    let inner = this.map.get(buffer);\n    return inner && inner.get(index);\n  }\n  /**\n  Set the value for this syntax node.\n  */\n  set(node, value) {\n    if (node instanceof BufferNode) this.setBuffer(node.context.buffer, node.index, value);else if (node instanceof TreeNode) this.map.set(node.tree, value);\n  }\n  /**\n  Retrieve value for this syntax node, if it exists in the map.\n  */\n  get(node) {\n    return node instanceof BufferNode ? this.getBuffer(node.context.buffer, node.index) : node instanceof TreeNode ? this.map.get(node.tree) : undefined;\n  }\n  /**\n  Set the value for the node that a cursor currently points to.\n  */\n  cursorSet(cursor, value) {\n    if (cursor.buffer) this.setBuffer(cursor.buffer.buffer, cursor.index, value);else this.map.set(cursor.tree, value);\n  }\n  /**\n  Retrieve the value for the node that a cursor currently points\n  to.\n  */\n  cursorGet(cursor) {\n    return cursor.buffer ? this.getBuffer(cursor.buffer.buffer, cursor.index) : this.map.get(cursor.tree);\n  }\n}\n\n/**\nTree fragments are used during [incremental\nparsing](#common.Parser.startParse) to track parts of old trees\nthat can be reused in a new parse. An array of fragments is used\nto track regions of an old tree whose nodes might be reused in new\nparses. Use the static\n[`applyChanges`](#common.TreeFragment^applyChanges) method to\nupdate fragments for document changes.\n*/\nclass TreeFragment {\n  /**\n  Construct a tree fragment. You'll usually want to use\n  [`addTree`](#common.TreeFragment^addTree) and\n  [`applyChanges`](#common.TreeFragment^applyChanges) instead of\n  calling this directly.\n  */\n  constructor(\n  /**\n  The start of the unchanged range pointed to by this fragment.\n  This refers to an offset in the _updated_ document (as opposed\n  to the original tree).\n  */\n  from,\n  /**\n  The end of the unchanged range.\n  */\n  to,\n  /**\n  The tree that this fragment is based on.\n  */\n  tree,\n  /**\n  The offset between the fragment's tree and the document that\n  this fragment can be used against. Add this when going from\n  document to tree positions, subtract it to go from tree to\n  document positions.\n  */\n  offset, openStart = false, openEnd = false) {\n    this.from = from;\n    this.to = to;\n    this.tree = tree;\n    this.offset = offset;\n    this.open = (openStart ? 1 /* Open.Start */ : 0) | (openEnd ? 2 /* Open.End */ : 0);\n  }\n  /**\n  Whether the start of the fragment represents the start of a\n  parse, or the end of a change. (In the second case, it may not\n  be safe to reuse some nodes at the start, depending on the\n  parsing algorithm.)\n  */\n  get openStart() {\n    return (this.open & 1 /* Open.Start */) > 0;\n  }\n  /**\n  Whether the end of the fragment represents the end of a\n  full-document parse, or the start of a change.\n  */\n  get openEnd() {\n    return (this.open & 2 /* Open.End */) > 0;\n  }\n  /**\n  Create a set of fragments from a freshly parsed tree, or update\n  an existing set of fragments by replacing the ones that overlap\n  with a tree with content from the new tree. When `partial` is\n  true, the parse is treated as incomplete, and the resulting\n  fragment has [`openEnd`](#common.TreeFragment.openEnd) set to\n  true.\n  */\n  static addTree(tree, fragments = [], partial = false) {\n    let result = [new TreeFragment(0, tree.length, tree, 0, false, partial)];\n    for (let f of fragments) if (f.to > tree.length) result.push(f);\n    return result;\n  }\n  /**\n  Apply a set of edits to an array of fragments, removing or\n  splitting fragments as necessary to remove edited ranges, and\n  adjusting offsets for fragments that moved.\n  */\n  static applyChanges(fragments, changes, minGap = 128) {\n    if (!changes.length) return fragments;\n    let result = [];\n    let fI = 1,\n      nextF = fragments.length ? fragments[0] : null;\n    for (let cI = 0, pos = 0, off = 0;; cI++) {\n      let nextC = cI < changes.length ? changes[cI] : null;\n      let nextPos = nextC ? nextC.fromA : 1e9;\n      if (nextPos - pos >= minGap) while (nextF && nextF.from < nextPos) {\n        let cut = nextF;\n        if (pos >= cut.from || nextPos <= cut.to || off) {\n          let fFrom = Math.max(cut.from, pos) - off,\n            fTo = Math.min(cut.to, nextPos) - off;\n          cut = fFrom >= fTo ? null : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);\n        }\n        if (cut) result.push(cut);\n        if (nextF.to > nextPos) break;\n        nextF = fI < fragments.length ? fragments[fI++] : null;\n      }\n      if (!nextC) break;\n      pos = nextC.toA;\n      off = nextC.toA - nextC.toB;\n    }\n    return result;\n  }\n}\n/**\nA superclass that parsers should extend.\n*/\nclass Parser {\n  /**\n  Start a parse, returning a [partial parse](#common.PartialParse)\n  object. [`fragments`](#common.TreeFragment) can be passed in to\n  make the parse incremental.\n  \n  By default, the entire input is parsed. You can pass `ranges`,\n  which should be a sorted array of non-empty, non-overlapping\n  ranges, to parse only those ranges. The tree returned in that\n  case will start at `ranges[0].from`.\n  */\n  startParse(input, fragments, ranges) {\n    if (typeof input == \"string\") input = new StringInput(input);\n    ranges = !ranges ? [new Range(0, input.length)] : ranges.length ? ranges.map(r => new Range(r.from, r.to)) : [new Range(0, 0)];\n    return this.createParse(input, fragments || [], ranges);\n  }\n  /**\n  Run a full parse, returning the resulting tree.\n  */\n  parse(input, fragments, ranges) {\n    let parse = this.startParse(input, fragments, ranges);\n    for (;;) {\n      let done = parse.advance();\n      if (done) return done;\n    }\n  }\n}\nclass StringInput {\n  constructor(string) {\n    this.string = string;\n  }\n  get length() {\n    return this.string.length;\n  }\n  chunk(from) {\n    return this.string.slice(from);\n  }\n  get lineChunks() {\n    return false;\n  }\n  read(from, to) {\n    return this.string.slice(from, to);\n  }\n}\n\n/**\nCreate a parse wrapper that, after the inner parse completes,\nscans its tree for mixed language regions with the `nest`\nfunction, runs the resulting [inner parses](#common.NestedParse),\nand then [mounts](#common.NodeProp^mounted) their results onto the\ntree.\n*/\nfunction parseMixed(nest) {\n  return (parse, input, fragments, ranges) => new MixedParse(parse, nest, input, fragments, ranges);\n}\nclass InnerParse {\n  constructor(parser, parse, overlay, target, from) {\n    this.parser = parser;\n    this.parse = parse;\n    this.overlay = overlay;\n    this.target = target;\n    this.from = from;\n  }\n}\nfunction checkRanges(ranges) {\n  if (!ranges.length || ranges.some(r => r.from >= r.to)) throw new RangeError(\"Invalid inner parse ranges given: \" + JSON.stringify(ranges));\n}\nclass ActiveOverlay {\n  constructor(parser, predicate, mounts, index, start, target, prev) {\n    this.parser = parser;\n    this.predicate = predicate;\n    this.mounts = mounts;\n    this.index = index;\n    this.start = start;\n    this.target = target;\n    this.prev = prev;\n    this.depth = 0;\n    this.ranges = [];\n  }\n}\nconst stoppedInner = new NodeProp({\n  perNode: true\n});\nclass MixedParse {\n  constructor(base, nest, input, fragments, ranges) {\n    this.nest = nest;\n    this.input = input;\n    this.fragments = fragments;\n    this.ranges = ranges;\n    this.inner = [];\n    this.innerDone = 0;\n    this.baseTree = null;\n    this.stoppedAt = null;\n    this.baseParse = base;\n  }\n  advance() {\n    if (this.baseParse) {\n      let done = this.baseParse.advance();\n      if (!done) return null;\n      this.baseParse = null;\n      this.baseTree = done;\n      this.startInner();\n      if (this.stoppedAt != null) for (let inner of this.inner) inner.parse.stopAt(this.stoppedAt);\n    }\n    if (this.innerDone == this.inner.length) {\n      let result = this.baseTree;\n      if (this.stoppedAt != null) result = new Tree(result.type, result.children, result.positions, result.length, result.propValues.concat([[stoppedInner, this.stoppedAt]]));\n      return result;\n    }\n    let inner = this.inner[this.innerDone],\n      done = inner.parse.advance();\n    if (done) {\n      this.innerDone++;\n      // This is a somewhat dodgy but super helpful hack where we\n      // patch up nodes created by the inner parse (and thus\n      // presumably not aliased anywhere else) to hold the information\n      // about the inner parse.\n      let props = Object.assign(Object.create(null), inner.target.props);\n      props[NodeProp.mounted.id] = new MountedTree(done, inner.overlay, inner.parser);\n      inner.target.props = props;\n    }\n    return null;\n  }\n  get parsedPos() {\n    if (this.baseParse) return 0;\n    let pos = this.input.length;\n    for (let i = this.innerDone; i < this.inner.length; i++) {\n      if (this.inner[i].from < pos) pos = Math.min(pos, this.inner[i].parse.parsedPos);\n    }\n    return pos;\n  }\n  stopAt(pos) {\n    this.stoppedAt = pos;\n    if (this.baseParse) this.baseParse.stopAt(pos);else for (let i = this.innerDone; i < this.inner.length; i++) this.inner[i].parse.stopAt(pos);\n  }\n  startInner() {\n    let fragmentCursor = new FragmentCursor(this.fragments);\n    let overlay = null;\n    let covered = null;\n    let cursor = new TreeCursor(new TreeNode(this.baseTree, this.ranges[0].from, 0, null), IterMode.IncludeAnonymous | IterMode.IgnoreMounts);\n    scan: for (let nest, isCovered;;) {\n      let enter = true,\n        range;\n      if (this.stoppedAt != null && cursor.from >= this.stoppedAt) {\n        enter = false;\n      } else if (fragmentCursor.hasNode(cursor)) {\n        if (overlay) {\n          let match = overlay.mounts.find(m => m.frag.from <= cursor.from && m.frag.to >= cursor.to && m.mount.overlay);\n          if (match) for (let r of match.mount.overlay) {\n            let from = r.from + match.pos,\n              to = r.to + match.pos;\n            if (from >= cursor.from && to <= cursor.to && !overlay.ranges.some(r => r.from < to && r.to > from)) overlay.ranges.push({\n              from,\n              to\n            });\n          }\n        }\n        enter = false;\n      } else if (covered && (isCovered = checkCover(covered.ranges, cursor.from, cursor.to))) {\n        enter = isCovered != 2 /* Cover.Full */;\n      } else if (!cursor.type.isAnonymous && (nest = this.nest(cursor, this.input)) && (cursor.from < cursor.to || !nest.overlay)) {\n        if (!cursor.tree) materialize(cursor);\n        let oldMounts = fragmentCursor.findMounts(cursor.from, nest.parser);\n        if (typeof nest.overlay == \"function\") {\n          overlay = new ActiveOverlay(nest.parser, nest.overlay, oldMounts, this.inner.length, cursor.from, cursor.tree, overlay);\n        } else {\n          let ranges = punchRanges(this.ranges, nest.overlay || (cursor.from < cursor.to ? [new Range(cursor.from, cursor.to)] : []));\n          if (ranges.length) checkRanges(ranges);\n          if (ranges.length || !nest.overlay) this.inner.push(new InnerParse(nest.parser, ranges.length ? nest.parser.startParse(this.input, enterFragments(oldMounts, ranges), ranges) : nest.parser.startParse(\"\"), nest.overlay ? nest.overlay.map(r => new Range(r.from - cursor.from, r.to - cursor.from)) : null, cursor.tree, ranges.length ? ranges[0].from : cursor.from));\n          if (!nest.overlay) enter = false;else if (ranges.length) covered = {\n            ranges,\n            depth: 0,\n            prev: covered\n          };\n        }\n      } else if (overlay && (range = overlay.predicate(cursor))) {\n        if (range === true) range = new Range(cursor.from, cursor.to);\n        if (range.from < range.to) overlay.ranges.push(range);\n      }\n      if (enter && cursor.firstChild()) {\n        if (overlay) overlay.depth++;\n        if (covered) covered.depth++;\n      } else {\n        for (;;) {\n          if (cursor.nextSibling()) break;\n          if (!cursor.parent()) break scan;\n          if (overlay && ! --overlay.depth) {\n            let ranges = punchRanges(this.ranges, overlay.ranges);\n            if (ranges.length) {\n              checkRanges(ranges);\n              this.inner.splice(overlay.index, 0, new InnerParse(overlay.parser, overlay.parser.startParse(this.input, enterFragments(overlay.mounts, ranges), ranges), overlay.ranges.map(r => new Range(r.from - overlay.start, r.to - overlay.start)), overlay.target, ranges[0].from));\n            }\n            overlay = overlay.prev;\n          }\n          if (covered && ! --covered.depth) covered = covered.prev;\n        }\n      }\n    }\n  }\n}\nfunction checkCover(covered, from, to) {\n  for (let range of covered) {\n    if (range.from >= to) break;\n    if (range.to > from) return range.from <= from && range.to >= to ? 2 /* Cover.Full */ : 1 /* Cover.Partial */;\n  }\n  return 0 /* Cover.None */;\n}\n// Take a piece of buffer and convert it into a stand-alone\n// TreeBuffer.\nfunction sliceBuf(buf, startI, endI, nodes, positions, off) {\n  if (startI < endI) {\n    let from = buf.buffer[startI + 1];\n    nodes.push(buf.slice(startI, endI, from));\n    positions.push(from - off);\n  }\n}\n// This function takes a node that's in a buffer, and converts it, and\n// its parent buffer nodes, into a Tree. This is again acting on the\n// assumption that the trees and buffers have been constructed by the\n// parse that was ran via the mix parser, and thus aren't shared with\n// any other code, making violations of the immutability safe.\nfunction materialize(cursor) {\n  let {\n      node\n    } = cursor,\n    stack = [];\n  let buffer = node.context.buffer;\n  // Scan up to the nearest tree\n  do {\n    stack.push(cursor.index);\n    cursor.parent();\n  } while (!cursor.tree);\n  // Find the index of the buffer in that tree\n  let base = cursor.tree,\n    i = base.children.indexOf(buffer);\n  let buf = base.children[i],\n    b = buf.buffer,\n    newStack = [i];\n  // Split a level in the buffer, putting the nodes before and after\n  // the child that contains `node` into new buffers.\n  function split(startI, endI, type, innerOffset, length, stackPos) {\n    let targetI = stack[stackPos];\n    let children = [],\n      positions = [];\n    sliceBuf(buf, startI, targetI, children, positions, innerOffset);\n    let from = b[targetI + 1],\n      to = b[targetI + 2];\n    newStack.push(children.length);\n    let child = stackPos ? split(targetI + 4, b[targetI + 3], buf.set.types[b[targetI]], from, to - from, stackPos - 1) : node.toTree();\n    children.push(child);\n    positions.push(from - innerOffset);\n    sliceBuf(buf, b[targetI + 3], endI, children, positions, innerOffset);\n    return new Tree(type, children, positions, length);\n  }\n  base.children[i] = split(0, b.length, NodeType.none, 0, buf.length, stack.length - 1);\n  // Move the cursor back to the target node\n  for (let index of newStack) {\n    let tree = cursor.tree.children[index],\n      pos = cursor.tree.positions[index];\n    cursor.yield(new TreeNode(tree, pos + cursor.from, index, cursor._tree));\n  }\n}\nclass StructureCursor {\n  constructor(root, offset) {\n    this.offset = offset;\n    this.done = false;\n    this.cursor = root.cursor(IterMode.IncludeAnonymous | IterMode.IgnoreMounts);\n  }\n  // Move to the first node (in pre-order) that starts at or after `pos`.\n  moveTo(pos) {\n    let {\n        cursor\n      } = this,\n      p = pos - this.offset;\n    while (!this.done && cursor.from < p) {\n      if (cursor.to >= pos && cursor.enter(p, 1, IterMode.IgnoreOverlays | IterMode.ExcludeBuffers)) ;else if (!cursor.next(false)) this.done = true;\n    }\n  }\n  hasNode(cursor) {\n    this.moveTo(cursor.from);\n    if (!this.done && this.cursor.from + this.offset == cursor.from && this.cursor.tree) {\n      for (let tree = this.cursor.tree;;) {\n        if (tree == cursor.tree) return true;\n        if (tree.children.length && tree.positions[0] == 0 && tree.children[0] instanceof Tree) tree = tree.children[0];else break;\n      }\n    }\n    return false;\n  }\n}\nclass FragmentCursor {\n  constructor(fragments) {\n    var _a;\n    this.fragments = fragments;\n    this.curTo = 0;\n    this.fragI = 0;\n    if (fragments.length) {\n      let first = this.curFrag = fragments[0];\n      this.curTo = (_a = first.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : first.to;\n      this.inner = new StructureCursor(first.tree, -first.offset);\n    } else {\n      this.curFrag = this.inner = null;\n    }\n  }\n  hasNode(node) {\n    while (this.curFrag && node.from >= this.curTo) this.nextFrag();\n    return this.curFrag && this.curFrag.from <= node.from && this.curTo >= node.to && this.inner.hasNode(node);\n  }\n  nextFrag() {\n    var _a;\n    this.fragI++;\n    if (this.fragI == this.fragments.length) {\n      this.curFrag = this.inner = null;\n    } else {\n      let frag = this.curFrag = this.fragments[this.fragI];\n      this.curTo = (_a = frag.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : frag.to;\n      this.inner = new StructureCursor(frag.tree, -frag.offset);\n    }\n  }\n  findMounts(pos, parser) {\n    var _a;\n    let result = [];\n    if (this.inner) {\n      this.inner.cursor.moveTo(pos, 1);\n      for (let pos = this.inner.cursor.node; pos; pos = pos.parent) {\n        let mount = (_a = pos.tree) === null || _a === void 0 ? void 0 : _a.prop(NodeProp.mounted);\n        if (mount && mount.parser == parser) {\n          for (let i = this.fragI; i < this.fragments.length; i++) {\n            let frag = this.fragments[i];\n            if (frag.from >= pos.to) break;\n            if (frag.tree == this.curFrag.tree) result.push({\n              frag,\n              pos: pos.from - frag.offset,\n              mount\n            });\n          }\n        }\n      }\n    }\n    return result;\n  }\n}\nfunction punchRanges(outer, ranges) {\n  let copy = null,\n    current = ranges;\n  for (let i = 1, j = 0; i < outer.length; i++) {\n    let gapFrom = outer[i - 1].to,\n      gapTo = outer[i].from;\n    for (; j < current.length; j++) {\n      let r = current[j];\n      if (r.from >= gapTo) break;\n      if (r.to <= gapFrom) continue;\n      if (!copy) current = copy = ranges.slice();\n      if (r.from < gapFrom) {\n        copy[j] = new Range(r.from, gapFrom);\n        if (r.to > gapTo) copy.splice(j + 1, 0, new Range(gapTo, r.to));\n      } else if (r.to > gapTo) {\n        copy[j--] = new Range(gapTo, r.to);\n      } else {\n        copy.splice(j--, 1);\n      }\n    }\n  }\n  return current;\n}\nfunction findCoverChanges(a, b, from, to) {\n  let iA = 0,\n    iB = 0,\n    inA = false,\n    inB = false,\n    pos = -1e9;\n  let result = [];\n  for (;;) {\n    let nextA = iA == a.length ? 1e9 : inA ? a[iA].to : a[iA].from;\n    let nextB = iB == b.length ? 1e9 : inB ? b[iB].to : b[iB].from;\n    if (inA != inB) {\n      let start = Math.max(pos, from),\n        end = Math.min(nextA, nextB, to);\n      if (start < end) result.push(new Range(start, end));\n    }\n    pos = Math.min(nextA, nextB);\n    if (pos == 1e9) break;\n    if (nextA == pos) {\n      if (!inA) inA = true;else {\n        inA = false;\n        iA++;\n      }\n    }\n    if (nextB == pos) {\n      if (!inB) inB = true;else {\n        inB = false;\n        iB++;\n      }\n    }\n  }\n  return result;\n}\n// Given a number of fragments for the outer tree, and a set of ranges\n// to parse, find fragments for inner trees mounted around those\n// ranges, if any.\nfunction enterFragments(mounts, ranges) {\n  let result = [];\n  for (let {\n    pos,\n    mount,\n    frag\n  } of mounts) {\n    let startPos = pos + (mount.overlay ? mount.overlay[0].from : 0),\n      endPos = startPos + mount.tree.length;\n    let from = Math.max(frag.from, startPos),\n      to = Math.min(frag.to, endPos);\n    if (mount.overlay) {\n      let overlay = mount.overlay.map(r => new Range(r.from + pos, r.to + pos));\n      let changes = findCoverChanges(ranges, overlay, from, to);\n      for (let i = 0, pos = from;; i++) {\n        let last = i == changes.length,\n          end = last ? to : changes[i].from;\n        if (end > pos) result.push(new TreeFragment(pos, end, mount.tree, -startPos, frag.from >= pos || frag.openStart, frag.to <= end || frag.openEnd));\n        if (last) break;\n        pos = changes[i].to;\n      }\n    } else {\n      result.push(new TreeFragment(from, to, mount.tree, -startPos, frag.from >= startPos || frag.openStart, frag.to <= endPos || frag.openEnd));\n    }\n  }\n  return result;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BsZXplci9jb21tb24vZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0EsTUFBTUEsbUJBQW1CLEdBQUcsSUFBSTtBQUNoQyxJQUFJQyxVQUFVLEdBQUcsQ0FBQztBQUNsQixNQUFNQyxLQUFLLENBQUM7RUFDUkMsV0FBV0EsQ0FBQ0MsSUFBSSxFQUFFQyxFQUFFLEVBQUU7SUFDbEIsSUFBSSxDQUFDRCxJQUFJLEdBQUdBLElBQUk7SUFDaEIsSUFBSSxDQUFDQyxFQUFFLEdBQUdBLEVBQUU7RUFDaEI7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNQyxRQUFRLENBQUM7RUFDWDtBQUNKO0FBQ0E7RUFDSUgsV0FBV0EsQ0FBQ0ksTUFBTSxHQUFHLENBQUMsQ0FBQyxFQUFFO0lBQ3JCLElBQUksQ0FBQ0MsRUFBRSxHQUFHUCxVQUFVLEVBQUU7SUFDdEIsSUFBSSxDQUFDUSxPQUFPLEdBQUcsQ0FBQyxDQUFDRixNQUFNLENBQUNFLE9BQU87SUFDL0IsSUFBSSxDQUFDQyxXQUFXLEdBQUdILE1BQU0sQ0FBQ0csV0FBVyxLQUFLLE1BQU07TUFDNUMsTUFBTSxJQUFJQyxLQUFLLENBQUMsc0RBQXNELENBQUM7SUFDM0UsQ0FBQyxDQUFDO0VBQ047RUFDQTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7RUFDSUMsR0FBR0EsQ0FBQ0MsS0FBSyxFQUFFO0lBQ1AsSUFBSSxJQUFJLENBQUNKLE9BQU8sRUFDWixNQUFNLElBQUlLLFVBQVUsQ0FBQyx3Q0FBd0MsQ0FBQztJQUNsRSxJQUFJLE9BQU9ELEtBQUssSUFBSSxVQUFVLEVBQzFCQSxLQUFLLEdBQUdFLFFBQVEsQ0FBQ0YsS0FBSyxDQUFDQSxLQUFLLENBQUM7SUFDakMsT0FBUUcsSUFBSSxJQUFLO01BQ2IsSUFBSUMsTUFBTSxHQUFHSixLQUFLLENBQUNHLElBQUksQ0FBQztN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QUFNLElBQUk0RyxJQUFJLENBQUMzRCxPQUFPLENBQUMsQ0FBQztJQUM5STtFQUNKO0VBQ0EsT0FBTzVQLE1BQU07QUFDakIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yaWRnZS1jb2RlbWlycm9yLy4uLy4uL25vZGVfbW9kdWxlcy9AbGV6ZXIvY29tbW9uL2Rpc3QvaW5kZXguanM/ODQ2MyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcblRoZSBkZWZhdWx0IG1heGltdW0gbGVuZ3RoIG9mIGEgYFRyZWVCdWZmZXJgIG5vZGUuXG4qL1xuY29uc3QgRGVmYXVsdEJ1ZmZlckxlbmd0aCA9IDEwMjQ7XG5sZXQgbmV4dFByb3BJRCA9IDA7XG5jbGFzcyBSYW5nZSB7XG4gICAgY29uc3RydWN0b3IoZnJvbSwgdG8pIHtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgIH1cbn1cbi8qKlxuRWFjaCBbbm9kZSB0eXBlXSgjY29tbW9uLk5vZGVUeXBlKSBvciBbaW5kaXZpZHVhbCB0cmVlXSgjY29tbW9uLlRyZWUpXG5jYW4gaGF2ZSBtZXRhZGF0YSBhc3NvY2lhdGVkIHdpdGggaXQgaW4gcHJvcHMuIEluc3RhbmNlcyBvZiB0aGlzXG5jbGFzcyByZXByZXNlbnQgcHJvcCBuYW1lcy5cbiovXG5jbGFzcyBOb2RlUHJvcCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgbmV3IG5vZGUgcHJvcCB0eXBlLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICAgICAgdGhpcy5pZCA9IG5leHRQcm9wSUQrKztcbiAgICAgICAgdGhpcy5wZXJOb2RlID0gISFjb25maWcucGVyTm9kZTtcbiAgICAgICAgdGhpcy5kZXNlcmlhbGl6ZSA9IGNvbmZpZy5kZXNlcmlhbGl6ZSB8fCAoKCkgPT4ge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhpcyBub2RlIHR5cGUgZG9lc24ndCBkZWZpbmUgYSBkZXNlcmlhbGl6ZSBmdW5jdGlvblwiKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFRoaXMgaXMgbWVhbnQgdG8gYmUgdXNlZCB3aXRoXG4gICAgW2BOb2RlU2V0LmV4dGVuZGBdKCNjb21tb24uTm9kZVNldC5leHRlbmQpIG9yXG4gICAgW2BMUlBhcnNlci5jb25maWd1cmVgXSgjbHIuUGFyc2VyQ29uZmlnLnByb3BzKSB0byBjb21wdXRlXG4gICAgcHJvcCB2YWx1ZXMgZm9yIGVhY2ggbm9kZSB0eXBlIGluIHRoZSBzZXQuIFRha2VzIGEgW21hdGNoXG4gICAgb2JqZWN0XSgjY29tbW9uLk5vZGVUeXBlXm1hdGNoKSBvciBmdW5jdGlvbiB0aGF0IHJldHVybnMgdW5kZWZpbmVkXG4gICAgaWYgdGhlIG5vZGUgdHlwZSBkb2Vzbid0IGdldCB0aGlzIHByb3AsIGFuZCB0aGUgcHJvcCdzIHZhbHVlIGlmXG4gICAgaXQgZG9lcy5cbiAgICAqL1xuICAgIGFkZChtYXRjaCkge1xuICAgICAgICBpZiAodGhpcy5wZXJOb2RlKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDYW4ndCBhZGQgcGVyLW5vZGUgcHJvcHMgdG8gbm9kZSB0eXBlc1wiKTtcbiAgICAgICAgaWYgKHR5cGVvZiBtYXRjaCAhPSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgICBtYXRjaCA9IE5vZGVUeXBlLm1hdGNoKG1hdGNoKTtcbiAgICAgICAgcmV0dXJuICh0eXBlKSA9PiB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gbWF0Y2godHlwZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyBudWxsIDogW3RoaXMsIHJlc3VsdF07XG4gICAgICAgIH07XG4gICAgfVxufVxuLyoqXG5Qcm9wIHRoYXQgaXMgdXNlZCB0byBkZXNjcmliZSBtYXRjaGluZyBkZWxpbWl0ZXJzLiBGb3Igb3BlbmluZ1xuZGVsaW1pdGVycywgdGhpcyBob2xkcyBhbiBhcnJheSBvZiBub2RlIG5hbWVzICh3cml0dGVuIGFzIGFcbnNwYWNlLXNlcGFyYXRlZCBzdHJpbmcgd2hlbiBkZWNsYXJpbmcgdGhpcyBwcm9wIGluIGEgZ3JhbW1hcilcbmZvciB0aGUgbm9kZSB0eXBlcyBvZiBjbG9zaW5nIGRlbGltaXRlcnMgdGhhdCBtYXRjaCBpdC5cbiovXG5Ob2RlUHJvcC5jbG9zZWRCeSA9IG5ldyBOb2RlUHJvcCh7IGRlc2VyaWFsaXplOiBzdHIgPT4gc3RyLnNwbGl0KFwiIFwiKSB9KTtcbi8qKlxuVGhlIGludmVyc2Ugb2YgW2BjbG9zZWRCeWBdKCNjb21tb24uTm9kZVByb3BeY2xvc2VkQnkpLiBUaGlzIGlzXG5hdHRhY2hlZCB0byBjbG9zaW5nIGRlbGltaXRlcnMsIGhvbGRpbmcgYW4gYXJyYXkgb2Ygbm9kZSBuYW1lc1xub2YgdHlwZXMgb2YgbWF0Y2hpbmcgb3BlbmluZyBkZWxpbWl0ZXJzLlxuKi9cbk5vZGVQcm9wLm9wZW5lZEJ5ID0gbmV3IE5vZGVQcm9wKHsgZGVzZXJpYWxpemU6IHN0ciA9PiBzdHIuc3BsaXQoXCIgXCIpIH0pO1xuLyoqXG5Vc2VkIHRvIGFzc2lnbiBub2RlIHR5cGVzIHRvIGdyb3VwcyAoZm9yIGV4YW1wbGUsIGFsbCBub2RlXG50eXBlcyB0aGF0IHJlcHJlc2VudCBhbiBleHByZXNzaW9uIGNvdWxkIGJlIHRhZ2dlZCB3aXRoIGFuXG5gXCJFeHByZXNzaW9uXCJgIGdyb3VwKS5cbiovXG5Ob2RlUHJvcC5ncm91cCA9IG5ldyBOb2RlUHJvcCh7IGRlc2VyaWFsaXplOiBzdHIgPT4gc3RyLnNwbGl0KFwiIFwiKSB9KTtcbi8qKlxuQXR0YWNoZWQgdG8gbm9kZXMgdG8gaW5kaWNhdGUgdGhlc2Ugc2hvdWxkIGJlXG5bZGlzcGxheWVkXShodHRwczovL2NvZGVtaXJyb3IubmV0L2RvY3MvcmVmLyNsYW5ndWFnZS5zeW50YXhUcmVlKVxuaW4gYSBiaWRpcmVjdGlvbmFsIHRleHQgaXNvbGF0ZSwgc28gdGhhdCBkaXJlY3Rpb24tbmV1dHJhbFxuY2hhcmFjdGVycyBvbiB0aGVpciBzaWRlcyBkb24ndCBpbmNvcnJlY3RseSBnZXQgYXNzb2NpYXRlZCB3aXRoXG5zdXJyb3VuZGluZyB0ZXh0LiBZb3UnbGwgZ2VuZXJhbGx5IHdhbnQgdG8gc2V0IHRoaXMgZm9yIG5vZGVzXG50aGF0IGNvbnRhaW4gYXJiaXRyYXJ5IHRleHQsIGxpa2Ugc3RyaW5ncyBhbmQgY29tbWVudHMsIGFuZCBmb3Jcbm5vZGVzIHRoYXQgYXBwZWFyIF9pbnNpZGVfIGFyYml0cmFyeSB0ZXh0LCBsaWtlIEhUTUwgdGFncy4gV2hlblxubm90IGdpdmVuIGEgdmFsdWUsIGluIGEgZ3JhbW1hciBkZWNsYXJhdGlvbiwgZGVmYXVsdHMgdG9cbmBcImF1dG9cImAuXG4qL1xuTm9kZVByb3AuaXNvbGF0ZSA9IG5ldyBOb2RlUHJvcCh7IGRlc2VyaWFsaXplOiB2YWx1ZSA9PiB7XG4gICAgICAgIGlmICh2YWx1ZSAmJiB2YWx1ZSAhPSBcInJ0bFwiICYmIHZhbHVlICE9IFwibHRyXCIgJiYgdmFsdWUgIT0gXCJhdXRvXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgdmFsdWUgZm9yIGlzb2xhdGU6IFwiICsgdmFsdWUpO1xuICAgICAgICByZXR1cm4gdmFsdWUgfHwgXCJhdXRvXCI7XG4gICAgfSB9KTtcbi8qKlxuVGhlIGhhc2ggb2YgdGhlIFtjb250ZXh0XSgjbHIuQ29udGV4dFRyYWNrZXIuY29uc3RydWN0b3IpXG50aGF0IHRoZSBub2RlIHdhcyBwYXJzZWQgaW4sIGlmIGFueS4gVXNlZCB0byBsaW1pdCByZXVzZSBvZlxuY29udGV4dHVhbCBub2Rlcy5cbiovXG5Ob2RlUHJvcC5jb250ZXh0SGFzaCA9IG5ldyBOb2RlUHJvcCh7IHBlck5vZGU6IHRydWUgfSk7XG4vKipcblRoZSBkaXN0YW5jZSBiZXlvbmQgdGhlIGVuZCBvZiB0aGUgbm9kZSB0aGF0IHRoZSB0b2tlbml6ZXJcbmxvb2tlZCBhaGVhZCBmb3IgYW55IG9mIHRoZSB0b2tlbnMgaW5zaWRlIHRoZSBub2RlLiAoVGhlIExSXG5wYXJzZXIgb25seSBzdG9yZXMgdGhpcyB3aGVuIGl0IGlzIGxhcmdlciB0aGFuIDI1LCBmb3JcbmVmZmljaWVuY3kgcmVhc29ucy4pXG4qL1xuTm9kZVByb3AubG9va0FoZWFkID0gbmV3IE5vZGVQcm9wKHsgcGVyTm9kZTogdHJ1ZSB9KTtcbi8qKlxuVGhpcyBwZXItbm9kZSBwcm9wIGlzIHVzZWQgdG8gcmVwbGFjZSBhIGdpdmVuIG5vZGUsIG9yIHBhcnQgb2YgYVxubm9kZSwgd2l0aCBhbm90aGVyIHRyZWUuIFRoaXMgaXMgdXNlZnVsIHRvIGluY2x1ZGUgdHJlZXMgZnJvbVxuZGlmZmVyZW50IGxhbmd1YWdlcyBpbiBtaXhlZC1sYW5ndWFnZSBwYXJzZXJzLlxuKi9cbk5vZGVQcm9wLm1vdW50ZWQgPSBuZXcgTm9kZVByb3AoeyBwZXJOb2RlOiB0cnVlIH0pO1xuLyoqXG5BIG1vdW50ZWQgdHJlZSwgd2hpY2ggY2FuIGJlIFtzdG9yZWRdKCNjb21tb24uTm9kZVByb3BebW91bnRlZCkgb25cbmEgdHJlZSBub2RlIHRvIGluZGljYXRlIHRoYXQgcGFydHMgb2YgaXRzIGNvbnRlbnQgYXJlXG5yZXByZXNlbnRlZCBieSBhbm90aGVyIHRyZWUuXG4qL1xuY2xhc3MgTW91bnRlZFRyZWUge1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBpbm5lciB0cmVlLlxuICAgICovXG4gICAgdHJlZSwgXG4gICAgLyoqXG4gICAgSWYgdGhpcyBpcyBudWxsLCB0aGlzIHRyZWUgcmVwbGFjZXMgdGhlIGVudGlyZSBub2RlIChpdCB3aWxsXG4gICAgYmUgaW5jbHVkZWQgaW4gdGhlIHJlZ3VsYXIgaXRlcmF0aW9uIGluc3RlYWQgb2YgaXRzIGhvc3RcbiAgICBub2RlKS4gSWYgbm90LCBvbmx5IHRoZSBnaXZlbiByYW5nZXMgYXJlIGNvbnNpZGVyZWQgdG8gYmVcbiAgICBjb3ZlcmVkIGJ5IHRoaXMgdHJlZS4gVGhpcyBpcyB1c2VkIGZvciB0cmVlcyB0aGF0IGFyZSBtaXhlZCBpblxuICAgIGEgd2F5IHRoYXQgaXNuJ3Qgc3RyaWN0bHkgaGllcmFyY2hpY2FsLiBTdWNoIG1vdW50ZWQgdHJlZXMgYXJlXG4gICAgb25seSBlbnRlcmVkIGJ5IFtgcmVzb2x2ZUlubmVyYF0oI2NvbW1vbi5UcmVlLnJlc29sdmVJbm5lcilcbiAgICBhbmQgW2BlbnRlcmBdKCNjb21tb24uU3ludGF4Tm9kZS5lbnRlcikuXG4gICAgKi9cbiAgICBvdmVybGF5LCBcbiAgICAvKipcbiAgICBUaGUgcGFyc2VyIHVzZWQgdG8gY3JlYXRlIHRoaXMgc3VidHJlZS5cbiAgICAqL1xuICAgIHBhcnNlcikge1xuICAgICAgICB0aGlzLnRyZWUgPSB0cmVlO1xuICAgICAgICB0aGlzLm92ZXJsYXkgPSBvdmVybGF5O1xuICAgICAgICB0aGlzLnBhcnNlciA9IHBhcnNlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzdGF0aWMgZ2V0KHRyZWUpIHtcbiAgICAgICAgcmV0dXJuIHRyZWUgJiYgdHJlZS5wcm9wcyAmJiB0cmVlLnByb3BzW05vZGVQcm9wLm1vdW50ZWQuaWRdO1xuICAgIH1cbn1cbmNvbnN0IG5vUHJvcHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuLyoqXG5FYWNoIG5vZGUgaW4gYSBzeW50YXggdHJlZSBoYXMgYSBub2RlIHR5cGUgYXNzb2NpYXRlZCB3aXRoIGl0LlxuKi9cbmNsYXNzIE5vZGVUeXBlIHtcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBuYW1lIG9mIHRoZSBub2RlIHR5cGUuIE5vdCBuZWNlc3NhcmlseSB1bmlxdWUsIGJ1dCBpZiB0aGVcbiAgICBncmFtbWFyIHdhcyB3cml0dGVuIHByb3Blcmx5LCBkaWZmZXJlbnQgbm9kZSB0eXBlcyB3aXRoIHRoZVxuICAgIHNhbWUgbmFtZSB3aXRoaW4gYSBub2RlIHNldCBzaG91bGQgcGxheSB0aGUgc2FtZSBzZW1hbnRpY1xuICAgIHJvbGUuXG4gICAgKi9cbiAgICBuYW1lLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIHByb3BzLCBcbiAgICAvKipcbiAgICBUaGUgaWQgb2YgdGhpcyBub2RlIGluIGl0cyBzZXQuIENvcnJlc3BvbmRzIHRvIHRoZSB0ZXJtIGlkc1xuICAgIHVzZWQgaW4gdGhlIHBhcnNlci5cbiAgICAqL1xuICAgIGlkLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGZsYWdzID0gMCkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5mbGFncyA9IGZsYWdzO1xuICAgIH1cbiAgICAvKipcbiAgICBEZWZpbmUgYSBub2RlIHR5cGUuXG4gICAgKi9cbiAgICBzdGF0aWMgZGVmaW5lKHNwZWMpIHtcbiAgICAgICAgbGV0IHByb3BzID0gc3BlYy5wcm9wcyAmJiBzcGVjLnByb3BzLmxlbmd0aCA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiBub1Byb3BzO1xuICAgICAgICBsZXQgZmxhZ3MgPSAoc3BlYy50b3AgPyAxIC8qIE5vZGVGbGFnLlRvcCAqLyA6IDApIHwgKHNwZWMuc2tpcHBlZCA/IDIgLyogTm9kZUZsYWcuU2tpcHBlZCAqLyA6IDApIHxcbiAgICAgICAgICAgIChzcGVjLmVycm9yID8gNCAvKiBOb2RlRmxhZy5FcnJvciAqLyA6IDApIHwgKHNwZWMubmFtZSA9PSBudWxsID8gOCAvKiBOb2RlRmxhZy5Bbm9ueW1vdXMgKi8gOiAwKTtcbiAgICAgICAgbGV0IHR5cGUgPSBuZXcgTm9kZVR5cGUoc3BlYy5uYW1lIHx8IFwiXCIsIHByb3BzLCBzcGVjLmlkLCBmbGFncyk7XG4gICAgICAgIGlmIChzcGVjLnByb3BzKVxuICAgICAgICAgICAgZm9yIChsZXQgc3JjIG9mIHNwZWMucHJvcHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc3JjKSlcbiAgICAgICAgICAgICAgICAgICAgc3JjID0gc3JjKHR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChzcmMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNyY1swXS5wZXJOb2RlKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDYW4ndCBzdG9yZSBhIHBlci1ub2RlIHByb3Agb24gYSBub2RlIHR5cGVcIik7XG4gICAgICAgICAgICAgICAgICAgIHByb3BzW3NyY1swXS5pZF0gPSBzcmNbMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gICAgLyoqXG4gICAgUmV0cmlldmVzIGEgbm9kZSBwcm9wIGZvciB0aGlzIHR5cGUuIFdpbGwgcmV0dXJuIGB1bmRlZmluZWRgIGlmXG4gICAgdGhlIHByb3AgaXNuJ3QgcHJlc2VudCBvbiB0aGlzIG5vZGUuXG4gICAgKi9cbiAgICBwcm9wKHByb3ApIHsgcmV0dXJuIHRoaXMucHJvcHNbcHJvcC5pZF07IH1cbiAgICAvKipcbiAgICBUcnVlIHdoZW4gdGhpcyBpcyB0aGUgdG9wIG5vZGUgb2YgYSBncmFtbWFyLlxuICAgICovXG4gICAgZ2V0IGlzVG9wKCkgeyByZXR1cm4gKHRoaXMuZmxhZ3MgJiAxIC8qIE5vZGVGbGFnLlRvcCAqLykgPiAwOyB9XG4gICAgLyoqXG4gICAgVHJ1ZSB3aGVuIHRoaXMgbm9kZSBpcyBwcm9kdWNlZCBieSBhIHNraXAgcnVsZS5cbiAgICAqL1xuICAgIGdldCBpc1NraXBwZWQoKSB7IHJldHVybiAodGhpcy5mbGFncyAmIDIgLyogTm9kZUZsYWcuU2tpcHBlZCAqLykgPiAwOyB9XG4gICAgLyoqXG4gICAgSW5kaWNhdGVzIHdoZXRoZXIgdGhpcyBpcyBhbiBlcnJvciBub2RlLlxuICAgICovXG4gICAgZ2V0IGlzRXJyb3IoKSB7IHJldHVybiAodGhpcy5mbGFncyAmIDQgLyogTm9kZUZsYWcuRXJyb3IgKi8pID4gMDsgfVxuICAgIC8qKlxuICAgIFdoZW4gdHJ1ZSwgdGhpcyBub2RlIHR5cGUgZG9lc24ndCBjb3JyZXNwb25kIHRvIGEgdXNlci1kZWNsYXJlZFxuICAgIG5hbWVkIG5vZGUsIGZvciBleGFtcGxlIGJlY2F1c2UgaXQgaXMgdXNlZCB0byBjYWNoZSByZXBldGl0aW9uLlxuICAgICovXG4gICAgZ2V0IGlzQW5vbnltb3VzKCkgeyByZXR1cm4gKHRoaXMuZmxhZ3MgJiA4IC8qIE5vZGVGbGFnLkFub255bW91cyAqLykgPiAwOyB9XG4gICAgLyoqXG4gICAgUmV0dXJucyB0cnVlIHdoZW4gdGhpcyBub2RlJ3MgbmFtZSBvciBvbmUgb2YgaXRzXG4gICAgW2dyb3Vwc10oI2NvbW1vbi5Ob2RlUHJvcF5ncm91cCkgbWF0Y2hlcyB0aGUgZ2l2ZW4gc3RyaW5nLlxuICAgICovXG4gICAgaXMobmFtZSkge1xuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm5hbWUgPT0gbmFtZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBncm91cCA9IHRoaXMucHJvcChOb2RlUHJvcC5ncm91cCk7XG4gICAgICAgICAgICByZXR1cm4gZ3JvdXAgPyBncm91cC5pbmRleE9mKG5hbWUpID4gLTEgOiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pZCA9PSBuYW1lO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBmdW5jdGlvbiBmcm9tIG5vZGUgdHlwZXMgdG8gYXJiaXRyYXJ5IHZhbHVlcyBieVxuICAgIHNwZWNpZnlpbmcgYW4gb2JqZWN0IHdob3NlIHByb3BlcnR5IG5hbWVzIGFyZSBub2RlIG9yXG4gICAgW2dyb3VwXSgjY29tbW9uLk5vZGVQcm9wXmdyb3VwKSBuYW1lcy4gT2Z0ZW4gdXNlZnVsIHdpdGhcbiAgICBbYE5vZGVQcm9wLmFkZGBdKCNjb21tb24uTm9kZVByb3AuYWRkKS4gWW91IGNhbiBwdXQgbXVsdGlwbGVcbiAgICBuYW1lcywgc2VwYXJhdGVkIGJ5IHNwYWNlcywgaW4gYSBzaW5nbGUgcHJvcGVydHkgbmFtZSB0byBtYXBcbiAgICBtdWx0aXBsZSBub2RlIG5hbWVzIHRvIGEgc2luZ2xlIHZhbHVlLlxuICAgICovXG4gICAgc3RhdGljIG1hdGNoKG1hcCkge1xuICAgICAgICBsZXQgZGlyZWN0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBtYXApXG4gICAgICAgICAgICBmb3IgKGxldCBuYW1lIG9mIHByb3Auc3BsaXQoXCIgXCIpKVxuICAgICAgICAgICAgICAgIGRpcmVjdFtuYW1lXSA9IG1hcFtwcm9wXTtcbiAgICAgICAgcmV0dXJuIChub2RlKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGxldCBncm91cHMgPSBub2RlLnByb3AoTm9kZVByb3AuZ3JvdXApLCBpID0gLTE7IGkgPCAoZ3JvdXBzID8gZ3JvdXBzLmxlbmd0aCA6IDApOyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgZm91bmQgPSBkaXJlY3RbaSA8IDAgPyBub2RlLm5hbWUgOiBncm91cHNbaV1dO1xuICAgICAgICAgICAgICAgIGlmIChmb3VuZClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZvdW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbn1cbi8qKlxuQW4gZW1wdHkgZHVtbXkgbm9kZSB0eXBlIHRvIHVzZSB3aGVuIG5vIGFjdHVhbCB0eXBlIGlzIGF2YWlsYWJsZS5cbiovXG5Ob2RlVHlwZS5ub25lID0gbmV3IE5vZGVUeXBlKFwiXCIsIE9iamVjdC5jcmVhdGUobnVsbCksIDAsIDggLyogTm9kZUZsYWcuQW5vbnltb3VzICovKTtcbi8qKlxuQSBub2RlIHNldCBob2xkcyBhIGNvbGxlY3Rpb24gb2Ygbm9kZSB0eXBlcy4gSXQgaXMgdXNlZCB0b1xuY29tcGFjdGx5IHJlcHJlc2VudCB0cmVlcyBieSBzdG9yaW5nIHRoZWlyIHR5cGUgaWRzLCByYXRoZXIgdGhhbiBhXG5mdWxsIHBvaW50ZXIgdG8gdGhlIHR5cGUgb2JqZWN0LCBpbiBhIG51bWVyaWMgYXJyYXkuIEVhY2ggcGFyc2VyXG5baGFzXSgjbHIuTFJQYXJzZXIubm9kZVNldCkgYSBub2RlIHNldCwgYW5kIFt0cmVlXG5idWZmZXJzXSgjY29tbW9uLlRyZWVCdWZmZXIpIGNhbiBvbmx5IHN0b3JlIGNvbGxlY3Rpb25zIG9mIG5vZGVzXG5mcm9tIHRoZSBzYW1lIHNldC4gQSBzZXQgY2FuIGhhdmUgYSBtYXhpbXVtIG9mIDIqKjE2ICg2NTUzNikgbm9kZVxudHlwZXMgaW4gaXQsIHNvIHRoYXQgdGhlIGlkcyBmaXQgaW50byAxNi1iaXQgdHlwZWQgYXJyYXkgc2xvdHMuXG4qL1xuY2xhc3MgTm9kZVNldCB7XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgc2V0IHdpdGggdGhlIGdpdmVuIHR5cGVzLiBUaGUgYGlkYCBwcm9wZXJ0eSBvZiBlYWNoXG4gICAgdHlwZSBzaG91bGQgY29ycmVzcG9uZCB0byBpdHMgcG9zaXRpb24gd2l0aGluIHRoZSBhcnJheS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSBub2RlIHR5cGVzIGluIHRoaXMgc2V0LCBieSBpZC5cbiAgICAqL1xuICAgIHR5cGVzKSB7XG4gICAgICAgIHRoaXMudHlwZXMgPSB0eXBlcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0eXBlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIGlmICh0eXBlc1tpXS5pZCAhPSBpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiTm9kZSB0eXBlIGlkcyBzaG91bGQgY29ycmVzcG9uZCB0byBhcnJheSBwb3NpdGlvbnMgd2hlbiBjcmVhdGluZyBhIG5vZGUgc2V0XCIpO1xuICAgIH1cbiAgICAvKipcbiAgICBDcmVhdGUgYSBjb3B5IG9mIHRoaXMgc2V0IHdpdGggc29tZSBub2RlIHByb3BlcnRpZXMgYWRkZWQuIFRoZVxuICAgIGFyZ3VtZW50cyB0byB0aGlzIG1ldGhvZCBjYW4gYmUgY3JlYXRlZCB3aXRoXG4gICAgW2BOb2RlUHJvcC5hZGRgXSgjY29tbW9uLk5vZGVQcm9wLmFkZCkuXG4gICAgKi9cbiAgICBleHRlbmQoLi4ucHJvcHMpIHtcbiAgICAgICAgbGV0IG5ld1R5cGVzID0gW107XG4gICAgICAgIGZvciAobGV0IHR5cGUgb2YgdGhpcy50eXBlcykge1xuICAgICAgICAgICAgbGV0IG5ld1Byb3BzID0gbnVsbDtcbiAgICAgICAgICAgIGZvciAobGV0IHNvdXJjZSBvZiBwcm9wcykge1xuICAgICAgICAgICAgICAgIGxldCBhZGQgPSBzb3VyY2UodHlwZSk7XG4gICAgICAgICAgICAgICAgaWYgKGFkZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5ld1Byb3BzKVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3UHJvcHMgPSBPYmplY3QuYXNzaWduKHt9LCB0eXBlLnByb3BzKTtcbiAgICAgICAgICAgICAgICAgICAgbmV3UHJvcHNbYWRkWzBdLmlkXSA9IGFkZFsxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXdUeXBlcy5wdXNoKG5ld1Byb3BzID8gbmV3IE5vZGVUeXBlKHR5cGUubmFtZSwgbmV3UHJvcHMsIHR5cGUuaWQsIHR5cGUuZmxhZ3MpIDogdHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBOb2RlU2V0KG5ld1R5cGVzKTtcbiAgICB9XG59XG5jb25zdCBDYWNoZWROb2RlID0gbmV3IFdlYWtNYXAoKSwgQ2FjaGVkSW5uZXJOb2RlID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxuT3B0aW9ucyB0aGF0IGNvbnRyb2wgaXRlcmF0aW9uLiBDYW4gYmUgY29tYmluZWQgd2l0aCB0aGUgYHxgXG5vcGVyYXRvciB0byBlbmFibGUgbXVsdGlwbGUgb25lcy5cbiovXG52YXIgSXRlck1vZGU7XG4oZnVuY3Rpb24gKEl0ZXJNb2RlKSB7XG4gICAgLyoqXG4gICAgV2hlbiBlbmFibGVkLCBpdGVyYXRpb24gd2lsbCBvbmx5IHZpc2l0IFtgVHJlZWBdKCNjb21tb24uVHJlZSlcbiAgICBvYmplY3RzLCBub3Qgbm9kZXMgcGFja2VkIGludG9cbiAgICBbYFRyZWVCdWZmZXJgXSgjY29tbW9uLlRyZWVCdWZmZXIpcy5cbiAgICAqL1xuICAgIEl0ZXJNb2RlW0l0ZXJNb2RlW1wiRXhjbHVkZUJ1ZmZlcnNcIl0gPSAxXSA9IFwiRXhjbHVkZUJ1ZmZlcnNcIjtcbiAgICAvKipcbiAgICBFbmFibGUgdGhpcyB0byBtYWtlIGl0ZXJhdGlvbiBpbmNsdWRlIGFub255bW91cyBub2RlcyAoc3VjaCBhc1xuICAgIHRoZSBub2RlcyB0aGF0IHdyYXAgcmVwZWF0ZWQgZ3JhbW1hciBjb25zdHJ1Y3RzIGludG8gYSBiYWxhbmNlZFxuICAgIHRyZWUpLlxuICAgICovXG4gICAgSXRlck1vZGVbSXRlck1vZGVbXCJJbmNsdWRlQW5vbnltb3VzXCJdID0gMl0gPSBcIkluY2x1ZGVBbm9ueW1vdXNcIjtcbiAgICAvKipcbiAgICBCeSBkZWZhdWx0LCByZWd1bGFyIFttb3VudGVkXSgjY29tbW9uLk5vZGVQcm9wXm1vdW50ZWQpIG5vZGVzXG4gICAgcmVwbGFjZSB0aGVpciBiYXNlIG5vZGUgaW4gaXRlcmF0aW9uLiBFbmFibGUgdGhpcyB0byBpZ25vcmUgdGhlbVxuICAgIGluc3RlYWQuXG4gICAgKi9cbiAgICBJdGVyTW9kZVtJdGVyTW9kZVtcIklnbm9yZU1vdW50c1wiXSA9IDRdID0gXCJJZ25vcmVNb3VudHNcIjtcbiAgICAvKipcbiAgICBUaGlzIG9wdGlvbiBvbmx5IGFwcGxpZXMgaW5cbiAgICBbYGVudGVyYF0oI2NvbW1vbi5TeW50YXhOb2RlLmVudGVyKS1zdHlsZSBtZXRob2RzLiBJdCB0ZWxscyB0aGVcbiAgICBsaWJyYXJ5IHRvIG5vdCBlbnRlciBtb3VudGVkIG92ZXJsYXlzIGlmIG9uZSBjb3ZlcnMgdGhlIGdpdmVuXG4gICAgcG9zaXRpb24uXG4gICAgKi9cbiAgICBJdGVyTW9kZVtJdGVyTW9kZVtcIklnbm9yZU92ZXJsYXlzXCJdID0gOF0gPSBcIklnbm9yZU92ZXJsYXlzXCI7XG59KShJdGVyTW9kZSB8fCAoSXRlck1vZGUgPSB7fSkpO1xuLyoqXG5BIHBpZWNlIG9mIHN5bnRheCB0cmVlLiBUaGVyZSBhcmUgdHdvIHdheXMgdG8gYXBwcm9hY2ggdGhlc2VcbnRyZWVzOiB0aGUgd2F5IHRoZXkgYXJlIGFjdHVhbGx5IHN0b3JlZCBpbiBtZW1vcnksIGFuZCB0aGVcbmNvbnZlbmllbnQgd2F5LlxuXG5TeW50YXggdHJlZXMgYXJlIHN0b3JlZCBhcyBhIHRyZWUgb2YgYFRyZWVgIGFuZCBgVHJlZUJ1ZmZlcmBcbm9iamVjdHMuIEJ5IHBhY2tpbmcgZGV0YWlsIGluZm9ybWF0aW9uIGludG8gYFRyZWVCdWZmZXJgIGxlYWZcbm5vZGVzLCB0aGUgcmVwcmVzZW50YXRpb24gaXMgbWFkZSBhIGxvdCBtb3JlIG1lbW9yeS1lZmZpY2llbnQuXG5cbkhvd2V2ZXIsIHdoZW4geW91IHdhbnQgdG8gYWN0dWFsbHkgd29yayB3aXRoIHRyZWUgbm9kZXMsIHRoaXNcbnJlcHJlc2VudGF0aW9uIGlzIHZlcnkgYXdrd2FyZCwgc28gbW9zdCBjbGllbnQgY29kZSB3aWxsIHdhbnQgdG9cbnVzZSB0aGUgW2BUcmVlQ3Vyc29yYF0oI2NvbW1vbi5UcmVlQ3Vyc29yKSBvclxuW2BTeW50YXhOb2RlYF0oI2NvbW1vbi5TeW50YXhOb2RlKSBpbnRlcmZhY2UgaW5zdGVhZCwgd2hpY2ggcHJvdmlkZXNcbmEgdmlldyBvbiBzb21lIHBhcnQgb2YgdGhpcyBkYXRhIHN0cnVjdHVyZSwgYW5kIGNhbiBiZSB1c2VkIHRvXG5tb3ZlIGFyb3VuZCB0byBhZGphY2VudCBub2Rlcy5cbiovXG5jbGFzcyBUcmVlIHtcbiAgICAvKipcbiAgICBDb25zdHJ1Y3QgYSBuZXcgdHJlZS4gU2VlIGFsc28gW2BUcmVlLmJ1aWxkYF0oI2NvbW1vbi5UcmVlXmJ1aWxkKS5cbiAgICAqL1xuICAgIGNvbnN0cnVjdG9yKFxuICAgIC8qKlxuICAgIFRoZSB0eXBlIG9mIHRoZSB0b3Agbm9kZS5cbiAgICAqL1xuICAgIHR5cGUsIFxuICAgIC8qKlxuICAgIFRoaXMgbm9kZSdzIGNoaWxkIG5vZGVzLlxuICAgICovXG4gICAgY2hpbGRyZW4sIFxuICAgIC8qKlxuICAgIFRoZSBwb3NpdGlvbnMgKG9mZnNldHMgcmVsYXRpdmUgdG8gdGhlIHN0YXJ0IG9mIHRoaXMgdHJlZSkgb2ZcbiAgICB0aGUgY2hpbGRyZW4uXG4gICAgKi9cbiAgICBwb3NpdGlvbnMsIFxuICAgIC8qKlxuICAgIFRoZSB0b3RhbCBsZW5ndGggb2YgdGhpcyB0cmVlXG4gICAgKi9cbiAgICBsZW5ndGgsIFxuICAgIC8qKlxuICAgIFBlci1ub2RlIFtub2RlIHByb3BzXSgjY29tbW9uLk5vZGVQcm9wKSB0byBhc3NvY2lhdGUgd2l0aCB0aGlzIG5vZGUuXG4gICAgKi9cbiAgICBwcm9wcykge1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gICAgICAgIHRoaXMucG9zaXRpb25zID0gcG9zaXRpb25zO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgLyoqXG4gICAgICAgIEBpbnRlcm5hbFxuICAgICAgICAqL1xuICAgICAgICB0aGlzLnByb3BzID0gbnVsbDtcbiAgICAgICAgaWYgKHByb3BzICYmIHByb3BzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5wcm9wcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgICBmb3IgKGxldCBbcHJvcCwgdmFsdWVdIG9mIHByb3BzKVxuICAgICAgICAgICAgICAgIHRoaXMucHJvcHNbdHlwZW9mIHByb3AgPT0gXCJudW1iZXJcIiA/IHByb3AgOiBwcm9wLmlkXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCBtb3VudGVkID0gTW91bnRlZFRyZWUuZ2V0KHRoaXMpO1xuICAgICAgICBpZiAobW91bnRlZCAmJiAhbW91bnRlZC5vdmVybGF5KVxuICAgICAgICAgICAgcmV0dXJuIG1vdW50ZWQudHJlZS50b1N0cmluZygpO1xuICAgICAgICBsZXQgY2hpbGRyZW4gPSBcIlwiO1xuICAgICAgICBmb3IgKGxldCBjaCBvZiB0aGlzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBsZXQgc3RyID0gY2gudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGlmIChzdHIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hpbGRyZW4pXG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuICs9IFwiLFwiO1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuICs9IHN0cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gIXRoaXMudHlwZS5uYW1lID8gY2hpbGRyZW4gOlxuICAgICAgICAgICAgKC9cXFcvLnRlc3QodGhpcy50eXBlLm5hbWUpICYmICF0aGlzLnR5cGUuaXNFcnJvciA/IEpTT04uc3RyaW5naWZ5KHRoaXMudHlwZS5uYW1lKSA6IHRoaXMudHlwZS5uYW1lKSArXG4gICAgICAgICAgICAgICAgKGNoaWxkcmVuLmxlbmd0aCA/IFwiKFwiICsgY2hpbGRyZW4gKyBcIilcIiA6IFwiXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgYSBbdHJlZSBjdXJzb3JdKCNjb21tb24uVHJlZUN1cnNvcikgcG9zaXRpb25lZCBhdCB0aGUgdG9wIG9mXG4gICAgdGhlIHRyZWUuIE1vZGUgY2FuIGJlIHVzZWQgdG8gW2NvbnRyb2xdKCNjb21tb24uSXRlck1vZGUpIHdoaWNoXG4gICAgbm9kZXMgdGhlIGN1cnNvciB2aXNpdHMuXG4gICAgKi9cbiAgICBjdXJzb3IobW9kZSA9IDApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlQ3Vyc29yKHRoaXMudG9wTm9kZSwgbW9kZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCBhIFt0cmVlIGN1cnNvcl0oI2NvbW1vbi5UcmVlQ3Vyc29yKSBwb2ludGluZyBpbnRvIHRoaXMgdHJlZVxuICAgIGF0IHRoZSBnaXZlbiBwb3NpdGlvbiBhbmQgc2lkZSAoc2VlXG4gICAgW2Btb3ZlVG9gXSgjY29tbW9uLlRyZWVDdXJzb3IubW92ZVRvKS5cbiAgICAqL1xuICAgIGN1cnNvckF0KHBvcywgc2lkZSA9IDAsIG1vZGUgPSAwKSB7XG4gICAgICAgIGxldCBzY29wZSA9IENhY2hlZE5vZGUuZ2V0KHRoaXMpIHx8IHRoaXMudG9wTm9kZTtcbiAgICAgICAgbGV0IGN1cnNvciA9IG5ldyBUcmVlQ3Vyc29yKHNjb3BlKTtcbiAgICAgICAgY3Vyc29yLm1vdmVUbyhwb3MsIHNpZGUpO1xuICAgICAgICBDYWNoZWROb2RlLnNldCh0aGlzLCBjdXJzb3IuX3RyZWUpO1xuICAgICAgICByZXR1cm4gY3Vyc29yO1xuICAgIH1cbiAgICAvKipcbiAgICBHZXQgYSBbc3ludGF4IG5vZGVdKCNjb21tb24uU3ludGF4Tm9kZSkgb2JqZWN0IGZvciB0aGUgdG9wIG9mIHRoZVxuICAgIHRyZWUuXG4gICAgKi9cbiAgICBnZXQgdG9wTm9kZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlTm9kZSh0aGlzLCAwLCAwLCBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgR2V0IHRoZSBbc3ludGF4IG5vZGVdKCNjb21tb24uU3ludGF4Tm9kZSkgYXQgdGhlIGdpdmVuIHBvc2l0aW9uLlxuICAgIElmIGBzaWRlYCBpcyAtMSwgdGhpcyB3aWxsIG1vdmUgaW50byBub2RlcyB0aGF0IGVuZCBhdCB0aGVcbiAgICBwb3NpdGlvbi4gSWYgMSwgaXQnbGwgbW92ZSBpbnRvIG5vZGVzIHRoYXQgc3RhcnQgYXQgdGhlXG4gICAgcG9zaXRpb24uIFdpdGggMCwgaXQnbGwgb25seSBlbnRlciBub2RlcyB0aGF0IGNvdmVyIHRoZSBwb3NpdGlvblxuICAgIGZyb20gYm90aCBzaWRlcy5cbiAgICBcbiAgICBOb3RlIHRoYXQgdGhpcyB3aWxsIG5vdCBlbnRlclxuICAgIFtvdmVybGF5c10oI2NvbW1vbi5Nb3VudGVkVHJlZS5vdmVybGF5KSwgYW5kIHlvdSBvZnRlbiB3YW50XG4gICAgW2ByZXNvbHZlSW5uZXJgXSgjY29tbW9uLlRyZWUucmVzb2x2ZUlubmVyKSBpbnN0ZWFkLlxuICAgICovXG4gICAgcmVzb2x2ZShwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIGxldCBub2RlID0gcmVzb2x2ZU5vZGUoQ2FjaGVkTm9kZS5nZXQodGhpcykgfHwgdGhpcy50b3BOb2RlLCBwb3MsIHNpZGUsIGZhbHNlKTtcbiAgICAgICAgQ2FjaGVkTm9kZS5zZXQodGhpcywgbm9kZSk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICAvKipcbiAgICBMaWtlIFtgcmVzb2x2ZWBdKCNjb21tb24uVHJlZS5yZXNvbHZlKSwgYnV0IHdpbGwgZW50ZXJcbiAgICBbb3ZlcmxhaWRdKCNjb21tb24uTW91bnRlZFRyZWUub3ZlcmxheSkgbm9kZXMsIHByb2R1Y2luZyBhIHN5bnRheCBub2RlXG4gICAgcG9pbnRpbmcgaW50byB0aGUgaW5uZXJtb3N0IG92ZXJsYWlkIHRyZWUgYXQgdGhlIGdpdmVuIHBvc2l0aW9uXG4gICAgKHdpdGggcGFyZW50IGxpbmtzIGdvaW5nIHRocm91Z2ggYWxsIHBhcmVudCBzdHJ1Y3R1cmUsIGluY2x1ZGluZ1xuICAgIHRoZSBob3N0IHRyZWVzKS5cbiAgICAqL1xuICAgIHJlc29sdmVJbm5lcihwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIGxldCBub2RlID0gcmVzb2x2ZU5vZGUoQ2FjaGVkSW5uZXJOb2RlLmdldCh0aGlzKSB8fCB0aGlzLnRvcE5vZGUsIHBvcywgc2lkZSwgdHJ1ZSk7XG4gICAgICAgIENhY2hlZElubmVyTm9kZS5zZXQodGhpcywgbm9kZSk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICAvKipcbiAgICBJbiBzb21lIHNpdHVhdGlvbnMsIGl0IGNhbiBiZSB1c2VmdWwgdG8gaXRlcmF0ZSB0aHJvdWdoIGFsbFxuICAgIG5vZGVzIGFyb3VuZCBhIHBvc2l0aW9uLCBpbmNsdWRpbmcgdGhvc2UgaW4gb3ZlcmxheXMgdGhhdCBkb24ndFxuICAgIGRpcmVjdGx5IGNvdmVyIHRoZSBwb3NpdGlvbi4gVGhpcyBtZXRob2QgZ2l2ZXMgeW91IGFuIGl0ZXJhdG9yXG4gICAgdGhhdCB3aWxsIHByb2R1Y2UgYWxsIG5vZGVzLCBmcm9tIHNtYWxsIHRvIGJpZywgYXJvdW5kIHRoZSBnaXZlblxuICAgIHBvc2l0aW9uLlxuICAgICovXG4gICAgcmVzb2x2ZVN0YWNrKHBvcywgc2lkZSA9IDApIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrSXRlcmF0b3IodGhpcywgcG9zLCBzaWRlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgSXRlcmF0ZSBvdmVyIHRoZSB0cmVlIGFuZCBpdHMgY2hpbGRyZW4sIGNhbGxpbmcgYGVudGVyYCBmb3IgYW55XG4gICAgbm9kZSB0aGF0IHRvdWNoZXMgdGhlIGBmcm9tYC9gdG9gIHJlZ2lvbiAoaWYgZ2l2ZW4pIGJlZm9yZVxuICAgIHJ1bm5pbmcgb3ZlciBzdWNoIGEgbm9kZSdzIGNoaWxkcmVuLCBhbmQgYGxlYXZlYCAoaWYgZ2l2ZW4pIHdoZW5cbiAgICBsZWF2aW5nIHRoZSBub2RlLiBXaGVuIGBlbnRlcmAgcmV0dXJucyBgZmFsc2VgLCB0aGF0IG5vZGUgd2lsbFxuICAgIG5vdCBoYXZlIGl0cyBjaGlsZHJlbiBpdGVyYXRlZCBvdmVyIChvciBgbGVhdmVgIGNhbGxlZCkuXG4gICAgKi9cbiAgICBpdGVyYXRlKHNwZWMpIHtcbiAgICAgICAgbGV0IHsgZW50ZXIsIGxlYXZlLCBmcm9tID0gMCwgdG8gPSB0aGlzLmxlbmd0aCB9ID0gc3BlYztcbiAgICAgICAgbGV0IG1vZGUgPSBzcGVjLm1vZGUgfHwgMCwgYW5vbiA9IChtb2RlICYgSXRlck1vZGUuSW5jbHVkZUFub255bW91cykgPiAwO1xuICAgICAgICBmb3IgKGxldCBjID0gdGhpcy5jdXJzb3IobW9kZSB8IEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMpOzspIHtcbiAgICAgICAgICAgIGxldCBlbnRlcmVkID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoYy5mcm9tIDw9IHRvICYmIGMudG8gPj0gZnJvbSAmJiAoIWFub24gJiYgYy50eXBlLmlzQW5vbnltb3VzIHx8IGVudGVyKGMpICE9PSBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoYy5maXJzdENoaWxkKCkpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGVudGVyZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIGlmIChlbnRlcmVkICYmIGxlYXZlICYmIChhbm9uIHx8ICFjLnR5cGUuaXNBbm9ueW1vdXMpKVxuICAgICAgICAgICAgICAgICAgICBsZWF2ZShjKTtcbiAgICAgICAgICAgICAgICBpZiAoYy5uZXh0U2libGluZygpKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAoIWMucGFyZW50KCkpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICBlbnRlcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICBHZXQgdGhlIHZhbHVlIG9mIHRoZSBnaXZlbiBbbm9kZSBwcm9wXSgjY29tbW9uLk5vZGVQcm9wKSBmb3IgdGhpc1xuICAgIG5vZGUuIFdvcmtzIHdpdGggYm90aCBwZXItbm9kZSBhbmQgcGVyLXR5cGUgcHJvcHMuXG4gICAgKi9cbiAgICBwcm9wKHByb3ApIHtcbiAgICAgICAgcmV0dXJuICFwcm9wLnBlck5vZGUgPyB0aGlzLnR5cGUucHJvcChwcm9wKSA6IHRoaXMucHJvcHMgPyB0aGlzLnByb3BzW3Byb3AuaWRdIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICBSZXR1cm5zIHRoZSBub2RlJ3MgW3Blci1ub2RlIHByb3BzXSgjY29tbW9uLk5vZGVQcm9wLnBlck5vZGUpIGluIGFcbiAgICBmb3JtYXQgdGhhdCBjYW4gYmUgcGFzc2VkIHRvIHRoZSBbYFRyZWVgXSgjY29tbW9uLlRyZWUpXG4gICAgY29uc3RydWN0b3IuXG4gICAgKi9cbiAgICBnZXQgcHJvcFZhbHVlcygpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBpZiAodGhpcy5wcm9wcylcbiAgICAgICAgICAgIGZvciAobGV0IGlkIGluIHRoaXMucHJvcHMpXG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goWytpZCwgdGhpcy5wcm9wc1tpZF1dKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgQmFsYW5jZSB0aGUgZGlyZWN0IGNoaWxkcmVuIG9mIHRoaXMgdHJlZSwgcHJvZHVjaW5nIGEgY29weSBvZlxuICAgIHdoaWNoIG1heSBoYXZlIGNoaWxkcmVuIGdyb3VwZWQgaW50byBzdWJ0cmVlcyB3aXRoIHR5cGVcbiAgICBbYE5vZGVUeXBlLm5vbmVgXSgjY29tbW9uLk5vZGVUeXBlXm5vbmUpLlxuICAgICovXG4gICAgYmFsYW5jZShjb25maWcgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5sZW5ndGggPD0gOCAvKiBCYWxhbmNlLkJyYW5jaEZhY3RvciAqLyA/IHRoaXMgOlxuICAgICAgICAgICAgYmFsYW5jZVJhbmdlKE5vZGVUeXBlLm5vbmUsIHRoaXMuY2hpbGRyZW4sIHRoaXMucG9zaXRpb25zLCAwLCB0aGlzLmNoaWxkcmVuLmxlbmd0aCwgMCwgdGhpcy5sZW5ndGgsIChjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgpID0+IG5ldyBUcmVlKHRoaXMudHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoLCB0aGlzLnByb3BWYWx1ZXMpLCBjb25maWcubWFrZVRyZWUgfHwgKChjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgpID0+IG5ldyBUcmVlKE5vZGVUeXBlLm5vbmUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQnVpbGQgYSB0cmVlIGZyb20gYSBwb3N0Zml4LW9yZGVyZWQgYnVmZmVyIG9mIG5vZGUgaW5mb3JtYXRpb24sXG4gICAgb3IgYSBjdXJzb3Igb3ZlciBzdWNoIGEgYnVmZmVyLlxuICAgICovXG4gICAgc3RhdGljIGJ1aWxkKGRhdGEpIHsgcmV0dXJuIGJ1aWxkVHJlZShkYXRhKTsgfVxufVxuLyoqXG5UaGUgZW1wdHkgdHJlZVxuKi9cblRyZWUuZW1wdHkgPSBuZXcgVHJlZShOb2RlVHlwZS5ub25lLCBbXSwgW10sIDApO1xuY2xhc3MgRmxhdEJ1ZmZlckN1cnNvciB7XG4gICAgY29uc3RydWN0b3IoYnVmZmVyLCBpbmRleCkge1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgIH1cbiAgICBnZXQgaWQoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gNF07IH1cbiAgICBnZXQgc3RhcnQoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gM107IH1cbiAgICBnZXQgZW5kKCkgeyByZXR1cm4gdGhpcy5idWZmZXJbdGhpcy5pbmRleCAtIDJdOyB9XG4gICAgZ2V0IHNpemUoKSB7IHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmluZGV4IC0gMV07IH1cbiAgICBnZXQgcG9zKCkgeyByZXR1cm4gdGhpcy5pbmRleDsgfVxuICAgIG5leHQoKSB7IHRoaXMuaW5kZXggLT0gNDsgfVxuICAgIGZvcmsoKSB7IHJldHVybiBuZXcgRmxhdEJ1ZmZlckN1cnNvcih0aGlzLmJ1ZmZlciwgdGhpcy5pbmRleCk7IH1cbn1cbi8qKlxuVHJlZSBidWZmZXJzIGNvbnRhaW4gKHR5cGUsIHN0YXJ0LCBlbmQsIGVuZEluZGV4KSBxdWFkcyBmb3IgZWFjaFxubm9kZS4gSW4gc3VjaCBhIGJ1ZmZlciwgbm9kZXMgYXJlIHN0b3JlZCBpbiBwcmVmaXggb3JkZXIgKHBhcmVudHNcbmJlZm9yZSBjaGlsZHJlbiwgd2l0aCB0aGUgZW5kSW5kZXggb2YgdGhlIHBhcmVudCBpbmRpY2F0aW5nIHdoaWNoXG5jaGlsZHJlbiBiZWxvbmcgdG8gaXQpLlxuKi9cbmNsYXNzIFRyZWVCdWZmZXIge1xuICAgIC8qKlxuICAgIENyZWF0ZSBhIHRyZWUgYnVmZmVyLlxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIGJ1ZmZlcidzIGNvbnRlbnQuXG4gICAgKi9cbiAgICBidWZmZXIsIFxuICAgIC8qKlxuICAgIFRoZSB0b3RhbCBsZW5ndGggb2YgdGhlIGdyb3VwIG9mIG5vZGVzIGluIHRoZSBidWZmZXIuXG4gICAgKi9cbiAgICBsZW5ndGgsIFxuICAgIC8qKlxuICAgIFRoZSBub2RlIHNldCB1c2VkIGluIHRoaXMgYnVmZmVyLlxuICAgICovXG4gICAgc2V0KSB7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdGhpcy5zZXQgPSBzZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgZ2V0IHR5cGUoKSB7IHJldHVybiBOb2RlVHlwZS5ub25lOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5idWZmZXIubGVuZ3RoOykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2godGhpcy5jaGlsZFN0cmluZyhpbmRleCkpO1xuICAgICAgICAgICAgaW5kZXggPSB0aGlzLmJ1ZmZlcltpbmRleCArIDNdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQuam9pbihcIixcIik7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY2hpbGRTdHJpbmcoaW5kZXgpIHtcbiAgICAgICAgbGV0IGlkID0gdGhpcy5idWZmZXJbaW5kZXhdLCBlbmRJbmRleCA9IHRoaXMuYnVmZmVyW2luZGV4ICsgM107XG4gICAgICAgIGxldCB0eXBlID0gdGhpcy5zZXQudHlwZXNbaWRdLCByZXN1bHQgPSB0eXBlLm5hbWU7XG4gICAgICAgIGlmICgvXFxXLy50ZXN0KHJlc3VsdCkgJiYgIXR5cGUuaXNFcnJvcilcbiAgICAgICAgICAgIHJlc3VsdCA9IEpTT04uc3RyaW5naWZ5KHJlc3VsdCk7XG4gICAgICAgIGluZGV4ICs9IDQ7XG4gICAgICAgIGlmIChlbmRJbmRleCA9PSBpbmRleClcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIGxldCBjaGlsZHJlbiA9IFtdO1xuICAgICAgICB3aGlsZSAoaW5kZXggPCBlbmRJbmRleCkge1xuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaCh0aGlzLmNoaWxkU3RyaW5nKGluZGV4KSk7XG4gICAgICAgICAgICBpbmRleCA9IHRoaXMuYnVmZmVyW2luZGV4ICsgM107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdCArIFwiKFwiICsgY2hpbGRyZW4uam9pbihcIixcIikgKyBcIilcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBmaW5kQ2hpbGQoc3RhcnRJbmRleCwgZW5kSW5kZXgsIGRpciwgcG9zLCBzaWRlKSB7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcywgcGljayA9IC0xO1xuICAgICAgICBmb3IgKGxldCBpID0gc3RhcnRJbmRleDsgaSAhPSBlbmRJbmRleDsgaSA9IGJ1ZmZlcltpICsgM10pIHtcbiAgICAgICAgICAgIGlmIChjaGVja1NpZGUoc2lkZSwgcG9zLCBidWZmZXJbaSArIDFdLCBidWZmZXJbaSArIDJdKSkge1xuICAgICAgICAgICAgICAgIHBpY2sgPSBpO1xuICAgICAgICAgICAgICAgIGlmIChkaXIgPiAwKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGljaztcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzbGljZShzdGFydEksIGVuZEksIGZyb20pIHtcbiAgICAgICAgbGV0IGIgPSB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgbGV0IGNvcHkgPSBuZXcgVWludDE2QXJyYXkoZW5kSSAtIHN0YXJ0SSksIGxlbiA9IDA7XG4gICAgICAgIGZvciAobGV0IGkgPSBzdGFydEksIGogPSAwOyBpIDwgZW5kSTspIHtcbiAgICAgICAgICAgIGNvcHlbaisrXSA9IGJbaSsrXTtcbiAgICAgICAgICAgIGNvcHlbaisrXSA9IGJbaSsrXSAtIGZyb207XG4gICAgICAgICAgICBsZXQgdG8gPSBjb3B5W2orK10gPSBiW2krK10gLSBmcm9tO1xuICAgICAgICAgICAgY29weVtqKytdID0gYltpKytdIC0gc3RhcnRJO1xuICAgICAgICAgICAgbGVuID0gTWF0aC5tYXgobGVuLCB0byk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlQnVmZmVyKGNvcHksIGxlbiwgdGhpcy5zZXQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNoZWNrU2lkZShzaWRlLCBwb3MsIGZyb20sIHRvKSB7XG4gICAgc3dpdGNoIChzaWRlKSB7XG4gICAgICAgIGNhc2UgLTIgLyogU2lkZS5CZWZvcmUgKi86IHJldHVybiBmcm9tIDwgcG9zO1xuICAgICAgICBjYXNlIC0xIC8qIFNpZGUuQXRPckJlZm9yZSAqLzogcmV0dXJuIHRvID49IHBvcyAmJiBmcm9tIDwgcG9zO1xuICAgICAgICBjYXNlIDAgLyogU2lkZS5Bcm91bmQgKi86IHJldHVybiBmcm9tIDwgcG9zICYmIHRvID4gcG9zO1xuICAgICAgICBjYXNlIDEgLyogU2lkZS5BdE9yQWZ0ZXIgKi86IHJldHVybiBmcm9tIDw9IHBvcyAmJiB0byA+IHBvcztcbiAgICAgICAgY2FzZSAyIC8qIFNpZGUuQWZ0ZXIgKi86IHJldHVybiB0byA+IHBvcztcbiAgICAgICAgY2FzZSA0IC8qIFNpZGUuRG9udENhcmUgKi86IHJldHVybiB0cnVlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlc29sdmVOb2RlKG5vZGUsIHBvcywgc2lkZSwgb3ZlcmxheXMpIHtcbiAgICB2YXIgX2E7XG4gICAgLy8gTW92ZSB1cCB0byBhIG5vZGUgdGhhdCBhY3R1YWxseSBob2xkcyB0aGUgcG9zaXRpb24sIGlmIHBvc3NpYmxlXG4gICAgd2hpbGUgKG5vZGUuZnJvbSA9PSBub2RlLnRvIHx8XG4gICAgICAgIChzaWRlIDwgMSA/IG5vZGUuZnJvbSA+PSBwb3MgOiBub2RlLmZyb20gPiBwb3MpIHx8XG4gICAgICAgIChzaWRlID4gLTEgPyBub2RlLnRvIDw9IHBvcyA6IG5vZGUudG8gPCBwb3MpKSB7XG4gICAgICAgIGxldCBwYXJlbnQgPSAhb3ZlcmxheXMgJiYgbm9kZSBpbnN0YW5jZW9mIFRyZWVOb2RlICYmIG5vZGUuaW5kZXggPCAwID8gbnVsbCA6IG5vZGUucGFyZW50O1xuICAgICAgICBpZiAoIXBhcmVudClcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICBub2RlID0gcGFyZW50O1xuICAgIH1cbiAgICBsZXQgbW9kZSA9IG92ZXJsYXlzID8gMCA6IEl0ZXJNb2RlLklnbm9yZU92ZXJsYXlzO1xuICAgIC8vIE11c3QgZ28gdXAgb3V0IG9mIG92ZXJsYXlzIHdoZW4gdGhvc2UgZG8gbm90IG92ZXJsYXAgd2l0aCBwb3NcbiAgICBpZiAob3ZlcmxheXMpXG4gICAgICAgIGZvciAobGV0IHNjYW4gPSBub2RlLCBwYXJlbnQgPSBzY2FuLnBhcmVudDsgcGFyZW50OyBzY2FuID0gcGFyZW50LCBwYXJlbnQgPSBzY2FuLnBhcmVudCkge1xuICAgICAgICAgICAgaWYgKHNjYW4gaW5zdGFuY2VvZiBUcmVlTm9kZSAmJiBzY2FuLmluZGV4IDwgMCAmJiAoKF9hID0gcGFyZW50LmVudGVyKHBvcywgc2lkZSwgbW9kZSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mcm9tKSAhPSBzY2FuLmZyb20pXG4gICAgICAgICAgICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICAgICAgfVxuICAgIGZvciAoOzspIHtcbiAgICAgICAgbGV0IGlubmVyID0gbm9kZS5lbnRlcihwb3MsIHNpZGUsIG1vZGUpO1xuICAgICAgICBpZiAoIWlubmVyKVxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIG5vZGUgPSBpbm5lcjtcbiAgICB9XG59XG5jbGFzcyBCYXNlTm9kZSB7XG4gICAgY3Vyc29yKG1vZGUgPSAwKSB7IHJldHVybiBuZXcgVHJlZUN1cnNvcih0aGlzLCBtb2RlKTsgfVxuICAgIGdldENoaWxkKHR5cGUsIGJlZm9yZSA9IG51bGwsIGFmdGVyID0gbnVsbCkge1xuICAgICAgICBsZXQgciA9IGdldENoaWxkcmVuKHRoaXMsIHR5cGUsIGJlZm9yZSwgYWZ0ZXIpO1xuICAgICAgICByZXR1cm4gci5sZW5ndGggPyByWzBdIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0Q2hpbGRyZW4odHlwZSwgYmVmb3JlID0gbnVsbCwgYWZ0ZXIgPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBnZXRDaGlsZHJlbih0aGlzLCB0eXBlLCBiZWZvcmUsIGFmdGVyKTtcbiAgICB9XG4gICAgcmVzb2x2ZShwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIHJldHVybiByZXNvbHZlTm9kZSh0aGlzLCBwb3MsIHNpZGUsIGZhbHNlKTtcbiAgICB9XG4gICAgcmVzb2x2ZUlubmVyKHBvcywgc2lkZSA9IDApIHtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVOb2RlKHRoaXMsIHBvcywgc2lkZSwgdHJ1ZSk7XG4gICAgfVxuICAgIG1hdGNoQ29udGV4dChjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBtYXRjaE5vZGVDb250ZXh0KHRoaXMsIGNvbnRleHQpO1xuICAgIH1cbiAgICBlbnRlclVuZmluaXNoZWROb2Rlc0JlZm9yZShwb3MpIHtcbiAgICAgICAgbGV0IHNjYW4gPSB0aGlzLmNoaWxkQmVmb3JlKHBvcyksIG5vZGUgPSB0aGlzO1xuICAgICAgICB3aGlsZSAoc2Nhbikge1xuICAgICAgICAgICAgbGV0IGxhc3QgPSBzY2FuLmxhc3RDaGlsZDtcbiAgICAgICAgICAgIGlmICghbGFzdCB8fCBsYXN0LnRvICE9IHNjYW4udG8pXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAobGFzdC50eXBlLmlzRXJyb3IgJiYgbGFzdC5mcm9tID09IGxhc3QudG8pIHtcbiAgICAgICAgICAgICAgICBub2RlID0gc2NhbjtcbiAgICAgICAgICAgICAgICBzY2FuID0gbGFzdC5wcmV2U2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNjYW4gPSBsYXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBnZXQgbm9kZSgpIHsgcmV0dXJuIHRoaXM7IH1cbiAgICBnZXQgbmV4dCgpIHsgcmV0dXJuIHRoaXMucGFyZW50OyB9XG59XG5jbGFzcyBUcmVlTm9kZSBleHRlbmRzIEJhc2VOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihfdHJlZSwgZnJvbSwgXG4gICAgLy8gSW5kZXggaW4gcGFyZW50IG5vZGUsIHNldCB0byAtMSBpZiB0aGUgbm9kZSBpcyBub3QgYSBkaXJlY3QgY2hpbGQgb2YgX3BhcmVudC5ub2RlIChvdmVybGF5KVxuICAgIGluZGV4LCBfcGFyZW50KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX3RyZWUgPSBfdHJlZTtcbiAgICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLl9wYXJlbnQgPSBfcGFyZW50O1xuICAgIH1cbiAgICBnZXQgdHlwZSgpIHsgcmV0dXJuIHRoaXMuX3RyZWUudHlwZTsgfVxuICAgIGdldCBuYW1lKCkgeyByZXR1cm4gdGhpcy5fdHJlZS50eXBlLm5hbWU7IH1cbiAgICBnZXQgdG8oKSB7IHJldHVybiB0aGlzLmZyb20gKyB0aGlzLl90cmVlLmxlbmd0aDsgfVxuICAgIG5leHRDaGlsZChpLCBkaXIsIHBvcywgc2lkZSwgbW9kZSA9IDApIHtcbiAgICAgICAgZm9yIChsZXQgcGFyZW50ID0gdGhpczs7KSB7XG4gICAgICAgICAgICBmb3IgKGxldCB7IGNoaWxkcmVuLCBwb3NpdGlvbnMgfSA9IHBhcmVudC5fdHJlZSwgZSA9IGRpciA+IDAgPyBjaGlsZHJlbi5sZW5ndGggOiAtMTsgaSAhPSBlOyBpICs9IGRpcikge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0ID0gY2hpbGRyZW5baV0sIHN0YXJ0ID0gcG9zaXRpb25zW2ldICsgcGFyZW50LmZyb207XG4gICAgICAgICAgICAgICAgaWYgKCFjaGVja1NpZGUoc2lkZSwgcG9zLCBzdGFydCwgc3RhcnQgKyBuZXh0Lmxlbmd0aCkpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0IGluc3RhbmNlb2YgVHJlZUJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAobW9kZSAmIEl0ZXJNb2RlLkV4Y2x1ZGVCdWZmZXJzKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpbmRleCA9IG5leHQuZmluZENoaWxkKDAsIG5leHQuYnVmZmVyLmxlbmd0aCwgZGlyLCBwb3MgLSBzdGFydCwgc2lkZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXJOb2RlKG5ldyBCdWZmZXJDb250ZXh0KHBhcmVudCwgbmV4dCwgaSwgc3RhcnQpLCBudWxsLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChtb2RlICYgSXRlck1vZGUuSW5jbHVkZUFub255bW91cykgfHwgKCFuZXh0LnR5cGUuaXNBbm9ueW1vdXMgfHwgaGFzQ2hpbGQobmV4dCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBtb3VudGVkO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShtb2RlICYgSXRlck1vZGUuSWdub3JlTW91bnRzKSAmJiAobW91bnRlZCA9IE1vdW50ZWRUcmVlLmdldChuZXh0KSkgJiYgIW1vdW50ZWQub3ZlcmxheSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVHJlZU5vZGUobW91bnRlZC50cmVlLCBzdGFydCwgaSwgcGFyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGlubmVyID0gbmV3IFRyZWVOb2RlKG5leHQsIHN0YXJ0LCBpLCBwYXJlbnQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKG1vZGUgJiBJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzKSB8fCAhaW5uZXIudHlwZS5pc0Fub255bW91cyA/IGlubmVyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGlubmVyLm5leHRDaGlsZChkaXIgPCAwID8gbmV4dC5jaGlsZHJlbi5sZW5ndGggLSAxIDogMCwgZGlyLCBwb3MsIHNpZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgobW9kZSAmIEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMpIHx8ICFwYXJlbnQudHlwZS5pc0Fub255bW91cylcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIGlmIChwYXJlbnQuaW5kZXggPj0gMClcbiAgICAgICAgICAgICAgICBpID0gcGFyZW50LmluZGV4ICsgZGlyO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGkgPSBkaXIgPCAwID8gLTEgOiBwYXJlbnQuX3BhcmVudC5fdHJlZS5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgICAgICBwYXJlbnQgPSBwYXJlbnQuX3BhcmVudDtcbiAgICAgICAgICAgIGlmICghcGFyZW50KVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBmaXJzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5uZXh0Q2hpbGQoMCwgMSwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovKTsgfVxuICAgIGdldCBsYXN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLm5leHRDaGlsZCh0aGlzLl90cmVlLmNoaWxkcmVuLmxlbmd0aCAtIDEsIC0xLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pOyB9XG4gICAgY2hpbGRBZnRlcihwb3MpIHsgcmV0dXJuIHRoaXMubmV4dENoaWxkKDAsIDEsIHBvcywgMiAvKiBTaWRlLkFmdGVyICovKTsgfVxuICAgIGNoaWxkQmVmb3JlKHBvcykgeyByZXR1cm4gdGhpcy5uZXh0Q2hpbGQodGhpcy5fdHJlZS5jaGlsZHJlbi5sZW5ndGggLSAxLCAtMSwgcG9zLCAtMiAvKiBTaWRlLkJlZm9yZSAqLyk7IH1cbiAgICBlbnRlcihwb3MsIHNpZGUsIG1vZGUgPSAwKSB7XG4gICAgICAgIGxldCBtb3VudGVkO1xuICAgICAgICBpZiAoIShtb2RlICYgSXRlck1vZGUuSWdub3JlT3ZlcmxheXMpICYmIChtb3VudGVkID0gTW91bnRlZFRyZWUuZ2V0KHRoaXMuX3RyZWUpKSAmJiBtb3VudGVkLm92ZXJsYXkpIHtcbiAgICAgICAgICAgIGxldCByUG9zID0gcG9zIC0gdGhpcy5mcm9tO1xuICAgICAgICAgICAgZm9yIChsZXQgeyBmcm9tLCB0byB9IG9mIG1vdW50ZWQub3ZlcmxheSkge1xuICAgICAgICAgICAgICAgIGlmICgoc2lkZSA+IDAgPyBmcm9tIDw9IHJQb3MgOiBmcm9tIDwgclBvcykgJiZcbiAgICAgICAgICAgICAgICAgICAgKHNpZGUgPCAwID8gdG8gPj0gclBvcyA6IHRvID4gclBvcykpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgVHJlZU5vZGUobW91bnRlZC50cmVlLCBtb3VudGVkLm92ZXJsYXlbMF0uZnJvbSArIHRoaXMuZnJvbSwgLTEsIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm5leHRDaGlsZCgwLCAxLCBwb3MsIHNpZGUsIG1vZGUpO1xuICAgIH1cbiAgICBuZXh0U2lnbmlmaWNhbnRQYXJlbnQoKSB7XG4gICAgICAgIGxldCB2YWwgPSB0aGlzO1xuICAgICAgICB3aGlsZSAodmFsLnR5cGUuaXNBbm9ueW1vdXMgJiYgdmFsLl9wYXJlbnQpXG4gICAgICAgICAgICB2YWwgPSB2YWwuX3BhcmVudDtcbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9XG4gICAgZ2V0IHBhcmVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCA/IHRoaXMuX3BhcmVudC5uZXh0U2lnbmlmaWNhbnRQYXJlbnQoKSA6IG51bGw7XG4gICAgfVxuICAgIGdldCBuZXh0U2libGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCAmJiB0aGlzLmluZGV4ID49IDAgPyB0aGlzLl9wYXJlbnQubmV4dENoaWxkKHRoaXMuaW5kZXggKyAxLCAxLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0IHByZXZTaWJsaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50ICYmIHRoaXMuaW5kZXggPj0gMCA/IHRoaXMuX3BhcmVudC5uZXh0Q2hpbGQodGhpcy5pbmRleCAtIDEsIC0xLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pIDogbnVsbDtcbiAgICB9XG4gICAgZ2V0IHRyZWUoKSB7IHJldHVybiB0aGlzLl90cmVlOyB9XG4gICAgdG9UcmVlKCkgeyByZXR1cm4gdGhpcy5fdHJlZTsgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgdG9TdHJpbmcoKSB7IHJldHVybiB0aGlzLl90cmVlLnRvU3RyaW5nKCk7IH1cbn1cbmZ1bmN0aW9uIGdldENoaWxkcmVuKG5vZGUsIHR5cGUsIGJlZm9yZSwgYWZ0ZXIpIHtcbiAgICBsZXQgY3VyID0gbm9kZS5jdXJzb3IoKSwgcmVzdWx0ID0gW107XG4gICAgaWYgKCFjdXIuZmlyc3RDaGlsZCgpKVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIGlmIChiZWZvcmUgIT0gbnVsbClcbiAgICAgICAgZm9yIChsZXQgZm91bmQgPSBmYWxzZTsgIWZvdW5kOykge1xuICAgICAgICAgICAgZm91bmQgPSBjdXIudHlwZS5pcyhiZWZvcmUpO1xuICAgICAgICAgICAgaWYgKCFjdXIubmV4dFNpYmxpbmcoKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgZm9yICg7Oykge1xuICAgICAgICBpZiAoYWZ0ZXIgIT0gbnVsbCAmJiBjdXIudHlwZS5pcyhhZnRlcikpXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICBpZiAoY3VyLnR5cGUuaXModHlwZSkpXG4gICAgICAgICAgICByZXN1bHQucHVzaChjdXIubm9kZSk7XG4gICAgICAgIGlmICghY3VyLm5leHRTaWJsaW5nKCkpXG4gICAgICAgICAgICByZXR1cm4gYWZ0ZXIgPT0gbnVsbCA/IHJlc3VsdCA6IFtdO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1hdGNoTm9kZUNvbnRleHQobm9kZSwgY29udGV4dCwgaSA9IGNvbnRleHQubGVuZ3RoIC0gMSkge1xuICAgIGZvciAobGV0IHAgPSBub2RlLnBhcmVudDsgaSA+PSAwOyBwID0gcC5wYXJlbnQpIHtcbiAgICAgICAgaWYgKCFwKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoIXAudHlwZS5pc0Fub255bW91cykge1xuICAgICAgICAgICAgaWYgKGNvbnRleHRbaV0gJiYgY29udGV4dFtpXSAhPSBwLm5hbWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuY2xhc3MgQnVmZmVyQ29udGV4dCB7XG4gICAgY29uc3RydWN0b3IocGFyZW50LCBidWZmZXIsIGluZGV4LCBzdGFydCkge1xuICAgICAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gICAgICAgIHRoaXMuaW5kZXggPSBpbmRleDtcbiAgICAgICAgdGhpcy5zdGFydCA9IHN0YXJ0O1xuICAgIH1cbn1cbmNsYXNzIEJ1ZmZlck5vZGUgZXh0ZW5kcyBCYXNlTm9kZSB7XG4gICAgZ2V0IG5hbWUoKSB7IHJldHVybiB0aGlzLnR5cGUubmFtZTsgfVxuICAgIGdldCBmcm9tKCkgeyByZXR1cm4gdGhpcy5jb250ZXh0LnN0YXJ0ICsgdGhpcy5jb250ZXh0LmJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDFdOyB9XG4gICAgZ2V0IHRvKCkgeyByZXR1cm4gdGhpcy5jb250ZXh0LnN0YXJ0ICsgdGhpcy5jb250ZXh0LmJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDJdOyB9XG4gICAgY29uc3RydWN0b3IoY29udGV4dCwgX3BhcmVudCwgaW5kZXgpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gX3BhcmVudDtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLnR5cGUgPSBjb250ZXh0LmJ1ZmZlci5zZXQudHlwZXNbY29udGV4dC5idWZmZXIuYnVmZmVyW2luZGV4XV07XG4gICAgfVxuICAgIGNoaWxkKGRpciwgcG9zLCBzaWRlKSB7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcy5jb250ZXh0O1xuICAgICAgICBsZXQgaW5kZXggPSBidWZmZXIuZmluZENoaWxkKHRoaXMuaW5kZXggKyA0LCBidWZmZXIuYnVmZmVyW3RoaXMuaW5kZXggKyAzXSwgZGlyLCBwb3MgLSB0aGlzLmNvbnRleHQuc3RhcnQsIHNpZGUpO1xuICAgICAgICByZXR1cm4gaW5kZXggPCAwID8gbnVsbCA6IG5ldyBCdWZmZXJOb2RlKHRoaXMuY29udGV4dCwgdGhpcywgaW5kZXgpO1xuICAgIH1cbiAgICBnZXQgZmlyc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuY2hpbGQoMSwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovKTsgfVxuICAgIGdldCBsYXN0Q2hpbGQoKSB7IHJldHVybiB0aGlzLmNoaWxkKC0xLCAwLCA0IC8qIFNpZGUuRG9udENhcmUgKi8pOyB9XG4gICAgY2hpbGRBZnRlcihwb3MpIHsgcmV0dXJuIHRoaXMuY2hpbGQoMSwgcG9zLCAyIC8qIFNpZGUuQWZ0ZXIgKi8pOyB9XG4gICAgY2hpbGRCZWZvcmUocG9zKSB7IHJldHVybiB0aGlzLmNoaWxkKC0xLCBwb3MsIC0yIC8qIFNpZGUuQmVmb3JlICovKTsgfVxuICAgIGVudGVyKHBvcywgc2lkZSwgbW9kZSA9IDApIHtcbiAgICAgICAgaWYgKG1vZGUgJiBJdGVyTW9kZS5FeGNsdWRlQnVmZmVycylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IGluZGV4ID0gYnVmZmVyLmZpbmRDaGlsZCh0aGlzLmluZGV4ICsgNCwgYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgM10sIHNpZGUgPiAwID8gMSA6IC0xLCBwb3MgLSB0aGlzLmNvbnRleHQuc3RhcnQsIHNpZGUpO1xuICAgICAgICByZXR1cm4gaW5kZXggPCAwID8gbnVsbCA6IG5ldyBCdWZmZXJOb2RlKHRoaXMuY29udGV4dCwgdGhpcywgaW5kZXgpO1xuICAgIH1cbiAgICBnZXQgcGFyZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGFyZW50IHx8IHRoaXMuY29udGV4dC5wYXJlbnQubmV4dFNpZ25pZmljYW50UGFyZW50KCk7XG4gICAgfVxuICAgIGV4dGVybmFsU2libGluZyhkaXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudCA/IG51bGwgOiB0aGlzLmNvbnRleHQucGFyZW50Lm5leHRDaGlsZCh0aGlzLmNvbnRleHQuaW5kZXggKyBkaXIsIGRpciwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovKTtcbiAgICB9XG4gICAgZ2V0IG5leHRTaWJsaW5nKCkge1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IGFmdGVyID0gYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgM107XG4gICAgICAgIGlmIChhZnRlciA8ICh0aGlzLl9wYXJlbnQgPyBidWZmZXIuYnVmZmVyW3RoaXMuX3BhcmVudC5pbmRleCArIDNdIDogYnVmZmVyLmJ1ZmZlci5sZW5ndGgpKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXJOb2RlKHRoaXMuY29udGV4dCwgdGhpcy5fcGFyZW50LCBhZnRlcik7XG4gICAgICAgIHJldHVybiB0aGlzLmV4dGVybmFsU2libGluZygxKTtcbiAgICB9XG4gICAgZ2V0IHByZXZTaWJsaW5nKCkge1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IHBhcmVudFN0YXJ0ID0gdGhpcy5fcGFyZW50ID8gdGhpcy5fcGFyZW50LmluZGV4ICsgNCA6IDA7XG4gICAgICAgIGlmICh0aGlzLmluZGV4ID09IHBhcmVudFN0YXJ0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXh0ZXJuYWxTaWJsaW5nKC0xKTtcbiAgICAgICAgcmV0dXJuIG5ldyBCdWZmZXJOb2RlKHRoaXMuY29udGV4dCwgdGhpcy5fcGFyZW50LCBidWZmZXIuZmluZENoaWxkKHBhcmVudFN0YXJ0LCB0aGlzLmluZGV4LCAtMSwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovKSk7XG4gICAgfVxuICAgIGdldCB0cmVlKCkgeyByZXR1cm4gbnVsbDsgfVxuICAgIHRvVHJlZSgpIHtcbiAgICAgICAgbGV0IGNoaWxkcmVuID0gW10sIHBvc2l0aW9ucyA9IFtdO1xuICAgICAgICBsZXQgeyBidWZmZXIgfSA9IHRoaXMuY29udGV4dDtcbiAgICAgICAgbGV0IHN0YXJ0SSA9IHRoaXMuaW5kZXggKyA0LCBlbmRJID0gYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgM107XG4gICAgICAgIGlmIChlbmRJID4gc3RhcnRJKSB7XG4gICAgICAgICAgICBsZXQgZnJvbSA9IGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDFdO1xuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChidWZmZXIuc2xpY2Uoc3RhcnRJLCBlbmRJLCBmcm9tKSk7XG4gICAgICAgICAgICBwb3NpdGlvbnMucHVzaCgwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFRyZWUodGhpcy50eXBlLCBjaGlsZHJlbiwgcG9zaXRpb25zLCB0aGlzLnRvIC0gdGhpcy5mcm9tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0b1N0cmluZygpIHsgcmV0dXJuIHRoaXMuY29udGV4dC5idWZmZXIuY2hpbGRTdHJpbmcodGhpcy5pbmRleCk7IH1cbn1cbmZ1bmN0aW9uIGl0ZXJTdGFjayhoZWFkcykge1xuICAgIGlmICghaGVhZHMubGVuZ3RoKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBsZXQgcGljayA9IDAsIHBpY2tlZCA9IGhlYWRzWzBdO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgaGVhZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IG5vZGUgPSBoZWFkc1tpXTtcbiAgICAgICAgaWYgKG5vZGUuZnJvbSA+IHBpY2tlZC5mcm9tIHx8IG5vZGUudG8gPCBwaWNrZWQudG8pIHtcbiAgICAgICAgICAgIHBpY2tlZCA9IG5vZGU7XG4gICAgICAgICAgICBwaWNrID0gaTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgbmV4dCA9IHBpY2tlZCBpbnN0YW5jZW9mIFRyZWVOb2RlICYmIHBpY2tlZC5pbmRleCA8IDAgPyBudWxsIDogcGlja2VkLnBhcmVudDtcbiAgICBsZXQgbmV3SGVhZHMgPSBoZWFkcy5zbGljZSgpO1xuICAgIGlmIChuZXh0KVxuICAgICAgICBuZXdIZWFkc1twaWNrXSA9IG5leHQ7XG4gICAgZWxzZVxuICAgICAgICBuZXdIZWFkcy5zcGxpY2UocGljaywgMSk7XG4gICAgcmV0dXJuIG5ldyBTdGFja0l0ZXJhdG9yKG5ld0hlYWRzLCBwaWNrZWQpO1xufVxuY2xhc3MgU3RhY2tJdGVyYXRvciB7XG4gICAgY29uc3RydWN0b3IoaGVhZHMsIG5vZGUpIHtcbiAgICAgICAgdGhpcy5oZWFkcyA9IGhlYWRzO1xuICAgICAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgIH1cbiAgICBnZXQgbmV4dCgpIHsgcmV0dXJuIGl0ZXJTdGFjayh0aGlzLmhlYWRzKTsgfVxufVxuZnVuY3Rpb24gc3RhY2tJdGVyYXRvcih0cmVlLCBwb3MsIHNpZGUpIHtcbiAgICBsZXQgaW5uZXIgPSB0cmVlLnJlc29sdmVJbm5lcihwb3MsIHNpZGUpLCBsYXllcnMgPSBudWxsO1xuICAgIGZvciAobGV0IHNjYW4gPSBpbm5lciBpbnN0YW5jZW9mIFRyZWVOb2RlID8gaW5uZXIgOiBpbm5lci5jb250ZXh0LnBhcmVudDsgc2Nhbjsgc2NhbiA9IHNjYW4ucGFyZW50KSB7XG4gICAgICAgIGlmIChzY2FuLmluZGV4IDwgMCkgeyAvLyBUaGlzIGlzIGFuIG92ZXJsYXkgcm9vdFxuICAgICAgICAgICAgbGV0IHBhcmVudCA9IHNjYW4ucGFyZW50O1xuICAgICAgICAgICAgKGxheWVycyB8fCAobGF5ZXJzID0gW2lubmVyXSkpLnB1c2gocGFyZW50LnJlc29sdmUocG9zLCBzaWRlKSk7XG4gICAgICAgICAgICBzY2FuID0gcGFyZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IG1vdW50ID0gTW91bnRlZFRyZWUuZ2V0KHNjYW4udHJlZSk7XG4gICAgICAgICAgICAvLyBSZWxldmFudCBvdmVybGF5IGJyYW5jaGluZyBvZmZcbiAgICAgICAgICAgIGlmIChtb3VudCAmJiBtb3VudC5vdmVybGF5ICYmIG1vdW50Lm92ZXJsYXlbMF0uZnJvbSA8PSBwb3MgJiYgbW91bnQub3ZlcmxheVttb3VudC5vdmVybGF5Lmxlbmd0aCAtIDFdLnRvID49IHBvcykge1xuICAgICAgICAgICAgICAgIGxldCByb290ID0gbmV3IFRyZWVOb2RlKG1vdW50LnRyZWUsIG1vdW50Lm92ZXJsYXlbMF0uZnJvbSArIHNjYW4uZnJvbSwgLTEsIHNjYW4pO1xuICAgICAgICAgICAgICAgIChsYXllcnMgfHwgKGxheWVycyA9IFtpbm5lcl0pKS5wdXNoKHJlc29sdmVOb2RlKHJvb3QsIHBvcywgc2lkZSwgZmFsc2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbGF5ZXJzID8gaXRlclN0YWNrKGxheWVycykgOiBpbm5lcjtcbn1cbi8qKlxuQSB0cmVlIGN1cnNvciBvYmplY3QgZm9jdXNlcyBvbiBhIGdpdmVuIG5vZGUgaW4gYSBzeW50YXggdHJlZSwgYW5kXG5hbGxvd3MgeW91IHRvIG1vdmUgdG8gYWRqYWNlbnQgbm9kZXMuXG4qL1xuY2xhc3MgVHJlZUN1cnNvciB7XG4gICAgLyoqXG4gICAgU2hvcnRoYW5kIGZvciBgLnR5cGUubmFtZWAuXG4gICAgKi9cbiAgICBnZXQgbmFtZSgpIHsgcmV0dXJuIHRoaXMudHlwZS5uYW1lOyB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihub2RlLCBcbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIG1vZGUgPSAwKSB7XG4gICAgICAgIHRoaXMubW9kZSA9IG1vZGU7XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5idWZmZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnN0YWNrID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICBAaW50ZXJuYWxcbiAgICAgICAgKi9cbiAgICAgICAgdGhpcy5pbmRleCA9IDA7XG4gICAgICAgIHRoaXMuYnVmZmVyTm9kZSA9IG51bGw7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgVHJlZU5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMueWllbGROb2RlKG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fdHJlZSA9IG5vZGUuY29udGV4dC5wYXJlbnQ7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlciA9IG5vZGUuY29udGV4dDtcbiAgICAgICAgICAgIGZvciAobGV0IG4gPSBub2RlLl9wYXJlbnQ7IG47IG4gPSBuLl9wYXJlbnQpXG4gICAgICAgICAgICAgICAgdGhpcy5zdGFjay51bnNoaWZ0KG4uaW5kZXgpO1xuICAgICAgICAgICAgdGhpcy5idWZmZXJOb2RlID0gbm9kZTtcbiAgICAgICAgICAgIHRoaXMueWllbGRCdWYobm9kZS5pbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgeWllbGROb2RlKG5vZGUpIHtcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB0aGlzLl90cmVlID0gbm9kZTtcbiAgICAgICAgdGhpcy50eXBlID0gbm9kZS50eXBlO1xuICAgICAgICB0aGlzLmZyb20gPSBub2RlLmZyb207XG4gICAgICAgIHRoaXMudG8gPSBub2RlLnRvO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgeWllbGRCdWYoaW5kZXgsIHR5cGUpIHtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICBsZXQgeyBzdGFydCwgYnVmZmVyIH0gPSB0aGlzLmJ1ZmZlcjtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZSB8fCBidWZmZXIuc2V0LnR5cGVzW2J1ZmZlci5idWZmZXJbaW5kZXhdXTtcbiAgICAgICAgdGhpcy5mcm9tID0gc3RhcnQgKyBidWZmZXIuYnVmZmVyW2luZGV4ICsgMV07XG4gICAgICAgIHRoaXMudG8gPSBzdGFydCArIGJ1ZmZlci5idWZmZXJbaW5kZXggKyAyXTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgeWllbGQobm9kZSkge1xuICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgVHJlZU5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkTm9kZShub2RlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJ1ZmZlciA9IG5vZGUuY29udGV4dDtcbiAgICAgICAgcmV0dXJuIHRoaXMueWllbGRCdWYobm9kZS5pbmRleCwgbm9kZS50eXBlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyID8gdGhpcy5idWZmZXIuYnVmZmVyLmNoaWxkU3RyaW5nKHRoaXMuaW5kZXgpIDogdGhpcy5fdHJlZS50b1N0cmluZygpO1xuICAgIH1cbiAgICAvKipcbiAgICBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGVudGVyQ2hpbGQoZGlyLCBwb3MsIHNpZGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJ1ZmZlcilcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnlpZWxkKHRoaXMuX3RyZWUubmV4dENoaWxkKGRpciA8IDAgPyB0aGlzLl90cmVlLl90cmVlLmNoaWxkcmVuLmxlbmd0aCAtIDEgOiAwLCBkaXIsIHBvcywgc2lkZSwgdGhpcy5tb2RlKSk7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcy5idWZmZXI7XG4gICAgICAgIGxldCBpbmRleCA9IGJ1ZmZlci5maW5kQ2hpbGQodGhpcy5pbmRleCArIDQsIGJ1ZmZlci5idWZmZXJbdGhpcy5pbmRleCArIDNdLCBkaXIsIHBvcyAtIHRoaXMuYnVmZmVyLnN0YXJ0LCBzaWRlKTtcbiAgICAgICAgaWYgKGluZGV4IDwgMClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgdGhpcy5zdGFjay5wdXNoKHRoaXMuaW5kZXgpO1xuICAgICAgICByZXR1cm4gdGhpcy55aWVsZEJ1ZihpbmRleCk7XG4gICAgfVxuICAgIC8qKlxuICAgIE1vdmUgdGhlIGN1cnNvciB0byB0aGlzIG5vZGUncyBmaXJzdCBjaGlsZC4gV2hlbiB0aGlzIHJldHVybnNcbiAgICBmYWxzZSwgdGhlIG5vZGUgaGFzIG5vIGNoaWxkLCBhbmQgdGhlIGN1cnNvciBoYXMgbm90IGJlZW4gbW92ZWQuXG4gICAgKi9cbiAgICBmaXJzdENoaWxkKCkgeyByZXR1cm4gdGhpcy5lbnRlckNoaWxkKDEsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLyk7IH1cbiAgICAvKipcbiAgICBNb3ZlIHRoZSBjdXJzb3IgdG8gdGhpcyBub2RlJ3MgbGFzdCBjaGlsZC5cbiAgICAqL1xuICAgIGxhc3RDaGlsZCgpIHsgcmV0dXJuIHRoaXMuZW50ZXJDaGlsZCgtMSwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovKTsgfVxuICAgIC8qKlxuICAgIE1vdmUgdGhlIGN1cnNvciB0byB0aGUgZmlyc3QgY2hpbGQgdGhhdCBlbmRzIGFmdGVyIGBwb3NgLlxuICAgICovXG4gICAgY2hpbGRBZnRlcihwb3MpIHsgcmV0dXJuIHRoaXMuZW50ZXJDaGlsZCgxLCBwb3MsIDIgLyogU2lkZS5BZnRlciAqLyk7IH1cbiAgICAvKipcbiAgICBNb3ZlIHRvIHRoZSBsYXN0IGNoaWxkIHRoYXQgc3RhcnRzIGJlZm9yZSBgcG9zYC5cbiAgICAqL1xuICAgIGNoaWxkQmVmb3JlKHBvcykgeyByZXR1cm4gdGhpcy5lbnRlckNoaWxkKC0xLCBwb3MsIC0yIC8qIFNpZGUuQmVmb3JlICovKTsgfVxuICAgIC8qKlxuICAgIE1vdmUgdGhlIGN1cnNvciB0byB0aGUgY2hpbGQgYXJvdW5kIGBwb3NgLiBJZiBzaWRlIGlzIC0xIHRoZVxuICAgIGNoaWxkIG1heSBlbmQgYXQgdGhhdCBwb3NpdGlvbiwgd2hlbiAxIGl0IG1heSBzdGFydCB0aGVyZS4gVGhpc1xuICAgIHdpbGwgYWxzbyBlbnRlciBbb3ZlcmxhaWRdKCNjb21tb24uTW91bnRlZFRyZWUub3ZlcmxheSlcbiAgICBbbW91bnRlZF0oI2NvbW1vbi5Ob2RlUHJvcF5tb3VudGVkKSB0cmVlcyB1bmxlc3MgYG92ZXJsYXlzYCBpc1xuICAgIHNldCB0byBmYWxzZS5cbiAgICAqL1xuICAgIGVudGVyKHBvcywgc2lkZSwgbW9kZSA9IHRoaXMubW9kZSkge1xuICAgICAgICBpZiAoIXRoaXMuYnVmZmVyKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGQodGhpcy5fdHJlZS5lbnRlcihwb3MsIHNpZGUsIG1vZGUpKTtcbiAgICAgICAgcmV0dXJuIG1vZGUgJiBJdGVyTW9kZS5FeGNsdWRlQnVmZmVycyA/IGZhbHNlIDogdGhpcy5lbnRlckNoaWxkKDEsIHBvcywgc2lkZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIE1vdmUgdG8gdGhlIG5vZGUncyBwYXJlbnQgbm9kZSwgaWYgdGhpcyBpc24ndCB0aGUgdG9wIG5vZGUuXG4gICAgKi9cbiAgICBwYXJlbnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZE5vZGUoKHRoaXMubW9kZSAmIEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMpID8gdGhpcy5fdHJlZS5fcGFyZW50IDogdGhpcy5fdHJlZS5wYXJlbnQpO1xuICAgICAgICBpZiAodGhpcy5zdGFjay5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZEJ1Zih0aGlzLnN0YWNrLnBvcCgpKTtcbiAgICAgICAgbGV0IHBhcmVudCA9ICh0aGlzLm1vZGUgJiBJdGVyTW9kZS5JbmNsdWRlQW5vbnltb3VzKSA/IHRoaXMuYnVmZmVyLnBhcmVudCA6IHRoaXMuYnVmZmVyLnBhcmVudC5uZXh0U2lnbmlmaWNhbnRQYXJlbnQoKTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBudWxsO1xuICAgICAgICByZXR1cm4gdGhpcy55aWVsZE5vZGUocGFyZW50KTtcbiAgICB9XG4gICAgLyoqXG4gICAgQGludGVybmFsXG4gICAgKi9cbiAgICBzaWJsaW5nKGRpcikge1xuICAgICAgICBpZiAoIXRoaXMuYnVmZmVyKVxuICAgICAgICAgICAgcmV0dXJuICF0aGlzLl90cmVlLl9wYXJlbnQgPyBmYWxzZVxuICAgICAgICAgICAgICAgIDogdGhpcy55aWVsZCh0aGlzLl90cmVlLmluZGV4IDwgMCA/IG51bGxcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLl90cmVlLl9wYXJlbnQubmV4dENoaWxkKHRoaXMuX3RyZWUuaW5kZXggKyBkaXIsIGRpciwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovLCB0aGlzLm1vZGUpKTtcbiAgICAgICAgbGV0IHsgYnVmZmVyIH0gPSB0aGlzLmJ1ZmZlciwgZCA9IHRoaXMuc3RhY2subGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKGRpciA8IDApIHtcbiAgICAgICAgICAgIGxldCBwYXJlbnRTdGFydCA9IGQgPCAwID8gMCA6IHRoaXMuc3RhY2tbZF0gKyA0O1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5kZXggIT0gcGFyZW50U3RhcnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMueWllbGRCdWYoYnVmZmVyLmZpbmRDaGlsZChwYXJlbnRTdGFydCwgdGhpcy5pbmRleCwgLTEsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGFmdGVyID0gYnVmZmVyLmJ1ZmZlclt0aGlzLmluZGV4ICsgM107XG4gICAgICAgICAgICBpZiAoYWZ0ZXIgPCAoZCA8IDAgPyBidWZmZXIuYnVmZmVyLmxlbmd0aCA6IGJ1ZmZlci5idWZmZXJbdGhpcy5zdGFja1tkXSArIDNdKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy55aWVsZEJ1ZihhZnRlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGQgPCAwID8gdGhpcy55aWVsZCh0aGlzLmJ1ZmZlci5wYXJlbnQubmV4dENoaWxkKHRoaXMuYnVmZmVyLmluZGV4ICsgZGlyLCBkaXIsIDAsIDQgLyogU2lkZS5Eb250Q2FyZSAqLywgdGhpcy5tb2RlKSkgOiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgTW92ZSB0byB0aGlzIG5vZGUncyBuZXh0IHNpYmxpbmcsIGlmIGFueS5cbiAgICAqL1xuICAgIG5leHRTaWJsaW5nKCkgeyByZXR1cm4gdGhpcy5zaWJsaW5nKDEpOyB9XG4gICAgLyoqXG4gICAgTW92ZSB0byB0aGlzIG5vZGUncyBwcmV2aW91cyBzaWJsaW5nLCBpZiBhbnkuXG4gICAgKi9cbiAgICBwcmV2U2libGluZygpIHsgcmV0dXJuIHRoaXMuc2libGluZygtMSk7IH1cbiAgICBhdExhc3ROb2RlKGRpcikge1xuICAgICAgICBsZXQgaW5kZXgsIHBhcmVudCwgeyBidWZmZXIgfSA9IHRoaXM7XG4gICAgICAgIGlmIChidWZmZXIpIHtcbiAgICAgICAgICAgIGlmIChkaXIgPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaW5kZXggPCBidWZmZXIuYnVmZmVyLmJ1ZmZlci5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5pbmRleDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICBpZiAoYnVmZmVyLmJ1ZmZlci5idWZmZXJbaSArIDNdIDwgdGhpcy5pbmRleClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICh7IGluZGV4LCBwYXJlbnQgfSA9IGJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAoeyBpbmRleCwgX3BhcmVudDogcGFyZW50IH0gPSB0aGlzLl90cmVlKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKDsgcGFyZW50OyB7IGluZGV4LCBfcGFyZW50OiBwYXJlbnQgfSA9IHBhcmVudCkge1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IGluZGV4ICsgZGlyLCBlID0gZGlyIDwgMCA/IC0xIDogcGFyZW50Ll90cmVlLmNoaWxkcmVuLmxlbmd0aDsgaSAhPSBlOyBpICs9IGRpcikge1xuICAgICAgICAgICAgICAgICAgICBsZXQgY2hpbGQgPSBwYXJlbnQuX3RyZWUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgICAgIGlmICgodGhpcy5tb2RlICYgSXRlck1vZGUuSW5jbHVkZUFub255bW91cykgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkIGluc3RhbmNlb2YgVHJlZUJ1ZmZlciB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgIWNoaWxkLnR5cGUuaXNBbm9ueW1vdXMgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0NoaWxkKGNoaWxkKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIG1vdmUoZGlyLCBlbnRlcikge1xuICAgICAgICBpZiAoZW50ZXIgJiYgdGhpcy5lbnRlckNoaWxkKGRpciwgMCwgNCAvKiBTaWRlLkRvbnRDYXJlICovKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zaWJsaW5nKGRpcikpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBpZiAodGhpcy5hdExhc3ROb2RlKGRpcikgfHwgIXRoaXMucGFyZW50KCkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgIE1vdmUgdG8gdGhlIG5leHQgbm9kZSBpbiBhXG4gICAgW3ByZS1vcmRlcl0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVHJlZV90cmF2ZXJzYWwjUHJlLW9yZGVyLF9OTFIpXG4gICAgdHJhdmVyc2FsLCBnb2luZyBmcm9tIGEgbm9kZSB0byBpdHMgZmlyc3QgY2hpbGQgb3IsIGlmIHRoZVxuICAgIGN1cnJlbnQgbm9kZSBpcyBlbXB0eSBvciBgZW50ZXJgIGlzIGZhbHNlLCBpdHMgbmV4dCBzaWJsaW5nIG9yXG4gICAgdGhlIG5leHQgc2libGluZyBvZiB0aGUgZmlyc3QgcGFyZW50IG5vZGUgdGhhdCBoYXMgb25lLlxuICAgICovXG4gICAgbmV4dChlbnRlciA9IHRydWUpIHsgcmV0dXJuIHRoaXMubW92ZSgxLCBlbnRlcik7IH1cbiAgICAvKipcbiAgICBNb3ZlIHRvIHRoZSBuZXh0IG5vZGUgaW4gYSBsYXN0LXRvLWZpcnN0IHByZS1vcmRlciB0cmF2ZXJhbC4gQVxuICAgIG5vZGUgaXMgZm9sbG93ZWQgYnkgaXRzIGxhc3QgY2hpbGQgb3IsIGlmIGl0IGhhcyBub25lLCBpdHNcbiAgICBwcmV2aW91cyBzaWJsaW5nIG9yIHRoZSBwcmV2aW91cyBzaWJsaW5nIG9mIHRoZSBmaXJzdCBwYXJlbnRcbiAgICBub2RlIHRoYXQgaGFzIG9uZS5cbiAgICAqL1xuICAgIHByZXYoZW50ZXIgPSB0cnVlKSB7IHJldHVybiB0aGlzLm1vdmUoLTEsIGVudGVyKTsgfVxuICAgIC8qKlxuICAgIE1vdmUgdGhlIGN1cnNvciB0byB0aGUgaW5uZXJtb3N0IG5vZGUgdGhhdCBjb3ZlcnMgYHBvc2AuIElmXG4gICAgYHNpZGVgIGlzIC0xLCBpdCB3aWxsIGVudGVyIG5vZGVzIHRoYXQgZW5kIGF0IGBwb3NgLiBJZiBpdCBpcyAxLFxuICAgIGl0IHdpbGwgZW50ZXIgbm9kZXMgdGhhdCBzdGFydCBhdCBgcG9zYC5cbiAgICAqL1xuICAgIG1vdmVUbyhwb3MsIHNpZGUgPSAwKSB7XG4gICAgICAgIC8vIE1vdmUgdXAgdG8gYSBub2RlIHRoYXQgYWN0dWFsbHkgaG9sZHMgdGhlIHBvc2l0aW9uLCBpZiBwb3NzaWJsZVxuICAgICAgICB3aGlsZSAodGhpcy5mcm9tID09IHRoaXMudG8gfHxcbiAgICAgICAgICAgIChzaWRlIDwgMSA/IHRoaXMuZnJvbSA+PSBwb3MgOiB0aGlzLmZyb20gPiBwb3MpIHx8XG4gICAgICAgICAgICAoc2lkZSA+IC0xID8gdGhpcy50byA8PSBwb3MgOiB0aGlzLnRvIDwgcG9zKSlcbiAgICAgICAgICAgIGlmICghdGhpcy5wYXJlbnQoKSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gVGhlbiBzY2FuIGRvd24gaW50byBjaGlsZCBub2RlcyBhcyBmYXIgYXMgcG9zc2libGVcbiAgICAgICAgd2hpbGUgKHRoaXMuZW50ZXJDaGlsZCgxLCBwb3MsIHNpZGUpKSB7IH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCBhIFtzeW50YXggbm9kZV0oI2NvbW1vbi5TeW50YXhOb2RlKSBhdCB0aGUgY3Vyc29yJ3MgY3VycmVudFxuICAgIHBvc2l0aW9uLlxuICAgICovXG4gICAgZ2V0IG5vZGUoKSB7XG4gICAgICAgIGlmICghdGhpcy5idWZmZXIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fdHJlZTtcbiAgICAgICAgbGV0IGNhY2hlID0gdGhpcy5idWZmZXJOb2RlLCByZXN1bHQgPSBudWxsLCBkZXB0aCA9IDA7XG4gICAgICAgIGlmIChjYWNoZSAmJiBjYWNoZS5jb250ZXh0ID09IHRoaXMuYnVmZmVyKSB7XG4gICAgICAgICAgICBzY2FuOiBmb3IgKGxldCBpbmRleCA9IHRoaXMuaW5kZXgsIGQgPSB0aGlzLnN0YWNrLmxlbmd0aDsgZCA+PSAwOykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGMgPSBjYWNoZTsgYzsgYyA9IGMuX3BhcmVudClcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMuaW5kZXggPT0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpbmRleCA9PSB0aGlzLmluZGV4KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gYztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlcHRoID0gZCArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhayBzY2FuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW5kZXggPSB0aGlzLnN0YWNrWy0tZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IGRlcHRoOyBpIDwgdGhpcy5zdGFjay5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBCdWZmZXJOb2RlKHRoaXMuYnVmZmVyLCByZXN1bHQsIHRoaXMuc3RhY2tbaV0pO1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXJOb2RlID0gbmV3IEJ1ZmZlck5vZGUodGhpcy5idWZmZXIsIHJlc3VsdCwgdGhpcy5pbmRleCk7XG4gICAgfVxuICAgIC8qKlxuICAgIEdldCB0aGUgW3RyZWVdKCNjb21tb24uVHJlZSkgdGhhdCByZXByZXNlbnRzIHRoZSBjdXJyZW50IG5vZGUsIGlmXG4gICAgYW55LiBXaWxsIHJldHVybiBudWxsIHdoZW4gdGhlIG5vZGUgaXMgaW4gYSBbdHJlZVxuICAgIGJ1ZmZlcl0oI2NvbW1vbi5UcmVlQnVmZmVyKS5cbiAgICAqL1xuICAgIGdldCB0cmVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIgPyBudWxsIDogdGhpcy5fdHJlZS5fdHJlZTtcbiAgICB9XG4gICAgLyoqXG4gICAgSXRlcmF0ZSBvdmVyIHRoZSBjdXJyZW50IG5vZGUgYW5kIGFsbCBpdHMgZGVzY2VuZGFudHMsIGNhbGxpbmdcbiAgICBgZW50ZXJgIHdoZW4gZW50ZXJpbmcgYSBub2RlIGFuZCBgbGVhdmVgLCBpZiBnaXZlbiwgd2hlbiBsZWF2aW5nXG4gICAgb25lLiBXaGVuIGBlbnRlcmAgcmV0dXJucyBgZmFsc2VgLCBhbnkgY2hpbGRyZW4gb2YgdGhhdCBub2RlIGFyZVxuICAgIHNraXBwZWQsIGFuZCBgbGVhdmVgIGlzbid0IGNhbGxlZCBmb3IgaXQuXG4gICAgKi9cbiAgICBpdGVyYXRlKGVudGVyLCBsZWF2ZSkge1xuICAgICAgICBmb3IgKGxldCBkZXB0aCA9IDA7Oykge1xuICAgICAgICAgICAgbGV0IG11c3RMZWF2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKHRoaXMudHlwZS5pc0Fub255bW91cyB8fCBlbnRlcih0aGlzKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5maXJzdENoaWxkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVwdGgrKztcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghdGhpcy50eXBlLmlzQW5vbnltb3VzKVxuICAgICAgICAgICAgICAgICAgICBtdXN0TGVhdmUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgICAgIGlmIChtdXN0TGVhdmUgJiYgbGVhdmUpXG4gICAgICAgICAgICAgICAgICAgIGxlYXZlKHRoaXMpO1xuICAgICAgICAgICAgICAgIG11c3RMZWF2ZSA9IHRoaXMudHlwZS5pc0Fub255bW91cztcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5uZXh0U2libGluZygpKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAoIWRlcHRoKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnQoKTtcbiAgICAgICAgICAgICAgICBkZXB0aC0tO1xuICAgICAgICAgICAgICAgIG11c3RMZWF2ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgVGVzdCB3aGV0aGVyIHRoZSBjdXJyZW50IG5vZGUgbWF0Y2hlcyBhIGdpdmVuIGNvbnRleHTigJRhIHNlcXVlbmNlXG4gICAgb2YgZGlyZWN0IHBhcmVudCBub2RlIG5hbWVzLiBFbXB0eSBzdHJpbmdzIGluIHRoZSBjb250ZXh0IGFycmF5XG4gICAgYXJlIHRyZWF0ZWQgYXMgd2lsZGNhcmRzLlxuICAgICovXG4gICAgbWF0Y2hDb250ZXh0KGNvbnRleHQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJ1ZmZlcilcbiAgICAgICAgICAgIHJldHVybiBtYXRjaE5vZGVDb250ZXh0KHRoaXMubm9kZSwgY29udGV4dCk7XG4gICAgICAgIGxldCB7IGJ1ZmZlciB9ID0gdGhpcy5idWZmZXIsIHsgdHlwZXMgfSA9IGJ1ZmZlci5zZXQ7XG4gICAgICAgIGZvciAobGV0IGkgPSBjb250ZXh0Lmxlbmd0aCAtIDEsIGQgPSB0aGlzLnN0YWNrLmxlbmd0aCAtIDE7IGkgPj0gMDsgZC0tKSB7XG4gICAgICAgICAgICBpZiAoZCA8IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoTm9kZUNvbnRleHQodGhpcy5ub2RlLCBjb250ZXh0LCBpKTtcbiAgICAgICAgICAgIGxldCB0eXBlID0gdHlwZXNbYnVmZmVyLmJ1ZmZlclt0aGlzLnN0YWNrW2RdXV07XG4gICAgICAgICAgICBpZiAoIXR5cGUuaXNBbm9ueW1vdXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29udGV4dFtpXSAmJiBjb250ZXh0W2ldICE9IHR5cGUubmFtZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5mdW5jdGlvbiBoYXNDaGlsZCh0cmVlKSB7XG4gICAgcmV0dXJuIHRyZWUuY2hpbGRyZW4uc29tZShjaCA9PiBjaCBpbnN0YW5jZW9mIFRyZWVCdWZmZXIgfHwgIWNoLnR5cGUuaXNBbm9ueW1vdXMgfHwgaGFzQ2hpbGQoY2gpKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkVHJlZShkYXRhKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCB7IGJ1ZmZlciwgbm9kZVNldCwgbWF4QnVmZmVyTGVuZ3RoID0gRGVmYXVsdEJ1ZmZlckxlbmd0aCwgcmV1c2VkID0gW10sIG1pblJlcGVhdFR5cGUgPSBub2RlU2V0LnR5cGVzLmxlbmd0aCB9ID0gZGF0YTtcbiAgICBsZXQgY3Vyc29yID0gQXJyYXkuaXNBcnJheShidWZmZXIpID8gbmV3IEZsYXRCdWZmZXJDdXJzb3IoYnVmZmVyLCBidWZmZXIubGVuZ3RoKSA6IGJ1ZmZlcjtcbiAgICBsZXQgdHlwZXMgPSBub2RlU2V0LnR5cGVzO1xuICAgIGxldCBjb250ZXh0SGFzaCA9IDAsIGxvb2tBaGVhZCA9IDA7XG4gICAgZnVuY3Rpb24gdGFrZU5vZGUocGFyZW50U3RhcnQsIG1pblBvcywgY2hpbGRyZW4sIHBvc2l0aW9ucywgaW5SZXBlYXQsIGRlcHRoKSB7XG4gICAgICAgIGxldCB7IGlkLCBzdGFydCwgZW5kLCBzaXplIH0gPSBjdXJzb3I7XG4gICAgICAgIGxldCBsb29rQWhlYWRBdFN0YXJ0ID0gbG9va0FoZWFkO1xuICAgICAgICB3aGlsZSAoc2l6ZSA8IDApIHtcbiAgICAgICAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgICAgICAgICBpZiAoc2l6ZSA9PSAtMSAvKiBTcGVjaWFsUmVjb3JkLlJldXNlICovKSB7XG4gICAgICAgICAgICAgICAgbGV0IG5vZGUgPSByZXVzZWRbaWRdO1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgcG9zaXRpb25zLnB1c2goc3RhcnQgLSBwYXJlbnRTdGFydCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc2l6ZSA9PSAtMyAvKiBTcGVjaWFsUmVjb3JkLkNvbnRleHRDaGFuZ2UgKi8pIHsgLy8gQ29udGV4dCBjaGFuZ2VcbiAgICAgICAgICAgICAgICBjb250ZXh0SGFzaCA9IGlkO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHNpemUgPT0gLTQgLyogU3BlY2lhbFJlY29yZC5Mb29rQWhlYWQgKi8pIHtcbiAgICAgICAgICAgICAgICBsb29rQWhlYWQgPSBpZDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihgVW5yZWNvZ25pemVkIHJlY29yZCBzaXplOiAke3NpemV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHR5cGUgPSB0eXBlc1tpZF0sIG5vZGUsIGJ1ZmZlcjtcbiAgICAgICAgbGV0IHN0YXJ0UG9zID0gc3RhcnQgLSBwYXJlbnRTdGFydDtcbiAgICAgICAgaWYgKGVuZCAtIHN0YXJ0IDw9IG1heEJ1ZmZlckxlbmd0aCAmJiAoYnVmZmVyID0gZmluZEJ1ZmZlclNpemUoY3Vyc29yLnBvcyAtIG1pblBvcywgaW5SZXBlYXQpKSkge1xuICAgICAgICAgICAgLy8gU21hbGwgZW5vdWdoIGZvciBhIGJ1ZmZlciwgYW5kIG5vIHJldXNlZCBub2RlcyBpbnNpZGVcbiAgICAgICAgICAgIGxldCBkYXRhID0gbmV3IFVpbnQxNkFycmF5KGJ1ZmZlci5zaXplIC0gYnVmZmVyLnNraXApO1xuICAgICAgICAgICAgbGV0IGVuZFBvcyA9IGN1cnNvci5wb3MgLSBidWZmZXIuc2l6ZSwgaW5kZXggPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgICAgIHdoaWxlIChjdXJzb3IucG9zID4gZW5kUG9zKVxuICAgICAgICAgICAgICAgIGluZGV4ID0gY29weVRvQnVmZmVyKGJ1ZmZlci5zdGFydCwgZGF0YSwgaW5kZXgpO1xuICAgICAgICAgICAgbm9kZSA9IG5ldyBUcmVlQnVmZmVyKGRhdGEsIGVuZCAtIGJ1ZmZlci5zdGFydCwgbm9kZVNldCk7XG4gICAgICAgICAgICBzdGFydFBvcyA9IGJ1ZmZlci5zdGFydCAtIHBhcmVudFN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBNYWtlIGl0IGEgbm9kZVxuICAgICAgICAgICAgbGV0IGVuZFBvcyA9IGN1cnNvci5wb3MgLSBzaXplO1xuICAgICAgICAgICAgY3Vyc29yLm5leHQoKTtcbiAgICAgICAgICAgIGxldCBsb2NhbENoaWxkcmVuID0gW10sIGxvY2FsUG9zaXRpb25zID0gW107XG4gICAgICAgICAgICBsZXQgbG9jYWxJblJlcGVhdCA9IGlkID49IG1pblJlcGVhdFR5cGUgPyBpZCA6IC0xO1xuICAgICAgICAgICAgbGV0IGxhc3RHcm91cCA9IDAsIGxhc3RFbmQgPSBlbmQ7XG4gICAgICAgICAgICB3aGlsZSAoY3Vyc29yLnBvcyA+IGVuZFBvcykge1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbEluUmVwZWF0ID49IDAgJiYgY3Vyc29yLmlkID09IGxvY2FsSW5SZXBlYXQgJiYgY3Vyc29yLnNpemUgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3Vyc29yLmVuZCA8PSBsYXN0RW5kIC0gbWF4QnVmZmVyTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYWtlUmVwZWF0TGVhZihsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgc3RhcnQsIGxhc3RHcm91cCwgY3Vyc29yLmVuZCwgbGFzdEVuZCwgbG9jYWxJblJlcGVhdCwgbG9va0FoZWFkQXRTdGFydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0R3JvdXAgPSBsb2NhbENoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RFbmQgPSBjdXJzb3IuZW5kO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRlcHRoID4gMjUwMCAvKiBDdXRPZmYuRGVwdGggKi8pIHtcbiAgICAgICAgICAgICAgICAgICAgdGFrZUZsYXROb2RlKHN0YXJ0LCBlbmRQb3MsIGxvY2FsQ2hpbGRyZW4sIGxvY2FsUG9zaXRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRha2VOb2RlKHN0YXJ0LCBlbmRQb3MsIGxvY2FsQ2hpbGRyZW4sIGxvY2FsUG9zaXRpb25zLCBsb2NhbEluUmVwZWF0LCBkZXB0aCArIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsb2NhbEluUmVwZWF0ID49IDAgJiYgbGFzdEdyb3VwID4gMCAmJiBsYXN0R3JvdXAgPCBsb2NhbENoaWxkcmVuLmxlbmd0aClcbiAgICAgICAgICAgICAgICBtYWtlUmVwZWF0TGVhZihsb2NhbENoaWxkcmVuLCBsb2NhbFBvc2l0aW9ucywgc3RhcnQsIGxhc3RHcm91cCwgc3RhcnQsIGxhc3RFbmQsIGxvY2FsSW5SZXBlYXQsIGxvb2tBaGVhZEF0U3RhcnQpO1xuICAgICAgICAgICAgbG9jYWxDaGlsZHJlbi5yZXZlcnNlKCk7XG4gICAgICAgICAgICBsb2NhbFBvc2l0aW9ucy5yZXZlcnNlKCk7XG4gICAgICAgICAgICBpZiAobG9jYWxJblJlcGVhdCA+IC0xICYmIGxhc3RHcm91cCA+IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgbWFrZSA9IG1ha2VCYWxhbmNlZCh0eXBlKTtcbiAgICAgICAgICAgICAgICBub2RlID0gYmFsYW5jZVJhbmdlKHR5cGUsIGxvY2FsQ2hpbGRyZW4sIGxvY2FsUG9zaXRpb25zLCAwLCBsb2NhbENoaWxkcmVuLmxlbmd0aCwgMCwgZW5kIC0gc3RhcnQsIG1ha2UsIG1ha2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG1ha2VUcmVlKHR5cGUsIGxvY2FsQ2hpbGRyZW4sIGxvY2FsUG9zaXRpb25zLCBlbmQgLSBzdGFydCwgbG9va0FoZWFkQXRTdGFydCAtIGVuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRyZW4ucHVzaChub2RlKTtcbiAgICAgICAgcG9zaXRpb25zLnB1c2goc3RhcnRQb3MpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0YWtlRmxhdE5vZGUocGFyZW50U3RhcnQsIG1pblBvcywgY2hpbGRyZW4sIHBvc2l0aW9ucykge1xuICAgICAgICBsZXQgbm9kZXMgPSBbXTsgLy8gVGVtcG9yYXJ5LCBpbnZlcnRlZCBhcnJheSBvZiBsZWFmIG5vZGVzIGZvdW5kLCB3aXRoIGFic29sdXRlIHBvc2l0aW9uc1xuICAgICAgICBsZXQgbm9kZUNvdW50ID0gMCwgc3RvcEF0ID0gLTE7XG4gICAgICAgIHdoaWxlIChjdXJzb3IucG9zID4gbWluUG9zKSB7XG4gICAgICAgICAgICBsZXQgeyBpZCwgc3RhcnQsIGVuZCwgc2l6ZSB9ID0gY3Vyc29yO1xuICAgICAgICAgICAgaWYgKHNpemUgPiA0KSB7IC8vIE5vdCBhIGxlYWZcbiAgICAgICAgICAgICAgICBjdXJzb3IubmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3RvcEF0ID4gLTEgJiYgc3RhcnQgPCBzdG9wQXQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChzdG9wQXQgPCAwKVxuICAgICAgICAgICAgICAgICAgICBzdG9wQXQgPSBlbmQgLSBtYXhCdWZmZXJMZW5ndGg7XG4gICAgICAgICAgICAgICAgbm9kZXMucHVzaChpZCwgc3RhcnQsIGVuZCk7XG4gICAgICAgICAgICAgICAgbm9kZUNvdW50Kys7XG4gICAgICAgICAgICAgICAgY3Vyc29yLm5leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZUNvdW50KSB7XG4gICAgICAgICAgICBsZXQgYnVmZmVyID0gbmV3IFVpbnQxNkFycmF5KG5vZGVDb3VudCAqIDQpO1xuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gbm9kZXNbbm9kZXMubGVuZ3RoIC0gMl07XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gbm9kZXMubGVuZ3RoIC0gMywgaiA9IDA7IGkgPj0gMDsgaSAtPSAzKSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyW2orK10gPSBub2Rlc1tpXTtcbiAgICAgICAgICAgICAgICBidWZmZXJbaisrXSA9IG5vZGVzW2kgKyAxXSAtIHN0YXJ0O1xuICAgICAgICAgICAgICAgIGJ1ZmZlcltqKytdID0gbm9kZXNbaSArIDJdIC0gc3RhcnQ7XG4gICAgICAgICAgICAgICAgYnVmZmVyW2orK10gPSBqO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChuZXcgVHJlZUJ1ZmZlcihidWZmZXIsIG5vZGVzWzJdIC0gc3RhcnQsIG5vZGVTZXQpKTtcbiAgICAgICAgICAgIHBvc2l0aW9ucy5wdXNoKHN0YXJ0IC0gcGFyZW50U3RhcnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1ha2VCYWxhbmNlZCh0eXBlKSB7XG4gICAgICAgIHJldHVybiAoY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoKSA9PiB7XG4gICAgICAgICAgICBsZXQgbG9va0FoZWFkID0gMCwgbGFzdEkgPSBjaGlsZHJlbi5sZW5ndGggLSAxLCBsYXN0LCBsb29rQWhlYWRQcm9wO1xuICAgICAgICAgICAgaWYgKGxhc3RJID49IDAgJiYgKGxhc3QgPSBjaGlsZHJlbltsYXN0SV0pIGluc3RhbmNlb2YgVHJlZSkge1xuICAgICAgICAgICAgICAgIGlmICghbGFzdEkgJiYgbGFzdC50eXBlID09IHR5cGUgJiYgbGFzdC5sZW5ndGggPT0gbGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGFzdDtcbiAgICAgICAgICAgICAgICBpZiAobG9va0FoZWFkUHJvcCA9IGxhc3QucHJvcChOb2RlUHJvcC5sb29rQWhlYWQpKVxuICAgICAgICAgICAgICAgICAgICBsb29rQWhlYWQgPSBwb3NpdGlvbnNbbGFzdEldICsgbGFzdC5sZW5ndGggKyBsb29rQWhlYWRQcm9wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1ha2VUcmVlKHR5cGUsIGNoaWxkcmVuLCBwb3NpdGlvbnMsIGxlbmd0aCwgbG9va0FoZWFkKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWFrZVJlcGVhdExlYWYoY2hpbGRyZW4sIHBvc2l0aW9ucywgYmFzZSwgaSwgZnJvbSwgdG8sIHR5cGUsIGxvb2tBaGVhZCkge1xuICAgICAgICBsZXQgbG9jYWxDaGlsZHJlbiA9IFtdLCBsb2NhbFBvc2l0aW9ucyA9IFtdO1xuICAgICAgICB3aGlsZSAoY2hpbGRyZW4ubGVuZ3RoID4gaSkge1xuICAgICAgICAgICAgbG9jYWxDaGlsZHJlbi5wdXNoKGNoaWxkcmVuLnBvcCgpKTtcbiAgICAgICAgICAgIGxvY2FsUG9zaXRpb25zLnB1c2gocG9zaXRpb25zLnBvcCgpICsgYmFzZSAtIGZyb20pO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkcmVuLnB1c2gobWFrZVRyZWUobm9kZVNldC50eXBlc1t0eXBlXSwgbG9jYWxDaGlsZHJlbiwgbG9jYWxQb3NpdGlvbnMsIHRvIC0gZnJvbSwgbG9va0FoZWFkIC0gdG8pKTtcbiAgICAgICAgcG9zaXRpb25zLnB1c2goZnJvbSAtIGJhc2UpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBtYWtlVHJlZSh0eXBlLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgsIGxvb2tBaGVhZCA9IDAsIHByb3BzKSB7XG4gICAgICAgIGlmIChjb250ZXh0SGFzaCkge1xuICAgICAgICAgICAgbGV0IHBhaXIgPSBbTm9kZVByb3AuY29udGV4dEhhc2gsIGNvbnRleHRIYXNoXTtcbiAgICAgICAgICAgIHByb3BzID0gcHJvcHMgPyBbcGFpcl0uY29uY2F0KHByb3BzKSA6IFtwYWlyXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG9va0FoZWFkID4gMjUpIHtcbiAgICAgICAgICAgIGxldCBwYWlyID0gW05vZGVQcm9wLmxvb2tBaGVhZCwgbG9va0FoZWFkXTtcbiAgICAgICAgICAgIHByb3BzID0gcHJvcHMgPyBbcGFpcl0uY29uY2F0KHByb3BzKSA6IFtwYWlyXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFRyZWUodHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgbGVuZ3RoLCBwcm9wcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbmRCdWZmZXJTaXplKG1heFNpemUsIGluUmVwZWF0KSB7XG4gICAgICAgIC8vIFNjYW4gdGhyb3VnaCB0aGUgYnVmZmVyIHRvIGZpbmQgcHJldmlvdXMgc2libGluZ3MgdGhhdCBmaXRcbiAgICAgICAgLy8gdG9nZXRoZXIgaW4gYSBUcmVlQnVmZmVyLCBhbmQgZG9uJ3QgY29udGFpbiBhbnkgcmV1c2VkIG5vZGVzXG4gICAgICAgIC8vICh3aGljaCBjYW4ndCBiZSBzdG9yZWQgaW4gYSBidWZmZXIpLlxuICAgICAgICAvLyBJZiBgaW5SZXBlYXRgIGlzID4gLTEsIGlnbm9yZSBub2RlIGJvdW5kYXJpZXMgb2YgdGhhdCB0eXBlIGZvclxuICAgICAgICAvLyBuZXN0aW5nLCBidXQgbWFrZSBzdXJlIHRoZSBlbmQgZmFsbHMgZWl0aGVyIGF0IHRoZSBzdGFydFxuICAgICAgICAvLyAoYG1heFNpemVgKSBvciBiZWZvcmUgc3VjaCBhIG5vZGUuXG4gICAgICAgIGxldCBmb3JrID0gY3Vyc29yLmZvcmsoKTtcbiAgICAgICAgbGV0IHNpemUgPSAwLCBzdGFydCA9IDAsIHNraXAgPSAwLCBtaW5TdGFydCA9IGZvcmsuZW5kIC0gbWF4QnVmZmVyTGVuZ3RoO1xuICAgICAgICBsZXQgcmVzdWx0ID0geyBzaXplOiAwLCBzdGFydDogMCwgc2tpcDogMCB9O1xuICAgICAgICBzY2FuOiBmb3IgKGxldCBtaW5Qb3MgPSBmb3JrLnBvcyAtIG1heFNpemU7IGZvcmsucG9zID4gbWluUG9zOykge1xuICAgICAgICAgICAgbGV0IG5vZGVTaXplID0gZm9yay5zaXplO1xuICAgICAgICAgICAgLy8gUHJldGVuZCBuZXN0ZWQgcmVwZWF0IG5vZGVzIG9mIHRoZSBzYW1lIHR5cGUgZG9uJ3QgZXhpc3RcbiAgICAgICAgICAgIGlmIChmb3JrLmlkID09IGluUmVwZWF0ICYmIG5vZGVTaXplID49IDApIHtcbiAgICAgICAgICAgICAgICAvLyBFeGNlcHQgdGhhdCB3ZSBzdG9yZSB0aGUgY3VycmVudCBzdGF0ZSBhcyBhIHZhbGlkIHJldHVyblxuICAgICAgICAgICAgICAgIC8vIHZhbHVlLlxuICAgICAgICAgICAgICAgIHJlc3VsdC5zaXplID0gc2l6ZTtcbiAgICAgICAgICAgICAgICByZXN1bHQuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgICAgICByZXN1bHQuc2tpcCA9IHNraXA7XG4gICAgICAgICAgICAgICAgc2tpcCArPSA0O1xuICAgICAgICAgICAgICAgIHNpemUgKz0gNDtcbiAgICAgICAgICAgICAgICBmb3JrLm5leHQoKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzdGFydFBvcyA9IGZvcmsucG9zIC0gbm9kZVNpemU7XG4gICAgICAgICAgICBpZiAobm9kZVNpemUgPCAwIHx8IHN0YXJ0UG9zIDwgbWluUG9zIHx8IGZvcmsuc3RhcnQgPCBtaW5TdGFydClcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGxldCBsb2NhbFNraXBwZWQgPSBmb3JrLmlkID49IG1pblJlcGVhdFR5cGUgPyA0IDogMDtcbiAgICAgICAgICAgIGxldCBub2RlU3RhcnQgPSBmb3JrLnN0YXJ0O1xuICAgICAgICAgICAgZm9yay5uZXh0KCk7XG4gICAgICAgICAgICB3aGlsZSAoZm9yay5wb3MgPiBzdGFydFBvcykge1xuICAgICAgICAgICAgICAgIGlmIChmb3JrLnNpemUgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb3JrLnNpemUgPT0gLTMgLyogU3BlY2lhbFJlY29yZC5Db250ZXh0Q2hhbmdlICovKVxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxTa2lwcGVkICs9IDQ7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrIHNjYW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZvcmsuaWQgPj0gbWluUmVwZWF0VHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbFNraXBwZWQgKz0gNDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yay5uZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGFydCA9IG5vZGVTdGFydDtcbiAgICAgICAgICAgIHNpemUgKz0gbm9kZVNpemU7XG4gICAgICAgICAgICBza2lwICs9IGxvY2FsU2tpcHBlZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5SZXBlYXQgPCAwIHx8IHNpemUgPT0gbWF4U2l6ZSkge1xuICAgICAgICAgICAgcmVzdWx0LnNpemUgPSBzaXplO1xuICAgICAgICAgICAgcmVzdWx0LnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgICAgICByZXN1bHQuc2tpcCA9IHNraXA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC5zaXplID4gNCA/IHJlc3VsdCA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29weVRvQnVmZmVyKGJ1ZmZlclN0YXJ0LCBidWZmZXIsIGluZGV4KSB7XG4gICAgICAgIGxldCB7IGlkLCBzdGFydCwgZW5kLCBzaXplIH0gPSBjdXJzb3I7XG4gICAgICAgIGN1cnNvci5uZXh0KCk7XG4gICAgICAgIGlmIChzaXplID49IDAgJiYgaWQgPCBtaW5SZXBlYXRUeXBlKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnRJbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgaWYgKHNpemUgPiA0KSB7XG4gICAgICAgICAgICAgICAgbGV0IGVuZFBvcyA9IGN1cnNvci5wb3MgLSAoc2l6ZSAtIDQpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChjdXJzb3IucG9zID4gZW5kUG9zKVxuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGNvcHlUb0J1ZmZlcihidWZmZXJTdGFydCwgYnVmZmVyLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBidWZmZXJbLS1pbmRleF0gPSBzdGFydEluZGV4O1xuICAgICAgICAgICAgYnVmZmVyWy0taW5kZXhdID0gZW5kIC0gYnVmZmVyU3RhcnQ7XG4gICAgICAgICAgICBidWZmZXJbLS1pbmRleF0gPSBzdGFydCAtIGJ1ZmZlclN0YXJ0O1xuICAgICAgICAgICAgYnVmZmVyWy0taW5kZXhdID0gaWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2l6ZSA9PSAtMyAvKiBTcGVjaWFsUmVjb3JkLkNvbnRleHRDaGFuZ2UgKi8pIHtcbiAgICAgICAgICAgIGNvbnRleHRIYXNoID0gaWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2l6ZSA9PSAtNCAvKiBTcGVjaWFsUmVjb3JkLkxvb2tBaGVhZCAqLykge1xuICAgICAgICAgICAgbG9va0FoZWFkID0gaWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgICBsZXQgY2hpbGRyZW4gPSBbXSwgcG9zaXRpb25zID0gW107XG4gICAgd2hpbGUgKGN1cnNvci5wb3MgPiAwKVxuICAgICAgICB0YWtlTm9kZShkYXRhLnN0YXJ0IHx8IDAsIGRhdGEuYnVmZmVyU3RhcnQgfHwgMCwgY2hpbGRyZW4sIHBvc2l0aW9ucywgLTEsIDApO1xuICAgIGxldCBsZW5ndGggPSAoX2EgPSBkYXRhLmxlbmd0aCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKGNoaWxkcmVuLmxlbmd0aCA/IHBvc2l0aW9uc1swXSArIGNoaWxkcmVuWzBdLmxlbmd0aCA6IDApO1xuICAgIHJldHVybiBuZXcgVHJlZSh0eXBlc1tkYXRhLnRvcElEXSwgY2hpbGRyZW4ucmV2ZXJzZSgpLCBwb3NpdGlvbnMucmV2ZXJzZSgpLCBsZW5ndGgpO1xufVxuY29uc3Qgbm9kZVNpemVDYWNoZSA9IG5ldyBXZWFrTWFwO1xuZnVuY3Rpb24gbm9kZVNpemUoYmFsYW5jZVR5cGUsIG5vZGUpIHtcbiAgICBpZiAoIWJhbGFuY2VUeXBlLmlzQW5vbnltb3VzIHx8IG5vZGUgaW5zdGFuY2VvZiBUcmVlQnVmZmVyIHx8IG5vZGUudHlwZSAhPSBiYWxhbmNlVHlwZSlcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgbGV0IHNpemUgPSBub2RlU2l6ZUNhY2hlLmdldChub2RlKTtcbiAgICBpZiAoc2l6ZSA9PSBudWxsKSB7XG4gICAgICAgIHNpemUgPSAxO1xuICAgICAgICBmb3IgKGxldCBjaGlsZCBvZiBub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBpZiAoY2hpbGQudHlwZSAhPSBiYWxhbmNlVHlwZSB8fCAhKGNoaWxkIGluc3RhbmNlb2YgVHJlZSkpIHtcbiAgICAgICAgICAgICAgICBzaXplID0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNpemUgKz0gbm9kZVNpemUoYmFsYW5jZVR5cGUsIGNoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICBub2RlU2l6ZUNhY2hlLnNldChub2RlLCBzaXplKTtcbiAgICB9XG4gICAgcmV0dXJuIHNpemU7XG59XG5mdW5jdGlvbiBiYWxhbmNlUmFuZ2UoXG4vLyBUaGUgdHlwZSB0aGUgYmFsYW5jZWQgdHJlZSdzIGlubmVyIG5vZGVzLlxuYmFsYW5jZVR5cGUsIFxuLy8gVGhlIGRpcmVjdCBjaGlsZHJlbiBhbmQgdGhlaXIgcG9zaXRpb25zXG5jaGlsZHJlbiwgcG9zaXRpb25zLCBcbi8vIFRoZSBpbmRleCByYW5nZSBpbiBjaGlsZHJlbi9wb3NpdGlvbnMgdG8gdXNlXG5mcm9tLCB0bywgXG4vLyBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIG5vZGVzLCByZWxhdGl2ZSB0byB0aGVpciBwYXJlbnQuXG5zdGFydCwgXG4vLyBMZW5ndGggb2YgdGhlIG91dGVyIG5vZGVcbmxlbmd0aCwgXG4vLyBGdW5jdGlvbiB0byBidWlsZCB0aGUgdG9wIG5vZGUgb2YgdGhlIGJhbGFuY2VkIHRyZWVcbm1rVG9wLCBcbi8vIEZ1bmN0aW9uIHRvIGJ1aWxkIGludGVybmFsIG5vZGVzIGZvciB0aGUgYmFsYW5jZWQgdHJlZVxubWtUcmVlKSB7XG4gICAgbGV0IHRvdGFsID0gMDtcbiAgICBmb3IgKGxldCBpID0gZnJvbTsgaSA8IHRvOyBpKyspXG4gICAgICAgIHRvdGFsICs9IG5vZGVTaXplKGJhbGFuY2VUeXBlLCBjaGlsZHJlbltpXSk7XG4gICAgbGV0IG1heENoaWxkID0gTWF0aC5jZWlsKCh0b3RhbCAqIDEuNSkgLyA4IC8qIEJhbGFuY2UuQnJhbmNoRmFjdG9yICovKTtcbiAgICBsZXQgbG9jYWxDaGlsZHJlbiA9IFtdLCBsb2NhbFBvc2l0aW9ucyA9IFtdO1xuICAgIGZ1bmN0aW9uIGRpdmlkZShjaGlsZHJlbiwgcG9zaXRpb25zLCBmcm9tLCB0bywgb2Zmc2V0KSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBmcm9tOyBpIDwgdG87KSB7XG4gICAgICAgICAgICBsZXQgZ3JvdXBGcm9tID0gaSwgZ3JvdXBTdGFydCA9IHBvc2l0aW9uc1tpXSwgZ3JvdXBTaXplID0gbm9kZVNpemUoYmFsYW5jZVR5cGUsIGNoaWxkcmVuW2ldKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGZvciAoOyBpIDwgdG87IGkrKykge1xuICAgICAgICAgICAgICAgIGxldCBuZXh0U2l6ZSA9IG5vZGVTaXplKGJhbGFuY2VUeXBlLCBjaGlsZHJlbltpXSk7XG4gICAgICAgICAgICAgICAgaWYgKGdyb3VwU2l6ZSArIG5leHRTaXplID49IG1heENoaWxkKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBncm91cFNpemUgKz0gbmV4dFNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA9PSBncm91cEZyb20gKyAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGdyb3VwU2l6ZSA+IG1heENoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBvbmx5ID0gY2hpbGRyZW5bZ3JvdXBGcm9tXTsgLy8gT25seSB0cmVlcyBjYW4gaGF2ZSBhIHNpemUgPiAxXG4gICAgICAgICAgICAgICAgICAgIGRpdmlkZShvbmx5LmNoaWxkcmVuLCBvbmx5LnBvc2l0aW9ucywgMCwgb25seS5jaGlsZHJlbi5sZW5ndGgsIHBvc2l0aW9uc1tncm91cEZyb21dICsgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxvY2FsQ2hpbGRyZW4ucHVzaChjaGlsZHJlbltncm91cEZyb21dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBsZW5ndGggPSBwb3NpdGlvbnNbaSAtIDFdICsgY2hpbGRyZW5baSAtIDFdLmxlbmd0aCAtIGdyb3VwU3RhcnQ7XG4gICAgICAgICAgICAgICAgbG9jYWxDaGlsZHJlbi5wdXNoKGJhbGFuY2VSYW5nZShiYWxhbmNlVHlwZSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgZ3JvdXBGcm9tLCBpLCBncm91cFN0YXJ0LCBsZW5ndGgsIG51bGwsIG1rVHJlZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9jYWxQb3NpdGlvbnMucHVzaChncm91cFN0YXJ0ICsgb2Zmc2V0IC0gc3RhcnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRpdmlkZShjaGlsZHJlbiwgcG9zaXRpb25zLCBmcm9tLCB0bywgMCk7XG4gICAgcmV0dXJuIChta1RvcCB8fCBta1RyZWUpKGxvY2FsQ2hpbGRyZW4sIGxvY2FsUG9zaXRpb25zLCBsZW5ndGgpO1xufVxuLyoqXG5Qcm92aWRlcyBhIHdheSB0byBhc3NvY2lhdGUgdmFsdWVzIHdpdGggcGllY2VzIG9mIHRyZWVzLiBBcyBsb25nXG5hcyB0aGF0IHBhcnQgb2YgdGhlIHRyZWUgaXMgcmV1c2VkLCB0aGUgYXNzb2NpYXRlZCB2YWx1ZXMgY2FuIGJlXG5yZXRyaWV2ZWQgZnJvbSBhbiB1cGRhdGVkIHRyZWUuXG4qL1xuY2xhc3MgTm9kZVdlYWtNYXAge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLm1hcCA9IG5ldyBXZWFrTWFwKCk7XG4gICAgfVxuICAgIHNldEJ1ZmZlcihidWZmZXIsIGluZGV4LCB2YWx1ZSkge1xuICAgICAgICBsZXQgaW5uZXIgPSB0aGlzLm1hcC5nZXQoYnVmZmVyKTtcbiAgICAgICAgaWYgKCFpbm5lcilcbiAgICAgICAgICAgIHRoaXMubWFwLnNldChidWZmZXIsIGlubmVyID0gbmV3IE1hcCk7XG4gICAgICAgIGlubmVyLnNldChpbmRleCwgdmFsdWUpO1xuICAgIH1cbiAgICBnZXRCdWZmZXIoYnVmZmVyLCBpbmRleCkge1xuICAgICAgICBsZXQgaW5uZXIgPSB0aGlzLm1hcC5nZXQoYnVmZmVyKTtcbiAgICAgICAgcmV0dXJuIGlubmVyICYmIGlubmVyLmdldChpbmRleCk7XG4gICAgfVxuICAgIC8qKlxuICAgIFNldCB0aGUgdmFsdWUgZm9yIHRoaXMgc3ludGF4IG5vZGUuXG4gICAgKi9cbiAgICBzZXQobm9kZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBCdWZmZXJOb2RlKVxuICAgICAgICAgICAgdGhpcy5zZXRCdWZmZXIobm9kZS5jb250ZXh0LmJ1ZmZlciwgbm9kZS5pbmRleCwgdmFsdWUpO1xuICAgICAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgVHJlZU5vZGUpXG4gICAgICAgICAgICB0aGlzLm1hcC5zZXQobm9kZS50cmVlLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHJpZXZlIHZhbHVlIGZvciB0aGlzIHN5bnRheCBub2RlLCBpZiBpdCBleGlzdHMgaW4gdGhlIG1hcC5cbiAgICAqL1xuICAgIGdldChub2RlKSB7XG4gICAgICAgIHJldHVybiBub2RlIGluc3RhbmNlb2YgQnVmZmVyTm9kZSA/IHRoaXMuZ2V0QnVmZmVyKG5vZGUuY29udGV4dC5idWZmZXIsIG5vZGUuaW5kZXgpXG4gICAgICAgICAgICA6IG5vZGUgaW5zdGFuY2VvZiBUcmVlTm9kZSA/IHRoaXMubWFwLmdldChub2RlLnRyZWUpIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICBTZXQgdGhlIHZhbHVlIGZvciB0aGUgbm9kZSB0aGF0IGEgY3Vyc29yIGN1cnJlbnRseSBwb2ludHMgdG8uXG4gICAgKi9cbiAgICBjdXJzb3JTZXQoY3Vyc29yLCB2YWx1ZSkge1xuICAgICAgICBpZiAoY3Vyc29yLmJ1ZmZlcilcbiAgICAgICAgICAgIHRoaXMuc2V0QnVmZmVyKGN1cnNvci5idWZmZXIuYnVmZmVyLCBjdXJzb3IuaW5kZXgsIHZhbHVlKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5tYXAuc2V0KGN1cnNvci50cmVlLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJldHJpZXZlIHRoZSB2YWx1ZSBmb3IgdGhlIG5vZGUgdGhhdCBhIGN1cnNvciBjdXJyZW50bHkgcG9pbnRzXG4gICAgdG8uXG4gICAgKi9cbiAgICBjdXJzb3JHZXQoY3Vyc29yKSB7XG4gICAgICAgIHJldHVybiBjdXJzb3IuYnVmZmVyID8gdGhpcy5nZXRCdWZmZXIoY3Vyc29yLmJ1ZmZlci5idWZmZXIsIGN1cnNvci5pbmRleCkgOiB0aGlzLm1hcC5nZXQoY3Vyc29yLnRyZWUpO1xuICAgIH1cbn1cblxuLyoqXG5UcmVlIGZyYWdtZW50cyBhcmUgdXNlZCBkdXJpbmcgW2luY3JlbWVudGFsXG5wYXJzaW5nXSgjY29tbW9uLlBhcnNlci5zdGFydFBhcnNlKSB0byB0cmFjayBwYXJ0cyBvZiBvbGQgdHJlZXNcbnRoYXQgY2FuIGJlIHJldXNlZCBpbiBhIG5ldyBwYXJzZS4gQW4gYXJyYXkgb2YgZnJhZ21lbnRzIGlzIHVzZWRcbnRvIHRyYWNrIHJlZ2lvbnMgb2YgYW4gb2xkIHRyZWUgd2hvc2Ugbm9kZXMgbWlnaHQgYmUgcmV1c2VkIGluIG5ld1xucGFyc2VzLiBVc2UgdGhlIHN0YXRpY1xuW2BhcHBseUNoYW5nZXNgXSgjY29tbW9uLlRyZWVGcmFnbWVudF5hcHBseUNoYW5nZXMpIG1ldGhvZCB0b1xudXBkYXRlIGZyYWdtZW50cyBmb3IgZG9jdW1lbnQgY2hhbmdlcy5cbiovXG5jbGFzcyBUcmVlRnJhZ21lbnQge1xuICAgIC8qKlxuICAgIENvbnN0cnVjdCBhIHRyZWUgZnJhZ21lbnQuIFlvdSdsbCB1c3VhbGx5IHdhbnQgdG8gdXNlXG4gICAgW2BhZGRUcmVlYF0oI2NvbW1vbi5UcmVlRnJhZ21lbnReYWRkVHJlZSkgYW5kXG4gICAgW2BhcHBseUNoYW5nZXNgXSgjY29tbW9uLlRyZWVGcmFnbWVudF5hcHBseUNoYW5nZXMpIGluc3RlYWQgb2ZcbiAgICBjYWxsaW5nIHRoaXMgZGlyZWN0bHkuXG4gICAgKi9cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAvKipcbiAgICBUaGUgc3RhcnQgb2YgdGhlIHVuY2hhbmdlZCByYW5nZSBwb2ludGVkIHRvIGJ5IHRoaXMgZnJhZ21lbnQuXG4gICAgVGhpcyByZWZlcnMgdG8gYW4gb2Zmc2V0IGluIHRoZSBfdXBkYXRlZF8gZG9jdW1lbnQgKGFzIG9wcG9zZWRcbiAgICB0byB0aGUgb3JpZ2luYWwgdHJlZSkuXG4gICAgKi9cbiAgICBmcm9tLCBcbiAgICAvKipcbiAgICBUaGUgZW5kIG9mIHRoZSB1bmNoYW5nZWQgcmFuZ2UuXG4gICAgKi9cbiAgICB0bywgXG4gICAgLyoqXG4gICAgVGhlIHRyZWUgdGhhdCB0aGlzIGZyYWdtZW50IGlzIGJhc2VkIG9uLlxuICAgICovXG4gICAgdHJlZSwgXG4gICAgLyoqXG4gICAgVGhlIG9mZnNldCBiZXR3ZWVuIHRoZSBmcmFnbWVudCdzIHRyZWUgYW5kIHRoZSBkb2N1bWVudCB0aGF0XG4gICAgdGhpcyBmcmFnbWVudCBjYW4gYmUgdXNlZCBhZ2FpbnN0LiBBZGQgdGhpcyB3aGVuIGdvaW5nIGZyb21cbiAgICBkb2N1bWVudCB0byB0cmVlIHBvc2l0aW9ucywgc3VidHJhY3QgaXQgdG8gZ28gZnJvbSB0cmVlIHRvXG4gICAgZG9jdW1lbnQgcG9zaXRpb25zLlxuICAgICovXG4gICAgb2Zmc2V0LCBvcGVuU3RhcnQgPSBmYWxzZSwgb3BlbkVuZCA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgICAgdGhpcy50cmVlID0gdHJlZTtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIHRoaXMub3BlbiA9IChvcGVuU3RhcnQgPyAxIC8qIE9wZW4uU3RhcnQgKi8gOiAwKSB8IChvcGVuRW5kID8gMiAvKiBPcGVuLkVuZCAqLyA6IDApO1xuICAgIH1cbiAgICAvKipcbiAgICBXaGV0aGVyIHRoZSBzdGFydCBvZiB0aGUgZnJhZ21lbnQgcmVwcmVzZW50cyB0aGUgc3RhcnQgb2YgYVxuICAgIHBhcnNlLCBvciB0aGUgZW5kIG9mIGEgY2hhbmdlLiAoSW4gdGhlIHNlY29uZCBjYXNlLCBpdCBtYXkgbm90XG4gICAgYmUgc2FmZSB0byByZXVzZSBzb21lIG5vZGVzIGF0IHRoZSBzdGFydCwgZGVwZW5kaW5nIG9uIHRoZVxuICAgIHBhcnNpbmcgYWxnb3JpdGhtLilcbiAgICAqL1xuICAgIGdldCBvcGVuU3RhcnQoKSB7IHJldHVybiAodGhpcy5vcGVuICYgMSAvKiBPcGVuLlN0YXJ0ICovKSA+IDA7IH1cbiAgICAvKipcbiAgICBXaGV0aGVyIHRoZSBlbmQgb2YgdGhlIGZyYWdtZW50IHJlcHJlc2VudHMgdGhlIGVuZCBvZiBhXG4gICAgZnVsbC1kb2N1bWVudCBwYXJzZSwgb3IgdGhlIHN0YXJ0IG9mIGEgY2hhbmdlLlxuICAgICovXG4gICAgZ2V0IG9wZW5FbmQoKSB7IHJldHVybiAodGhpcy5vcGVuICYgMiAvKiBPcGVuLkVuZCAqLykgPiAwOyB9XG4gICAgLyoqXG4gICAgQ3JlYXRlIGEgc2V0IG9mIGZyYWdtZW50cyBmcm9tIGEgZnJlc2hseSBwYXJzZWQgdHJlZSwgb3IgdXBkYXRlXG4gICAgYW4gZXhpc3Rpbmcgc2V0IG9mIGZyYWdtZW50cyBieSByZXBsYWNpbmcgdGhlIG9uZXMgdGhhdCBvdmVybGFwXG4gICAgd2l0aCBhIHRyZWUgd2l0aCBjb250ZW50IGZyb20gdGhlIG5ldyB0cmVlLiBXaGVuIGBwYXJ0aWFsYCBpc1xuICAgIHRydWUsIHRoZSBwYXJzZSBpcyB0cmVhdGVkIGFzIGluY29tcGxldGUsIGFuZCB0aGUgcmVzdWx0aW5nXG4gICAgZnJhZ21lbnQgaGFzIFtgb3BlbkVuZGBdKCNjb21tb24uVHJlZUZyYWdtZW50Lm9wZW5FbmQpIHNldCB0b1xuICAgIHRydWUuXG4gICAgKi9cbiAgICBzdGF0aWMgYWRkVHJlZSh0cmVlLCBmcmFnbWVudHMgPSBbXSwgcGFydGlhbCA9IGZhbHNlKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBbbmV3IFRyZWVGcmFnbWVudCgwLCB0cmVlLmxlbmd0aCwgdHJlZSwgMCwgZmFsc2UsIHBhcnRpYWwpXTtcbiAgICAgICAgZm9yIChsZXQgZiBvZiBmcmFnbWVudHMpXG4gICAgICAgICAgICBpZiAoZi50byA+IHRyZWUubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGYpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICBBcHBseSBhIHNldCBvZiBlZGl0cyB0byBhbiBhcnJheSBvZiBmcmFnbWVudHMsIHJlbW92aW5nIG9yXG4gICAgc3BsaXR0aW5nIGZyYWdtZW50cyBhcyBuZWNlc3NhcnkgdG8gcmVtb3ZlIGVkaXRlZCByYW5nZXMsIGFuZFxuICAgIGFkanVzdGluZyBvZmZzZXRzIGZvciBmcmFnbWVudHMgdGhhdCBtb3ZlZC5cbiAgICAqL1xuICAgIHN0YXRpYyBhcHBseUNoYW5nZXMoZnJhZ21lbnRzLCBjaGFuZ2VzLCBtaW5HYXAgPSAxMjgpIHtcbiAgICAgICAgaWYgKCFjaGFuZ2VzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiBmcmFnbWVudHM7XG4gICAgICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICAgICAgbGV0IGZJID0gMSwgbmV4dEYgPSBmcmFnbWVudHMubGVuZ3RoID8gZnJhZ21lbnRzWzBdIDogbnVsbDtcbiAgICAgICAgZm9yIChsZXQgY0kgPSAwLCBwb3MgPSAwLCBvZmYgPSAwOzsgY0krKykge1xuICAgICAgICAgICAgbGV0IG5leHRDID0gY0kgPCBjaGFuZ2VzLmxlbmd0aCA/IGNoYW5nZXNbY0ldIDogbnVsbDtcbiAgICAgICAgICAgIGxldCBuZXh0UG9zID0gbmV4dEMgPyBuZXh0Qy5mcm9tQSA6IDFlOTtcbiAgICAgICAgICAgIGlmIChuZXh0UG9zIC0gcG9zID49IG1pbkdhcClcbiAgICAgICAgICAgICAgICB3aGlsZSAobmV4dEYgJiYgbmV4dEYuZnJvbSA8IG5leHRQb3MpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGN1dCA9IG5leHRGO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zID49IGN1dC5mcm9tIHx8IG5leHRQb3MgPD0gY3V0LnRvIHx8IG9mZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGZGcm9tID0gTWF0aC5tYXgoY3V0LmZyb20sIHBvcykgLSBvZmYsIGZUbyA9IE1hdGgubWluKGN1dC50bywgbmV4dFBvcykgLSBvZmY7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXQgPSBmRnJvbSA+PSBmVG8gPyBudWxsIDogbmV3IFRyZWVGcmFnbWVudChmRnJvbSwgZlRvLCBjdXQudHJlZSwgY3V0Lm9mZnNldCArIG9mZiwgY0kgPiAwLCAhIW5leHRDKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY3V0KVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY3V0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRGLnRvID4gbmV4dFBvcylcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBuZXh0RiA9IGZJIDwgZnJhZ21lbnRzLmxlbmd0aCA/IGZyYWdtZW50c1tmSSsrXSA6IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFuZXh0QylcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIHBvcyA9IG5leHRDLnRvQTtcbiAgICAgICAgICAgIG9mZiA9IG5leHRDLnRvQSAtIG5leHRDLnRvQjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbi8qKlxuQSBzdXBlcmNsYXNzIHRoYXQgcGFyc2VycyBzaG91bGQgZXh0ZW5kLlxuKi9cbmNsYXNzIFBhcnNlciB7XG4gICAgLyoqXG4gICAgU3RhcnQgYSBwYXJzZSwgcmV0dXJuaW5nIGEgW3BhcnRpYWwgcGFyc2VdKCNjb21tb24uUGFydGlhbFBhcnNlKVxuICAgIG9iamVjdC4gW2BmcmFnbWVudHNgXSgjY29tbW9uLlRyZWVGcmFnbWVudCkgY2FuIGJlIHBhc3NlZCBpbiB0b1xuICAgIG1ha2UgdGhlIHBhcnNlIGluY3JlbWVudGFsLlxuICAgIFxuICAgIEJ5IGRlZmF1bHQsIHRoZSBlbnRpcmUgaW5wdXQgaXMgcGFyc2VkLiBZb3UgY2FuIHBhc3MgYHJhbmdlc2AsXG4gICAgd2hpY2ggc2hvdWxkIGJlIGEgc29ydGVkIGFycmF5IG9mIG5vbi1lbXB0eSwgbm9uLW92ZXJsYXBwaW5nXG4gICAgcmFuZ2VzLCB0byBwYXJzZSBvbmx5IHRob3NlIHJhbmdlcy4gVGhlIHRyZWUgcmV0dXJuZWQgaW4gdGhhdFxuICAgIGNhc2Ugd2lsbCBzdGFydCBhdCBgcmFuZ2VzWzBdLmZyb21gLlxuICAgICovXG4gICAgc3RhcnRQYXJzZShpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgaW5wdXQgPSBuZXcgU3RyaW5nSW5wdXQoaW5wdXQpO1xuICAgICAgICByYW5nZXMgPSAhcmFuZ2VzID8gW25ldyBSYW5nZSgwLCBpbnB1dC5sZW5ndGgpXSA6IHJhbmdlcy5sZW5ndGggPyByYW5nZXMubWFwKHIgPT4gbmV3IFJhbmdlKHIuZnJvbSwgci50bykpIDogW25ldyBSYW5nZSgwLCAwKV07XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVBhcnNlKGlucHV0LCBmcmFnbWVudHMgfHwgW10sIHJhbmdlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgIFJ1biBhIGZ1bGwgcGFyc2UsIHJldHVybmluZyB0aGUgcmVzdWx0aW5nIHRyZWUuXG4gICAgKi9cbiAgICBwYXJzZShpbnB1dCwgZnJhZ21lbnRzLCByYW5nZXMpIHtcbiAgICAgICAgbGV0IHBhcnNlID0gdGhpcy5zdGFydFBhcnNlKGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcyk7XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGxldCBkb25lID0gcGFyc2UuYWR2YW5jZSgpO1xuICAgICAgICAgICAgaWYgKGRvbmUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvbmU7XG4gICAgICAgIH1cbiAgICB9XG59XG5jbGFzcyBTdHJpbmdJbnB1dCB7XG4gICAgY29uc3RydWN0b3Ioc3RyaW5nKSB7XG4gICAgICAgIHRoaXMuc3RyaW5nID0gc3RyaW5nO1xuICAgIH1cbiAgICBnZXQgbGVuZ3RoKCkgeyByZXR1cm4gdGhpcy5zdHJpbmcubGVuZ3RoOyB9XG4gICAgY2h1bmsoZnJvbSkgeyByZXR1cm4gdGhpcy5zdHJpbmcuc2xpY2UoZnJvbSk7IH1cbiAgICBnZXQgbGluZUNodW5rcygpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgcmVhZChmcm9tLCB0bykgeyByZXR1cm4gdGhpcy5zdHJpbmcuc2xpY2UoZnJvbSwgdG8pOyB9XG59XG5cbi8qKlxuQ3JlYXRlIGEgcGFyc2Ugd3JhcHBlciB0aGF0LCBhZnRlciB0aGUgaW5uZXIgcGFyc2UgY29tcGxldGVzLFxuc2NhbnMgaXRzIHRyZWUgZm9yIG1peGVkIGxhbmd1YWdlIHJlZ2lvbnMgd2l0aCB0aGUgYG5lc3RgXG5mdW5jdGlvbiwgcnVucyB0aGUgcmVzdWx0aW5nIFtpbm5lciBwYXJzZXNdKCNjb21tb24uTmVzdGVkUGFyc2UpLFxuYW5kIHRoZW4gW21vdW50c10oI2NvbW1vbi5Ob2RlUHJvcF5tb3VudGVkKSB0aGVpciByZXN1bHRzIG9udG8gdGhlXG50cmVlLlxuKi9cbmZ1bmN0aW9uIHBhcnNlTWl4ZWQobmVzdCkge1xuICAgIHJldHVybiAocGFyc2UsIGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcykgPT4gbmV3IE1peGVkUGFyc2UocGFyc2UsIG5lc3QsIGlucHV0LCBmcmFnbWVudHMsIHJhbmdlcyk7XG59XG5jbGFzcyBJbm5lclBhcnNlIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJzZXIsIHBhcnNlLCBvdmVybGF5LCB0YXJnZXQsIGZyb20pIHtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgICAgIHRoaXMucGFyc2UgPSBwYXJzZTtcbiAgICAgICAgdGhpcy5vdmVybGF5ID0gb3ZlcmxheTtcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHRoaXMuZnJvbSA9IGZyb207XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tSYW5nZXMocmFuZ2VzKSB7XG4gICAgaWYgKCFyYW5nZXMubGVuZ3RoIHx8IHJhbmdlcy5zb21lKHIgPT4gci5mcm9tID49IHIudG8pKVxuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkludmFsaWQgaW5uZXIgcGFyc2UgcmFuZ2VzIGdpdmVuOiBcIiArIEpTT04uc3RyaW5naWZ5KHJhbmdlcykpO1xufVxuY2xhc3MgQWN0aXZlT3ZlcmxheSB7XG4gICAgY29uc3RydWN0b3IocGFyc2VyLCBwcmVkaWNhdGUsIG1vdW50cywgaW5kZXgsIHN0YXJ0LCB0YXJnZXQsIHByZXYpIHtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBwYXJzZXI7XG4gICAgICAgIHRoaXMucHJlZGljYXRlID0gcHJlZGljYXRlO1xuICAgICAgICB0aGlzLm1vdW50cyA9IG1vdW50cztcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0aGlzLnN0YXJ0ID0gc3RhcnQ7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICB0aGlzLnByZXYgPSBwcmV2O1xuICAgICAgICB0aGlzLmRlcHRoID0gMDtcbiAgICAgICAgdGhpcy5yYW5nZXMgPSBbXTtcbiAgICB9XG59XG5jb25zdCBzdG9wcGVkSW5uZXIgPSBuZXcgTm9kZVByb3AoeyBwZXJOb2RlOiB0cnVlIH0pO1xuY2xhc3MgTWl4ZWRQYXJzZSB7XG4gICAgY29uc3RydWN0b3IoYmFzZSwgbmVzdCwgaW5wdXQsIGZyYWdtZW50cywgcmFuZ2VzKSB7XG4gICAgICAgIHRoaXMubmVzdCA9IG5lc3Q7XG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5mcmFnbWVudHMgPSBmcmFnbWVudHM7XG4gICAgICAgIHRoaXMucmFuZ2VzID0gcmFuZ2VzO1xuICAgICAgICB0aGlzLmlubmVyID0gW107XG4gICAgICAgIHRoaXMuaW5uZXJEb25lID0gMDtcbiAgICAgICAgdGhpcy5iYXNlVHJlZSA9IG51bGw7XG4gICAgICAgIHRoaXMuc3RvcHBlZEF0ID0gbnVsbDtcbiAgICAgICAgdGhpcy5iYXNlUGFyc2UgPSBiYXNlO1xuICAgIH1cbiAgICBhZHZhbmNlKCkge1xuICAgICAgICBpZiAodGhpcy5iYXNlUGFyc2UpIHtcbiAgICAgICAgICAgIGxldCBkb25lID0gdGhpcy5iYXNlUGFyc2UuYWR2YW5jZSgpO1xuICAgICAgICAgICAgaWYgKCFkb25lKVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgdGhpcy5iYXNlUGFyc2UgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5iYXNlVHJlZSA9IGRvbmU7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0SW5uZXIoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0b3BwZWRBdCAhPSBudWxsKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGlubmVyIG9mIHRoaXMuaW5uZXIpXG4gICAgICAgICAgICAgICAgICAgIGlubmVyLnBhcnNlLnN0b3BBdCh0aGlzLnN0b3BwZWRBdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaW5uZXJEb25lID09IHRoaXMuaW5uZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0ID0gdGhpcy5iYXNlVHJlZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0b3BwZWRBdCAhPSBudWxsKVxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBUcmVlKHJlc3VsdC50eXBlLCByZXN1bHQuY2hpbGRyZW4sIHJlc3VsdC5wb3NpdGlvbnMsIHJlc3VsdC5sZW5ndGgsIHJlc3VsdC5wcm9wVmFsdWVzLmNvbmNhdChbW3N0b3BwZWRJbm5lciwgdGhpcy5zdG9wcGVkQXRdXSkpO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaW5uZXIgPSB0aGlzLmlubmVyW3RoaXMuaW5uZXJEb25lXSwgZG9uZSA9IGlubmVyLnBhcnNlLmFkdmFuY2UoKTtcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIHRoaXMuaW5uZXJEb25lKys7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIGEgc29tZXdoYXQgZG9kZ3kgYnV0IHN1cGVyIGhlbHBmdWwgaGFjayB3aGVyZSB3ZVxuICAgICAgICAgICAgLy8gcGF0Y2ggdXAgbm9kZXMgY3JlYXRlZCBieSB0aGUgaW5uZXIgcGFyc2UgKGFuZCB0aHVzXG4gICAgICAgICAgICAvLyBwcmVzdW1hYmx5IG5vdCBhbGlhc2VkIGFueXdoZXJlIGVsc2UpIHRvIGhvbGQgdGhlIGluZm9ybWF0aW9uXG4gICAgICAgICAgICAvLyBhYm91dCB0aGUgaW5uZXIgcGFyc2UuXG4gICAgICAgICAgICBsZXQgcHJvcHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIGlubmVyLnRhcmdldC5wcm9wcyk7XG4gICAgICAgICAgICBwcm9wc1tOb2RlUHJvcC5tb3VudGVkLmlkXSA9IG5ldyBNb3VudGVkVHJlZShkb25lLCBpbm5lci5vdmVybGF5LCBpbm5lci5wYXJzZXIpO1xuICAgICAgICAgICAgaW5uZXIudGFyZ2V0LnByb3BzID0gcHJvcHM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGdldCBwYXJzZWRQb3MoKSB7XG4gICAgICAgIGlmICh0aGlzLmJhc2VQYXJzZSlcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBsZXQgcG9zID0gdGhpcy5pbnB1dC5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmlubmVyRG9uZTsgaSA8IHRoaXMuaW5uZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlubmVyW2ldLmZyb20gPCBwb3MpXG4gICAgICAgICAgICAgICAgcG9zID0gTWF0aC5taW4ocG9zLCB0aGlzLmlubmVyW2ldLnBhcnNlLnBhcnNlZFBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvcztcbiAgICB9XG4gICAgc3RvcEF0KHBvcykge1xuICAgICAgICB0aGlzLnN0b3BwZWRBdCA9IHBvcztcbiAgICAgICAgaWYgKHRoaXMuYmFzZVBhcnNlKVxuICAgICAgICAgICAgdGhpcy5iYXNlUGFyc2Uuc3RvcEF0KHBvcyk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmlubmVyRG9uZTsgaSA8IHRoaXMuaW5uZXIubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgdGhpcy5pbm5lcltpXS5wYXJzZS5zdG9wQXQocG9zKTtcbiAgICB9XG4gICAgc3RhcnRJbm5lcigpIHtcbiAgICAgICAgbGV0IGZyYWdtZW50Q3Vyc29yID0gbmV3IEZyYWdtZW50Q3Vyc29yKHRoaXMuZnJhZ21lbnRzKTtcbiAgICAgICAgbGV0IG92ZXJsYXkgPSBudWxsO1xuICAgICAgICBsZXQgY292ZXJlZCA9IG51bGw7XG4gICAgICAgIGxldCBjdXJzb3IgPSBuZXcgVHJlZUN1cnNvcihuZXcgVHJlZU5vZGUodGhpcy5iYXNlVHJlZSwgdGhpcy5yYW5nZXNbMF0uZnJvbSwgMCwgbnVsbCksIEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMgfCBJdGVyTW9kZS5JZ25vcmVNb3VudHMpO1xuICAgICAgICBzY2FuOiBmb3IgKGxldCBuZXN0LCBpc0NvdmVyZWQ7Oykge1xuICAgICAgICAgICAgbGV0IGVudGVyID0gdHJ1ZSwgcmFuZ2U7XG4gICAgICAgICAgICBpZiAodGhpcy5zdG9wcGVkQXQgIT0gbnVsbCAmJiBjdXJzb3IuZnJvbSA+PSB0aGlzLnN0b3BwZWRBdCkge1xuICAgICAgICAgICAgICAgIGVudGVyID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChmcmFnbWVudEN1cnNvci5oYXNOb2RlKGN1cnNvcikpIHtcbiAgICAgICAgICAgICAgICBpZiAob3ZlcmxheSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWF0Y2ggPSBvdmVybGF5Lm1vdW50cy5maW5kKG0gPT4gbS5mcmFnLmZyb20gPD0gY3Vyc29yLmZyb20gJiYgbS5mcmFnLnRvID49IGN1cnNvci50byAmJiBtLm1vdW50Lm92ZXJsYXkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2gpXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCByIG9mIG1hdGNoLm1vdW50Lm92ZXJsYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZnJvbSA9IHIuZnJvbSArIG1hdGNoLnBvcywgdG8gPSByLnRvICsgbWF0Y2gucG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcm9tID49IGN1cnNvci5mcm9tICYmIHRvIDw9IGN1cnNvci50byAmJiAhb3ZlcmxheS5yYW5nZXMuc29tZShyID0+IHIuZnJvbSA8IHRvICYmIHIudG8gPiBmcm9tKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxheS5yYW5nZXMucHVzaCh7IGZyb20sIHRvIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbnRlciA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY292ZXJlZCAmJiAoaXNDb3ZlcmVkID0gY2hlY2tDb3Zlcihjb3ZlcmVkLnJhbmdlcywgY3Vyc29yLmZyb20sIGN1cnNvci50bykpKSB7XG4gICAgICAgICAgICAgICAgZW50ZXIgPSBpc0NvdmVyZWQgIT0gMiAvKiBDb3Zlci5GdWxsICovO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWN1cnNvci50eXBlLmlzQW5vbnltb3VzICYmIChuZXN0ID0gdGhpcy5uZXN0KGN1cnNvciwgdGhpcy5pbnB1dCkpICYmXG4gICAgICAgICAgICAgICAgKGN1cnNvci5mcm9tIDwgY3Vyc29yLnRvIHx8ICFuZXN0Lm92ZXJsYXkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjdXJzb3IudHJlZSlcbiAgICAgICAgICAgICAgICAgICAgbWF0ZXJpYWxpemUoY3Vyc29yKTtcbiAgICAgICAgICAgICAgICBsZXQgb2xkTW91bnRzID0gZnJhZ21lbnRDdXJzb3IuZmluZE1vdW50cyhjdXJzb3IuZnJvbSwgbmVzdC5wYXJzZXIpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbmVzdC5vdmVybGF5ID09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICBvdmVybGF5ID0gbmV3IEFjdGl2ZU92ZXJsYXkobmVzdC5wYXJzZXIsIG5lc3Qub3ZlcmxheSwgb2xkTW91bnRzLCB0aGlzLmlubmVyLmxlbmd0aCwgY3Vyc29yLmZyb20sIGN1cnNvci50cmVlLCBvdmVybGF5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByYW5nZXMgPSBwdW5jaFJhbmdlcyh0aGlzLnJhbmdlcywgbmVzdC5vdmVybGF5IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAoY3Vyc29yLmZyb20gPCBjdXJzb3IudG8gPyBbbmV3IFJhbmdlKGN1cnNvci5mcm9tLCBjdXJzb3IudG8pXSA6IFtdKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyYW5nZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tSYW5nZXMocmFuZ2VzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlcy5sZW5ndGggfHwgIW5lc3Qub3ZlcmxheSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5uZXIucHVzaChuZXcgSW5uZXJQYXJzZShuZXN0LnBhcnNlciwgcmFuZ2VzLmxlbmd0aCA/IG5lc3QucGFyc2VyLnN0YXJ0UGFyc2UodGhpcy5pbnB1dCwgZW50ZXJGcmFnbWVudHMob2xkTW91bnRzLCByYW5nZXMpLCByYW5nZXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBuZXN0LnBhcnNlci5zdGFydFBhcnNlKFwiXCIpLCBuZXN0Lm92ZXJsYXkgPyBuZXN0Lm92ZXJsYXkubWFwKHIgPT4gbmV3IFJhbmdlKHIuZnJvbSAtIGN1cnNvci5mcm9tLCByLnRvIC0gY3Vyc29yLmZyb20pKSA6IG51bGwsIGN1cnNvci50cmVlLCByYW5nZXMubGVuZ3RoID8gcmFuZ2VzWzBdLmZyb20gOiBjdXJzb3IuZnJvbSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5lc3Qub3ZlcmxheSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGVudGVyID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJhbmdlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3ZlcmVkID0geyByYW5nZXMsIGRlcHRoOiAwLCBwcmV2OiBjb3ZlcmVkIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3ZlcmxheSAmJiAocmFuZ2UgPSBvdmVybGF5LnByZWRpY2F0ZShjdXJzb3IpKSkge1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZSA9PT0gdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UgPSBuZXcgUmFuZ2UoY3Vyc29yLmZyb20sIGN1cnNvci50byk7XG4gICAgICAgICAgICAgICAgaWYgKHJhbmdlLmZyb20gPCByYW5nZS50bylcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxheS5yYW5nZXMucHVzaChyYW5nZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZW50ZXIgJiYgY3Vyc29yLmZpcnN0Q2hpbGQoKSkge1xuICAgICAgICAgICAgICAgIGlmIChvdmVybGF5KVxuICAgICAgICAgICAgICAgICAgICBvdmVybGF5LmRlcHRoKys7XG4gICAgICAgICAgICAgICAgaWYgKGNvdmVyZWQpXG4gICAgICAgICAgICAgICAgICAgIGNvdmVyZWQuZGVwdGgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnNvci5uZXh0U2libGluZygpKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY3Vyc29yLnBhcmVudCgpKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWsgc2NhbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG92ZXJsYXkgJiYgIS0tb3ZlcmxheS5kZXB0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJhbmdlcyA9IHB1bmNoUmFuZ2VzKHRoaXMucmFuZ2VzLCBvdmVybGF5LnJhbmdlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmFuZ2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrUmFuZ2VzKHJhbmdlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbm5lci5zcGxpY2Uob3ZlcmxheS5pbmRleCwgMCwgbmV3IElubmVyUGFyc2Uob3ZlcmxheS5wYXJzZXIsIG92ZXJsYXkucGFyc2VyLnN0YXJ0UGFyc2UodGhpcy5pbnB1dCwgZW50ZXJGcmFnbWVudHMob3ZlcmxheS5tb3VudHMsIHJhbmdlcyksIHJhbmdlcyksIG92ZXJsYXkucmFuZ2VzLm1hcChyID0+IG5ldyBSYW5nZShyLmZyb20gLSBvdmVybGF5LnN0YXJ0LCByLnRvIC0gb3ZlcmxheS5zdGFydCkpLCBvdmVybGF5LnRhcmdldCwgcmFuZ2VzWzBdLmZyb20pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXkgPSBvdmVybGF5LnByZXY7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvdmVyZWQgJiYgIS0tY292ZXJlZC5kZXB0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvdmVyZWQgPSBjb3ZlcmVkLnByZXY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gY2hlY2tDb3Zlcihjb3ZlcmVkLCBmcm9tLCB0bykge1xuICAgIGZvciAobGV0IHJhbmdlIG9mIGNvdmVyZWQpIHtcbiAgICAgICAgaWYgKHJhbmdlLmZyb20gPj0gdG8pXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKHJhbmdlLnRvID4gZnJvbSlcbiAgICAgICAgICAgIHJldHVybiByYW5nZS5mcm9tIDw9IGZyb20gJiYgcmFuZ2UudG8gPj0gdG8gPyAyIC8qIENvdmVyLkZ1bGwgKi8gOiAxIC8qIENvdmVyLlBhcnRpYWwgKi87XG4gICAgfVxuICAgIHJldHVybiAwIC8qIENvdmVyLk5vbmUgKi87XG59XG4vLyBUYWtlIGEgcGllY2Ugb2YgYnVmZmVyIGFuZCBjb252ZXJ0IGl0IGludG8gYSBzdGFuZC1hbG9uZVxuLy8gVHJlZUJ1ZmZlci5cbmZ1bmN0aW9uIHNsaWNlQnVmKGJ1Ziwgc3RhcnRJLCBlbmRJLCBub2RlcywgcG9zaXRpb25zLCBvZmYpIHtcbiAgICBpZiAoc3RhcnRJIDwgZW5kSSkge1xuICAgICAgICBsZXQgZnJvbSA9IGJ1Zi5idWZmZXJbc3RhcnRJICsgMV07XG4gICAgICAgIG5vZGVzLnB1c2goYnVmLnNsaWNlKHN0YXJ0SSwgZW5kSSwgZnJvbSkpO1xuICAgICAgICBwb3NpdGlvbnMucHVzaChmcm9tIC0gb2ZmKTtcbiAgICB9XG59XG4vLyBUaGlzIGZ1bmN0aW9uIHRha2VzIGEgbm9kZSB0aGF0J3MgaW4gYSBidWZmZXIsIGFuZCBjb252ZXJ0cyBpdCwgYW5kXG4vLyBpdHMgcGFyZW50IGJ1ZmZlciBub2RlcywgaW50byBhIFRyZWUuIFRoaXMgaXMgYWdhaW4gYWN0aW5nIG9uIHRoZVxuLy8gYXNzdW1wdGlvbiB0aGF0IHRoZSB0cmVlcyBhbmQgYnVmZmVycyBoYXZlIGJlZW4gY29uc3RydWN0ZWQgYnkgdGhlXG4vLyBwYXJzZSB0aGF0IHdhcyByYW4gdmlhIHRoZSBtaXggcGFyc2VyLCBhbmQgdGh1cyBhcmVuJ3Qgc2hhcmVkIHdpdGhcbi8vIGFueSBvdGhlciBjb2RlLCBtYWtpbmcgdmlvbGF0aW9ucyBvZiB0aGUgaW1tdXRhYmlsaXR5IHNhZmUuXG5mdW5jdGlvbiBtYXRlcmlhbGl6ZShjdXJzb3IpIHtcbiAgICBsZXQgeyBub2RlIH0gPSBjdXJzb3IsIHN0YWNrID0gW107XG4gICAgbGV0IGJ1ZmZlciA9IG5vZGUuY29udGV4dC5idWZmZXI7XG4gICAgLy8gU2NhbiB1cCB0byB0aGUgbmVhcmVzdCB0cmVlXG4gICAgZG8ge1xuICAgICAgICBzdGFjay5wdXNoKGN1cnNvci5pbmRleCk7XG4gICAgICAgIGN1cnNvci5wYXJlbnQoKTtcbiAgICB9IHdoaWxlICghY3Vyc29yLnRyZWUpO1xuICAgIC8vIEZpbmQgdGhlIGluZGV4IG9mIHRoZSBidWZmZXIgaW4gdGhhdCB0cmVlXG4gICAgbGV0IGJhc2UgPSBjdXJzb3IudHJlZSwgaSA9IGJhc2UuY2hpbGRyZW4uaW5kZXhPZihidWZmZXIpO1xuICAgIGxldCBidWYgPSBiYXNlLmNoaWxkcmVuW2ldLCBiID0gYnVmLmJ1ZmZlciwgbmV3U3RhY2sgPSBbaV07XG4gICAgLy8gU3BsaXQgYSBsZXZlbCBpbiB0aGUgYnVmZmVyLCBwdXR0aW5nIHRoZSBub2RlcyBiZWZvcmUgYW5kIGFmdGVyXG4gICAgLy8gdGhlIGNoaWxkIHRoYXQgY29udGFpbnMgYG5vZGVgIGludG8gbmV3IGJ1ZmZlcnMuXG4gICAgZnVuY3Rpb24gc3BsaXQoc3RhcnRJLCBlbmRJLCB0eXBlLCBpbm5lck9mZnNldCwgbGVuZ3RoLCBzdGFja1Bvcykge1xuICAgICAgICBsZXQgdGFyZ2V0SSA9IHN0YWNrW3N0YWNrUG9zXTtcbiAgICAgICAgbGV0IGNoaWxkcmVuID0gW10sIHBvc2l0aW9ucyA9IFtdO1xuICAgICAgICBzbGljZUJ1ZihidWYsIHN0YXJ0SSwgdGFyZ2V0SSwgY2hpbGRyZW4sIHBvc2l0aW9ucywgaW5uZXJPZmZzZXQpO1xuICAgICAgICBsZXQgZnJvbSA9IGJbdGFyZ2V0SSArIDFdLCB0byA9IGJbdGFyZ2V0SSArIDJdO1xuICAgICAgICBuZXdTdGFjay5wdXNoKGNoaWxkcmVuLmxlbmd0aCk7XG4gICAgICAgIGxldCBjaGlsZCA9IHN0YWNrUG9zXG4gICAgICAgICAgICA/IHNwbGl0KHRhcmdldEkgKyA0LCBiW3RhcmdldEkgKyAzXSwgYnVmLnNldC50eXBlc1tiW3RhcmdldEldXSwgZnJvbSwgdG8gLSBmcm9tLCBzdGFja1BvcyAtIDEpXG4gICAgICAgICAgICA6IG5vZGUudG9UcmVlKCk7XG4gICAgICAgIGNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgICAgICBwb3NpdGlvbnMucHVzaChmcm9tIC0gaW5uZXJPZmZzZXQpO1xuICAgICAgICBzbGljZUJ1ZihidWYsIGJbdGFyZ2V0SSArIDNdLCBlbmRJLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBpbm5lck9mZnNldCk7XG4gICAgICAgIHJldHVybiBuZXcgVHJlZSh0eXBlLCBjaGlsZHJlbiwgcG9zaXRpb25zLCBsZW5ndGgpO1xuICAgIH1cbiAgICBiYXNlLmNoaWxkcmVuW2ldID0gc3BsaXQoMCwgYi5sZW5ndGgsIE5vZGVUeXBlLm5vbmUsIDAsIGJ1Zi5sZW5ndGgsIHN0YWNrLmxlbmd0aCAtIDEpO1xuICAgIC8vIE1vdmUgdGhlIGN1cnNvciBiYWNrIHRvIHRoZSB0YXJnZXQgbm9kZVxuICAgIGZvciAobGV0IGluZGV4IG9mIG5ld1N0YWNrKSB7XG4gICAgICAgIGxldCB0cmVlID0gY3Vyc29yLnRyZWUuY2hpbGRyZW5baW5kZXhdLCBwb3MgPSBjdXJzb3IudHJlZS5wb3NpdGlvbnNbaW5kZXhdO1xuICAgICAgICBjdXJzb3IueWllbGQobmV3IFRyZWVOb2RlKHRyZWUsIHBvcyArIGN1cnNvci5mcm9tLCBpbmRleCwgY3Vyc29yLl90cmVlKSk7XG4gICAgfVxufVxuY2xhc3MgU3RydWN0dXJlQ3Vyc29yIHtcbiAgICBjb25zdHJ1Y3Rvcihyb290LCBvZmZzZXQpIHtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmN1cnNvciA9IHJvb3QuY3Vyc29yKEl0ZXJNb2RlLkluY2x1ZGVBbm9ueW1vdXMgfCBJdGVyTW9kZS5JZ25vcmVNb3VudHMpO1xuICAgIH1cbiAgICAvLyBNb3ZlIHRvIHRoZSBmaXJzdCBub2RlIChpbiBwcmUtb3JkZXIpIHRoYXQgc3RhcnRzIGF0IG9yIGFmdGVyIGBwb3NgLlxuICAgIG1vdmVUbyhwb3MpIHtcbiAgICAgICAgbGV0IHsgY3Vyc29yIH0gPSB0aGlzLCBwID0gcG9zIC0gdGhpcy5vZmZzZXQ7XG4gICAgICAgIHdoaWxlICghdGhpcy5kb25lICYmIGN1cnNvci5mcm9tIDwgcCkge1xuICAgICAgICAgICAgaWYgKGN1cnNvci50byA+PSBwb3MgJiYgY3Vyc29yLmVudGVyKHAsIDEsIEl0ZXJNb2RlLklnbm9yZU92ZXJsYXlzIHwgSXRlck1vZGUuRXhjbHVkZUJ1ZmZlcnMpKSA7XG4gICAgICAgICAgICBlbHNlIGlmICghY3Vyc29yLm5leHQoZmFsc2UpKVxuICAgICAgICAgICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFzTm9kZShjdXJzb3IpIHtcbiAgICAgICAgdGhpcy5tb3ZlVG8oY3Vyc29yLmZyb20pO1xuICAgICAgICBpZiAoIXRoaXMuZG9uZSAmJiB0aGlzLmN1cnNvci5mcm9tICsgdGhpcy5vZmZzZXQgPT0gY3Vyc29yLmZyb20gJiYgdGhpcy5jdXJzb3IudHJlZSkge1xuICAgICAgICAgICAgZm9yIChsZXQgdHJlZSA9IHRoaXMuY3Vyc29yLnRyZWU7Oykge1xuICAgICAgICAgICAgICAgIGlmICh0cmVlID09IGN1cnNvci50cmVlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAodHJlZS5jaGlsZHJlbi5sZW5ndGggJiYgdHJlZS5wb3NpdGlvbnNbMF0gPT0gMCAmJiB0cmVlLmNoaWxkcmVuWzBdIGluc3RhbmNlb2YgVHJlZSlcbiAgICAgICAgICAgICAgICAgICAgdHJlZSA9IHRyZWUuY2hpbGRyZW5bMF07XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuY2xhc3MgRnJhZ21lbnRDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKGZyYWdtZW50cykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRoaXMuZnJhZ21lbnRzID0gZnJhZ21lbnRzO1xuICAgICAgICB0aGlzLmN1clRvID0gMDtcbiAgICAgICAgdGhpcy5mcmFnSSA9IDA7XG4gICAgICAgIGlmIChmcmFnbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgZmlyc3QgPSB0aGlzLmN1ckZyYWcgPSBmcmFnbWVudHNbMF07XG4gICAgICAgICAgICB0aGlzLmN1clRvID0gKF9hID0gZmlyc3QudHJlZS5wcm9wKHN0b3BwZWRJbm5lcikpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZpcnN0LnRvO1xuICAgICAgICAgICAgdGhpcy5pbm5lciA9IG5ldyBTdHJ1Y3R1cmVDdXJzb3IoZmlyc3QudHJlZSwgLWZpcnN0Lm9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmN1ckZyYWcgPSB0aGlzLmlubmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYXNOb2RlKG5vZGUpIHtcbiAgICAgICAgd2hpbGUgKHRoaXMuY3VyRnJhZyAmJiBub2RlLmZyb20gPj0gdGhpcy5jdXJUbylcbiAgICAgICAgICAgIHRoaXMubmV4dEZyYWcoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VyRnJhZyAmJiB0aGlzLmN1ckZyYWcuZnJvbSA8PSBub2RlLmZyb20gJiYgdGhpcy5jdXJUbyA+PSBub2RlLnRvICYmIHRoaXMuaW5uZXIuaGFzTm9kZShub2RlKTtcbiAgICB9XG4gICAgbmV4dEZyYWcoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5mcmFnSSsrO1xuICAgICAgICBpZiAodGhpcy5mcmFnSSA9PSB0aGlzLmZyYWdtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuY3VyRnJhZyA9IHRoaXMuaW5uZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGZyYWcgPSB0aGlzLmN1ckZyYWcgPSB0aGlzLmZyYWdtZW50c1t0aGlzLmZyYWdJXTtcbiAgICAgICAgICAgIHRoaXMuY3VyVG8gPSAoX2EgPSBmcmFnLnRyZWUucHJvcChzdG9wcGVkSW5uZXIpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmcmFnLnRvO1xuICAgICAgICAgICAgdGhpcy5pbm5lciA9IG5ldyBTdHJ1Y3R1cmVDdXJzb3IoZnJhZy50cmVlLCAtZnJhZy5vZmZzZXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZpbmRNb3VudHMocG9zLCBwYXJzZXIpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGlmICh0aGlzLmlubmVyKSB7XG4gICAgICAgICAgICB0aGlzLmlubmVyLmN1cnNvci5tb3ZlVG8ocG9zLCAxKTtcbiAgICAgICAgICAgIGZvciAobGV0IHBvcyA9IHRoaXMuaW5uZXIuY3Vyc29yLm5vZGU7IHBvczsgcG9zID0gcG9zLnBhcmVudCkge1xuICAgICAgICAgICAgICAgIGxldCBtb3VudCA9IChfYSA9IHBvcy50cmVlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucHJvcChOb2RlUHJvcC5tb3VudGVkKTtcbiAgICAgICAgICAgICAgICBpZiAobW91bnQgJiYgbW91bnQucGFyc2VyID09IHBhcnNlcikge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5mcmFnSTsgaSA8IHRoaXMuZnJhZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgZnJhZyA9IHRoaXMuZnJhZ21lbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZyYWcuZnJvbSA+PSBwb3MudG8pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJhZy50cmVlID09IHRoaXMuY3VyRnJhZy50cmVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zOiBwb3MuZnJvbSAtIGZyYWcub2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3VudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuZnVuY3Rpb24gcHVuY2hSYW5nZXMob3V0ZXIsIHJhbmdlcykge1xuICAgIGxldCBjb3B5ID0gbnVsbCwgY3VycmVudCA9IHJhbmdlcztcbiAgICBmb3IgKGxldCBpID0gMSwgaiA9IDA7IGkgPCBvdXRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgZ2FwRnJvbSA9IG91dGVyW2kgLSAxXS50bywgZ2FwVG8gPSBvdXRlcltpXS5mcm9tO1xuICAgICAgICBmb3IgKDsgaiA8IGN1cnJlbnQubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGxldCByID0gY3VycmVudFtqXTtcbiAgICAgICAgICAgIGlmIChyLmZyb20gPj0gZ2FwVG8pXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBpZiAoci50byA8PSBnYXBGcm9tKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKCFjb3B5KVxuICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjb3B5ID0gcmFuZ2VzLnNsaWNlKCk7XG4gICAgICAgICAgICBpZiAoci5mcm9tIDwgZ2FwRnJvbSkge1xuICAgICAgICAgICAgICAgIGNvcHlbal0gPSBuZXcgUmFuZ2Uoci5mcm9tLCBnYXBGcm9tKTtcbiAgICAgICAgICAgICAgICBpZiAoci50byA+IGdhcFRvKVxuICAgICAgICAgICAgICAgICAgICBjb3B5LnNwbGljZShqICsgMSwgMCwgbmV3IFJhbmdlKGdhcFRvLCByLnRvKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyLnRvID4gZ2FwVG8pIHtcbiAgICAgICAgICAgICAgICBjb3B5W2otLV0gPSBuZXcgUmFuZ2UoZ2FwVG8sIHIudG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29weS5zcGxpY2Uoai0tLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3VycmVudDtcbn1cbmZ1bmN0aW9uIGZpbmRDb3ZlckNoYW5nZXMoYSwgYiwgZnJvbSwgdG8pIHtcbiAgICBsZXQgaUEgPSAwLCBpQiA9IDAsIGluQSA9IGZhbHNlLCBpbkIgPSBmYWxzZSwgcG9zID0gLTFlOTtcbiAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgZm9yICg7Oykge1xuICAgICAgICBsZXQgbmV4dEEgPSBpQSA9PSBhLmxlbmd0aCA/IDFlOSA6IGluQSA/IGFbaUFdLnRvIDogYVtpQV0uZnJvbTtcbiAgICAgICAgbGV0IG5leHRCID0gaUIgPT0gYi5sZW5ndGggPyAxZTkgOiBpbkIgPyBiW2lCXS50byA6IGJbaUJdLmZyb207XG4gICAgICAgIGlmIChpbkEgIT0gaW5CKSB7XG4gICAgICAgICAgICBsZXQgc3RhcnQgPSBNYXRoLm1heChwb3MsIGZyb20pLCBlbmQgPSBNYXRoLm1pbihuZXh0QSwgbmV4dEIsIHRvKTtcbiAgICAgICAgICAgIGlmIChzdGFydCA8IGVuZClcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXcgUmFuZ2Uoc3RhcnQsIGVuZCkpO1xuICAgICAgICB9XG4gICAgICAgIHBvcyA9IE1hdGgubWluKG5leHRBLCBuZXh0Qik7XG4gICAgICAgIGlmIChwb3MgPT0gMWU5KVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmIChuZXh0QSA9PSBwb3MpIHtcbiAgICAgICAgICAgIGlmICghaW5BKVxuICAgICAgICAgICAgICAgIGluQSA9IHRydWU7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbkEgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpQSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuZXh0QiA9PSBwb3MpIHtcbiAgICAgICAgICAgIGlmICghaW5CKVxuICAgICAgICAgICAgICAgIGluQiA9IHRydWU7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbkIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpQisrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vLyBHaXZlbiBhIG51bWJlciBvZiBmcmFnbWVudHMgZm9yIHRoZSBvdXRlciB0cmVlLCBhbmQgYSBzZXQgb2YgcmFuZ2VzXG4vLyB0byBwYXJzZSwgZmluZCBmcmFnbWVudHMgZm9yIGlubmVyIHRyZWVzIG1vdW50ZWQgYXJvdW5kIHRob3NlXG4vLyByYW5nZXMsIGlmIGFueS5cbmZ1bmN0aW9uIGVudGVyRnJhZ21lbnRzKG1vdW50cywgcmFuZ2VzKSB7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IHsgcG9zLCBtb3VudCwgZnJhZyB9IG9mIG1vdW50cykge1xuICAgICAgICBsZXQgc3RhcnRQb3MgPSBwb3MgKyAobW91bnQub3ZlcmxheSA/IG1vdW50Lm92ZXJsYXlbMF0uZnJvbSA6IDApLCBlbmRQb3MgPSBzdGFydFBvcyArIG1vdW50LnRyZWUubGVuZ3RoO1xuICAgICAgICBsZXQgZnJvbSA9IE1hdGgubWF4KGZyYWcuZnJvbSwgc3RhcnRQb3MpLCB0byA9IE1hdGgubWluKGZyYWcudG8sIGVuZFBvcyk7XG4gICAgICAgIGlmIChtb3VudC5vdmVybGF5KSB7XG4gICAgICAgICAgICBsZXQgb3ZlcmxheSA9IG1vdW50Lm92ZXJsYXkubWFwKHIgPT4gbmV3IFJhbmdlKHIuZnJvbSArIHBvcywgci50byArIHBvcykpO1xuICAgICAgICAgICAgbGV0IGNoYW5nZXMgPSBmaW5kQ292ZXJDaGFuZ2VzKHJhbmdlcywgb3ZlcmxheSwgZnJvbSwgdG8pO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDAsIHBvcyA9IGZyb207OyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgbGFzdCA9IGkgPT0gY2hhbmdlcy5sZW5ndGgsIGVuZCA9IGxhc3QgPyB0byA6IGNoYW5nZXNbaV0uZnJvbTtcbiAgICAgICAgICAgICAgICBpZiAoZW5kID4gcG9zKVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChuZXcgVHJlZUZyYWdtZW50KHBvcywgZW5kLCBtb3VudC50cmVlLCAtc3RhcnRQb3MsIGZyYWcuZnJvbSA+PSBwb3MgfHwgZnJhZy5vcGVuU3RhcnQsIGZyYWcudG8gPD0gZW5kIHx8IGZyYWcub3BlbkVuZCkpO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0KVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBwb3MgPSBjaGFuZ2VzW2ldLnRvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV3IFRyZWVGcmFnbWVudChmcm9tLCB0bywgbW91bnQudHJlZSwgLXN0YXJ0UG9zLCBmcmFnLmZyb20gPj0gc3RhcnRQb3MgfHwgZnJhZy5vcGVuU3RhcnQsIGZyYWcudG8gPD0gZW5kUG9zIHx8IGZyYWcub3BlbkVuZCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCB7IERlZmF1bHRCdWZmZXJMZW5ndGgsIEl0ZXJNb2RlLCBNb3VudGVkVHJlZSwgTm9kZVByb3AsIE5vZGVTZXQsIE5vZGVUeXBlLCBOb2RlV2Vha01hcCwgUGFyc2VyLCBUcmVlLCBUcmVlQnVmZmVyLCBUcmVlQ3Vyc29yLCBUcmVlRnJhZ21lbnQsIHBhcnNlTWl4ZWQgfTtcbiJdLCJuYW1lcyI6WyJEZWZhdWx0QnVmZmVyTGVuZ3RoIiwibmV4dFByb3BJRCIsIlJhbmdlIiwiY29uc3RydWN0b3IiLCJmcm9tIiwidG8iLCJOb2RlUHJvcCIsImNvbmZpZyIsImlkIiwicGVyTm9kZSIsImRlc2VyaWFsaXplIiwiRXJyb3IiLCJhZGQiLCJtYXRjaCIsIlJhbmdlRXJyb3IiLCJOb2RlVHlwZSIsInR5cGUiLCJyZXN1bHQiLCJ1bmRlZmluZWQiLCJjbG9zZWRCeSIsInN0ciIsInNwbGl0Iiwib3BlbmVkQnkiLCJncm91cCIsImlzb2xhdGUiLCJ2YWx1ZSIsImNvbnRleHRIYXNoIiwibG9va0FoZWFkIiwibW91bnRlZCIsIk1vdW50ZWRUcmVlIiwidHJlZSIsIm92ZXJsYXkiLCJwYXJzZXIiLCJnZXQiLCJwcm9wcyIsIm5vUHJvcHMiLCJPYmplY3QiLCJjcmVhdGUiLCJuYW1lIiwiZmxhZ3MiLCJkZWZpbmUiLCJzcGVjIiwibGVuZ3RoIiwidG9wIiwic2tpcHBlZCIsImVycm9yIiwic3JjIiwiQXJyYXkiLCJpc0FycmF5IiwicHJvcCIsImlzVG9wIiwiaXNTa2lwcGVkIiwiaXNFcnJvciIsImlzQW5vbnltb3VzIiwiaXMiLCJpbmRleE9mIiwibWFwIiwiZGlyZWN0Iiwibm9kZSIsImdyb3VwcyIsImkiLCJmb3VuZCIsIm5vbmUiLCJOb2RlU2V0IiwidHlwZXMiLCJleHRlbmQiLCJuZXdUeXBlcyIsIm5ld1Byb3BzIiwic291cmNlIiwiYXNzaWduIiwicHVzaCIsIkNhY2hlZE5vZGUiLCJXZWFrTWFwIiwiQ2FjaGVkSW5uZXJOb2RlIiwiSXRlck1vZGUiLCJUcmVlIiwiY2hpbGRyZW4iLCJwb3NpdGlvbnMiLCJ0b1N0cmluZyIsImNoIiwidGVzdCIsIkpTT04iLCJzdHJpbmdpZnkiLCJjdXJzb3IiLCJtb2RlIiwiVHJlZUN1cnNvciIsInRvcE5vZGUiLCJjdXJzb3JBdCIsInBvcyIsInNpZGUiLCJzY29wZSIsIm1vdmVUbyIsInNldCIsIl90cmVlIiwiVHJlZU5vZGUiLCJyZXNvbHZlIiwicmVzb2x2ZU5vZGUiLCJyZXNvbHZlSW5uZXIiLCJyZXNvbHZlU3RhY2siLCJzdGFja0l0ZXJhdG9yIiwiaXRlcmF0ZSIsImVudGVyIiwibGVhdmUiLCJhbm9uIiwiSW5jbHVkZUFub255bW91cyIsImMiLCJlbnRlcmVkIiwiZmlyc3RDaGlsZCIsIm5leHRTaWJsaW5nIiwicGFyZW50IiwicHJvcFZhbHVlcyIsImJhbGFuY2UiLCJiYWxhbmNlUmFuZ2UiLCJtYWtlVHJlZSIsImJ1aWxkIiwiZGF0YSIsImJ1aWxkVHJlZSIsImVtcHR5IiwiRmxhdEJ1ZmZlckN1cnNvciIsImJ1ZmZlciIsImluZGV4Iiwic3RhcnQiLCJlbmQiLCJzaXplIiwibmV4dCIsImZvcmsiLCJUcmVlQnVmZmVyIiwiY2hpbGRTdHJpbmciLCJqb2luIiwiZW5kSW5kZXgiLCJmaW5kQ2hpbGQiLCJzdGFydEluZGV4IiwiZGlyIiwicGljayIsImNoZWNrU2lkZSIsInNsaWNlIiwic3RhcnRJIiwiZW5kSSIsImIiLCJjb3B5IiwiVWludDE2QXJyYXkiLCJsZW4iLCJqIiwiTWF0aCIsIm1heCIsIm92ZXJsYXlzIiwiX2EiLCJJZ25vcmVPdmVybGF5cyIsInNjYW4iLCJpbm5lciIsIkJhc2VOb2RlIiwiZ2V0Q2hpbGQiLCJiZWZvcmUiLCJhZnRlciIsInIiLCJnZXRDaGlsZHJlbiIsIm1hdGNoQ29udGV4dCIsImNvbnRleHQiLCJtYXRjaE5vZGVDb250ZXh0IiwiZW50ZXJVbmZpbmlzaGVkTm9kZXNCZWZvcmUiLCJjaGlsZEJlZm9yZSIsImxhc3QiLCJsYXN0Q2hpbGQiLCJwcmV2U2libGluZyIsIl9wYXJlbnQiLCJuZXh0Q2hpbGQiLCJlIiwiRXhjbHVkZUJ1ZmZlcnMiLCJCdWZmZXJOb2RlIiwiQnVmZmVyQ29udGV4dCIsImhhc0NoaWxkIiwiSWdub3JlTW91bnRzIiwiY2hpbGRBZnRlciIsInJQb3MiLCJuZXh0U2lnbmlmaWNhbnRQYXJlbnQiLCJ2YWwiLCJ0b1RyZWUiLCJjdXIiLCJwIiwiY2hpbGQiLCJleHRlcm5hbFNpYmxpbmciLCJwYXJlbnRTdGFydCIsIml0ZXJTdGFjayIsImhlYWRzIiwicGlja2VkIiwibmV3SGVhZHMiLCJzcGxpY2UiLCJTdGFja0l0ZXJhdG9yIiwibGF5ZXJzIiwibW91bnQiLCJyb290Iiwic3RhY2siLCJidWZmZXJOb2RlIiwieWllbGROb2RlIiwibiIsInVuc2hpZnQiLCJ5aWVsZEJ1ZiIsInlpZWxkIiwiZW50ZXJDaGlsZCIsInBvcCIsInNpYmxpbmciLCJkIiwiYXRMYXN0Tm9kZSIsIm1vdmUiLCJwcmV2IiwiY2FjaGUiLCJkZXB0aCIsIm11c3RMZWF2ZSIsInNvbWUiLCJub2RlU2V0IiwibWF4QnVmZmVyTGVuZ3RoIiwicmV1c2VkIiwibWluUmVwZWF0VHlwZSIsInRha2VOb2RlIiwibWluUG9zIiwiaW5SZXBlYXQiLCJsb29rQWhlYWRBdFN0YXJ0Iiwic3RhcnRQb3MiLCJmaW5kQnVmZmVyU2l6ZSIsInNraXAiLCJlbmRQb3MiLCJjb3B5VG9CdWZmZXIiLCJsb2NhbENoaWxkcmVuIiwibG9jYWxQb3NpdGlvbnMiLCJsb2NhbEluUmVwZWF0IiwibGFzdEdyb3VwIiwibGFzdEVuZCIsIm1ha2VSZXBlYXRMZWFmIiwidGFrZUZsYXROb2RlIiwicmV2ZXJzZSIsIm1ha2UiLCJtYWtlQmFsYW5jZWQiLCJub2RlcyIsIm5vZGVDb3VudCIsInN0b3BBdCIsImxhc3RJIiwibG9va0FoZWFkUHJvcCIsImJhc2UiLCJwYWlyIiwiY29uY2F0IiwibWF4U2l6ZSIsIm1pblN0YXJ0Iiwibm9kZVNpemUiLCJsb2NhbFNraXBwZWQiLCJub2RlU3RhcnQiLCJidWZmZXJTdGFydCIsInRvcElEIiwibm9kZVNpemVDYWNoZSIsImJhbGFuY2VUeXBlIiwibWtUb3AiLCJta1RyZWUiLCJ0b3RhbCIsIm1heENoaWxkIiwiY2VpbCIsImRpdmlkZSIsIm9mZnNldCIsImdyb3VwRnJvbSIsImdyb3VwU3RhcnQiLCJncm91cFNpemUiLCJuZXh0U2l6ZSIsIm9ubHkiLCJOb2RlV2Vha01hcCIsInNldEJ1ZmZlciIsIk1hcCIsImdldEJ1ZmZlciIsImN1cnNvclNldCIsImN1cnNvckdldCIsIlRyZWVGcmFnbWVudCIsIm9wZW5TdGFydCIsIm9wZW5FbmQiLCJvcGVuIiwiYWRkVHJlZSIsImZyYWdtZW50cyIsInBhcnRpYWwiLCJmIiwiYXBwbHlDaGFuZ2VzIiwiY2hhbmdlcyIsIm1pbkdhcCIsImZJIiwibmV4dEYiLCJjSSIsIm9mZiIsIm5leHRDIiwibmV4dFBvcyIsImZyb21BIiwiY3V0IiwiZkZyb20iLCJmVG8iLCJtaW4iLCJ0b0EiLCJ0b0IiLCJQYXJzZXIiLCJzdGFydFBhcnNlIiwiaW5wdXQiLCJyYW5nZXMiLCJTdHJpbmdJbnB1dCIsImNyZWF0ZVBhcnNlIiwicGFyc2UiLCJkb25lIiwiYWR2YW5jZSIsInN0cmluZyIsImNodW5rIiwibGluZUNodW5rcyIsInJlYWQiLCJwYXJzZU1peGVkIiwibmVzdCIsIk1peGVkUGFyc2UiLCJJbm5lclBhcnNlIiwidGFyZ2V0IiwiY2hlY2tSYW5nZXMiLCJBY3RpdmVPdmVybGF5IiwicHJlZGljYXRlIiwibW91bnRzIiwic3RvcHBlZElubmVyIiwiaW5uZXJEb25lIiwiYmFzZVRyZWUiLCJzdG9wcGVkQXQiLCJiYXNlUGFyc2UiLCJzdGFydElubmVyIiwicGFyc2VkUG9zIiwiZnJhZ21lbnRDdXJzb3IiLCJGcmFnbWVudEN1cnNvciIsImNvdmVyZWQiLCJpc0NvdmVyZWQiLCJyYW5nZSIsImhhc05vZGUiLCJmaW5kIiwibSIsImZyYWciLCJjaGVja0NvdmVyIiwibWF0ZXJpYWxpemUiLCJvbGRNb3VudHMiLCJmaW5kTW91bnRzIiwicHVuY2hSYW5nZXMiLCJlbnRlckZyYWdtZW50cyIsInNsaWNlQnVmIiwiYnVmIiwibmV3U3RhY2siLCJpbm5lck9mZnNldCIsInN0YWNrUG9zIiwidGFyZ2V0SSIsIlN0cnVjdHVyZUN1cnNvciIsImN1clRvIiwiZnJhZ0kiLCJmaXJzdCIsImN1ckZyYWciLCJuZXh0RnJhZyIsIm91dGVyIiwiY3VycmVudCIsImdhcEZyb20iLCJnYXBUbyIsImZpbmRDb3ZlckNoYW5nZXMiLCJhIiwiaUEiLCJpQiIsImluQSIsImluQiIsIm5leHRBIiwibmV4dEIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/@lezer/common/dist/index.js\n");

/***/ }),

/***/ "../../node_modules/@lezer/highlight/dist/index.js":
/*!*********************************************************!*\
  !*** ../../node_modules/@lezer/highlight/dist/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Tag: () => (/* binding */ Tag),\n/* harmony export */   classHighlighter: () => (/* binding */ classHighlighter),\n/* harmony export */   getStyleTags: () => (/* binding */ getStyleTags),\n/* harmony export */   highlightCode: () => (/* binding */ highlightCode),\n/* harmony export */   highlightTree: () => (/* binding */ highlightTree),\n/* harmony export */   styleTags: () => (/* binding */ styleTags),\n/* harmony export */   tagHighlighter: () => (/* binding */ tagHighlighter),\n/* harmony export */   tags: () => (/* binding */ tags)\n/* harmony export */ });\n/* harmony import */ var _lezer_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @lezer/common */ \"../../node_modules/@lezer/common/dist/index.js\");\n\nlet nextTagID = 0;\n/**\nHighlighting tags are markers that denote a highlighting category.\nThey are [associated](#highlight.styleTags) with parts of a syntax\ntree by a language mode, and then mapped to an actual CSS style by\na [highlighter](#highlight.Highlighter).\n\nBecause syntax tree node types and highlight styles have to be\nable to talk the same language, CodeMirror uses a mostly _closed_\n[vocabulary](#highlight.tags) of syntax tags (as opposed to\ntraditional open string-based systems, which make it hard for\nhighlighting themes to cover all the tokens produced by the\nvarious languages).\n\nIt _is_ possible to [define](#highlight.Tag^define) your own\nhighlighting tags for system-internal use (where you control both\nthe language package and the highlighter), but such tags will not\nbe picked up by regular highlighters (though you can derive them\nfrom standard tags to allow highlighters to fall back to those).\n*/\nclass Tag {\n  /**\n  @internal\n  */\n  constructor(\n  /**\n  The set of this tag and all its parent tags, starting with\n  this one itself and sorted in order of decreasing specificity.\n  */\n  set,\n  /**\n  The base unmodified tag that this one is based on, if it's\n  modified @internal\n  */\n  base,\n  /**\n  The modifiers applied to this.base @internal\n  */\n  modified) {\n    this.set = set;\n    this.base = base;\n    this.modified = modified;\n    /**\n    @internal\n    */\n    this.id = nextTagID++;\n  }\n  /**\n  Define a new tag. If `parent` is given, the tag is treated as a\n  sub-tag of that parent, and\n  [highlighters](#highlight.tagHighlighter) that don't mention\n  this tag will try to fall back to the parent tag (or grandparent\n  tag, etc).\n  */\n  static define(parent) {\n    if (parent === null || parent === void 0 ? void 0 : parent.base) throw new Error(\"Can not derive from a modified tag\");\n    let tag = new Tag([], null, []);\n    tag.set.push(tag);\n    if (parent) for (let t of parent.set) tag.set.push(t);\n    return tag;\n  }\n  /**\n  Define a tag _modifier_, which is a function that, given a tag,\n  will return a tag that is a subtag of the original. Applying the\n  same modifier to a twice tag will return the same value (`m1(t1)\n  == m1(t1)`) and applying multiple modifiers will, regardless or\n  order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).\n  \n  When multiple modifiers are applied to a given base tag, each\n  smaller set of modifiers is registered as a parent, so that for\n  example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,\n  `m1(m3(t1)`, and so on.\n  */\n  static defineModifier() {\n    let mod = new Modifier();\n    return tag => {\n      if (tag.modified.indexOf(mod) > -1) return tag;\n      return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a, b) => a.id - b.id));\n    };\n  }\n}\nlet nextModifierID = 0;\nclass Modifier {\n  constructor() {\n    this.instances = [];\n    this.id = nextModifierID++;\n  }\n  static get(base, mods) {\n    if (!mods.length) return base;\n    let exists = mods[0].instances.find(t => t.base == base && sameArray(mods, t.modified));\n    if (exists) return exists;\n    let set = [],\n      tag = new Tag(set, base, mods);\n    for (let m of mods) m.instances.push(tag);\n    let configs = powerSet(mods);\n    for (let parent of base.set) if (!parent.modified.length) for (let config of configs) set.push(Modifier.get(parent, config));\n    return tag;\n  }\n}\nfunction sameArray(a, b) {\n  return a.length == b.length && a.every((x, i) => x == b[i]);\n}\nfunction powerSet(array) {\n  let sets = [[]];\n  for (let i = 0; i < array.length; i++) {\n    for (let j = 0, e = sets.length; j < e; j++) {\n      sets.push(sets[j].concat(array[i]));\n    }\n  }\n  return sets.sort((a, b) => b.length - a.length);\n}\n/**\nThis function is used to add a set of tags to a language syntax\nvia [`NodeSet.extend`](#common.NodeSet.extend) or\n[`LRParser.configure`](#lr.LRParser.configure).\n\nThe argument object maps node selectors to [highlighting\ntags](#highlight.Tag) or arrays of tags.\n\nNode selectors may hold one or more (space-separated) node paths.\nSuch a path can be a [node name](#common.NodeType.name), or\nmultiple node names (or `*` wildcards) separated by slash\ncharacters, as in `\"Block/Declaration/VariableName\"`. Such a path\nmatches the final node but only if its direct parent nodes are the\nother nodes mentioned. A `*` in such a path matches any parent,\nbut only a single level—wildcards that match multiple parents\naren't supported, both for efficiency reasons and because Lezer\ntrees make it rather hard to reason about what they would match.)\n\nA path can be ended with `/...` to indicate that the tag assigned\nto the node should also apply to all child nodes, even if they\nmatch their own style (by default, only the innermost style is\nused).\n\nWhen a path ends in `!`, as in `Attribute!`, no further matching\nhappens for the node's child nodes, and the entire node gets the\ngiven style.\n\nIn this notation, node names that contain `/`, `!`, `*`, or `...`\nmust be quoted as JSON strings.\n\nFor example:\n\n```javascript\nparser.withProps(\n  styleTags({\n    // Style Number and BigNumber nodes\n    \"Number BigNumber\": tags.number,\n    // Style Escape nodes whose parent is String\n    \"String/Escape\": tags.escape,\n    // Style anything inside Attributes nodes\n    \"Attributes!\": tags.meta,\n    // Add a style to all content inside Italic nodes\n    \"Italic/...\": tags.emphasis,\n    // Style InvalidString nodes as both `string` and `invalid`\n    \"InvalidString\": [tags.string, tags.invalid],\n    // Style the node named \"/\" as punctuation\n    '\"/\"': tags.punctuation\n  })\n)\n```\n*/\nfunction styleTags(spec) {\n  let byName = Object.create(null);\n  for (let prop in spec) {\n    let tags = spec[prop];\n    if (!Array.isArray(tags)) tags = [tags];\n    for (let part of prop.split(\" \")) if (part) {\n      let pieces = [],\n        mode = 2 /* Mode.Normal */,\n        rest = part;\n      for (let pos = 0;;) {\n        if (rest == \"...\" && pos > 0 && pos + 3 == part.length) {\n          mode = 1 /* Mode.Inherit */;\n          break;\n        }\n        let m = /^\"(?:[^\"\\\\]|\\\\.)*?\"|[^\\/!]+/.exec(rest);\n        if (!m) throw new RangeError(\"Invalid path: \" + part);\n        pieces.push(m[0] == \"*\" ? \"\" : m[0][0] == '\"' ? JSON.parse(m[0]) : m[0]);\n        pos += m[0].length;\n        if (pos == part.length) break;\n        let next = part[pos++];\n        if (pos == part.length && next == \"!\") {\n          mode = 0 /* Mode.Opaque */;\n          break;\n        }\n        if (next != \"/\") throw new RangeError(\"Invalid path: \" + part);\n        rest = part.slice(pos);\n      }\n      let last = pieces.length - 1,\n        inner = pieces[last];\n      if (!inner) throw new RangeError(\"Invalid path: \" + part);\n      let rule = new Rule(tags, mode, last > 0 ? pieces.slice(0, last) : null);\n      byName[inner] = rule.sort(byName[inner]);\n    }\n  }\n  return ruleNodeProp.add(byName);\n}\nconst ruleNodeProp = new _lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp();\nclass Rule {\n  constructor(tags, mode, context, next) {\n    this.tags = tags;\n    this.mode = mode;\n    this.context = context;\n    this.next = next;\n  }\n  get opaque() {\n    return this.mode == 0 /* Mode.Opaque */;\n  }\n  get inherit() {\n    return this.mode == 1 /* Mode.Inherit */;\n  }\n  sort(other) {\n    if (!other || other.depth < this.depth) {\n      this.next = other;\n      return this;\n    }\n    other.next = this.sort(other.next);\n    return other;\n  }\n  get depth() {\n    return this.context ? this.context.length : 0;\n  }\n}\nRule.empty = new Rule([], 2 /* Mode.Normal */, null);\n/**\nDefine a [highlighter](#highlight.Highlighter) from an array of\ntag/class pairs. Classes associated with more specific tags will\ntake precedence.\n*/\nfunction tagHighlighter(tags, options) {\n  let map = Object.create(null);\n  for (let style of tags) {\n    if (!Array.isArray(style.tag)) map[style.tag.id] = style.class;else for (let tag of style.tag) map[tag.id] = style.class;\n  }\n  let {\n    scope,\n    all = null\n  } = options || {};\n  return {\n    style: tags => {\n      let cls = all;\n      for (let tag of tags) {\n        for (let sub of tag.set) {\n          let tagClass = map[sub.id];\n          if (tagClass) {\n            cls = cls ? cls + \" \" + tagClass : tagClass;\n            break;\n          }\n        }\n      }\n      return cls;\n    },\n    scope\n  };\n}\nfunction highlightTags(highlighters, tags) {\n  let result = null;\n  for (let highlighter of highlighters) {\n    let value = highlighter.style(tags);\n    if (value) result = result ? result + \" \" + value : value;\n  }\n  return result;\n}\n/**\nHighlight the given [tree](#common.Tree) with the given\n[highlighter](#highlight.Highlighter). Often, the higher-level\n[`highlightCode`](#highlight.highlightCode) function is easier to\nuse.\n*/\nfunction highlightTree(tree, highlighter,\n/**\nAssign styling to a region of the text. Will be called, in order\nof position, for any ranges where more than zero classes apply.\n`classes` is a space separated string of CSS classes.\n*/\nputStyle,\n/**\nThe start of the range to highlight.\n*/\nfrom = 0,\n/**\nThe end of the range.\n*/\nto = tree.length) {\n  let builder = new HighlightBuilder(from, Array.isArray(highlighter) ? highlighter : [highlighter], putStyle);\n  builder.highlightRange(tree.cursor(), from, to, \"\", builder.highlighters);\n  builder.flush(to);\n}\n/**\nHighlight the given tree with the given highlighter, calling\n`putText` for every piece of text, either with a set of classes or\nwith the empty string when unstyled, and `putBreak` for every line\nbreak.\n*/\nfunction highlightCode(code, tree, highlighter, putText, putBreak, from = 0, to = code.length) {\n  let pos = from;\n  function writeTo(p, classes) {\n    if (p <= pos) return;\n    for (let text = code.slice(pos, p), i = 0;;) {\n      let nextBreak = text.indexOf(\"\\n\", i);\n      let upto = nextBreak < 0 ? text.length : nextBreak;\n      if (upto > i) putText(text.slice(i, upto), classes);\n      if (nextBreak < 0) break;\n      putBreak();\n      i = nextBreak + 1;\n    }\n    pos = p;\n  }\n  highlightTree(tree, highlighter, (from, to, classes) => {\n    writeTo(from, \"\");\n    writeTo(to, classes);\n  }, from, to);\n  writeTo(to, \"\");\n}\nclass HighlightBuilder {\n  constructor(at, highlighters, span) {\n    this.at = at;\n    this.highlighters = highlighters;\n    this.span = span;\n    this.class = \"\";\n  }\n  startSpan(at, cls) {\n    if (cls != this.class) {\n      this.flush(at);\n      if (at > this.at) this.at = at;\n      this.class = cls;\n    }\n  }\n  flush(to) {\n    if (to > this.at && this.class) this.span(this.at, to, this.class);\n  }\n  highlightRange(cursor, from, to, inheritedClass, highlighters) {\n    let {\n      type,\n      from: start,\n      to: end\n    } = cursor;\n    if (start >= to || end <= from) return;\n    if (type.isTop) highlighters = this.highlighters.filter(h => !h.scope || h.scope(type));\n    let cls = inheritedClass;\n    let rule = getStyleTags(cursor) || Rule.empty;\n    let tagCls = highlightTags(highlighters, rule.tags);\n    if (tagCls) {\n      if (cls) cls += \" \";\n      cls += tagCls;\n      if (rule.mode == 1 /* Mode.Inherit */) inheritedClass += (inheritedClass ? \" \" : \"\") + tagCls;\n    }\n    this.startSpan(Math.max(from, start), cls);\n    if (rule.opaque) return;\n    let mounted = cursor.tree && cursor.tree.prop(_lezer_common__WEBPACK_IMPORTED_MODULE_0__.NodeProp.mounted);\n    if (mounted && mounted.overlay) {\n      let inner = cursor.node.enter(mounted.overlay[0].from + start, 1);\n      let innerHighlighters = this.highlighters.filter(h => !h.scope || h.scope(mounted.tree.type));\n      let hasChild = cursor.firstChild();\n      for (let i = 0, pos = start;; i++) {\n        let next = i < mounted.overlay.length ? mounted.overlay[i] : null;\n        let nextPos = next ? next.from + start : end;\n        let rangeFrom = Math.max(from, pos),\n          rangeTo = Math.min(to, nextPos);\n        if (rangeFrom < rangeTo && hasChild) {\n          while (cursor.from < rangeTo) {\n            this.highlightRange(cursor, rangeFrom, rangeTo, inheritedClass, highlighters);\n            this.startSpan(Math.min(rangeTo, cursor.to), cls);\n            if (cursor.to >= nextPos || !cursor.nextSibling()) break;\n          }\n        }\n        if (!next || nextPos > to) break;\n        pos = next.to + start;\n        if (pos > from) {\n          this.highlightRange(inner.cursor(), Math.max(from, next.from + start), Math.min(to, pos), \"\", innerHighlighters);\n          this.startSpan(Math.min(to, pos), cls);\n        }\n      }\n      if (hasChild) cursor.parent();\n    } else if (cursor.firstChild()) {\n      if (mounted) inheritedClass = \"\";\n      do {\n        if (cursor.to <= from) continue;\n        if (cursor.from >= to) break;\n        this.highlightRange(cursor, from, to, inheritedClass, highlighters);\n        this.startSpan(Math.min(to, cursor.to), cls);\n      } while (cursor.nextSibling());\n      cursor.parent();\n    }\n  }\n}\n/**\nMatch a syntax node's [highlight rules](#highlight.styleTags). If\nthere's a match, return its set of tags, and whether it is\nopaque (uses a `!`) or applies to all child nodes (`/...`).\n*/\nfunction getStyleTags(node) {\n  let rule = node.type.prop(ruleNodeProp);\n  while (rule && rule.context && !node.matchContext(rule.context)) rule = rule.next;\n  return rule || null;\n}\nconst t = Tag.define;\nconst comment = t(),\n  name = t(),\n  typeName = t(name),\n  propertyName = t(name),\n  literal = t(),\n  string = t(literal),\n  number = t(literal),\n  content = t(),\n  heading = t(content),\n  keyword = t(),\n  operator = t(),\n  punctuation = t(),\n  bracket = t(punctuation),\n  meta = t();\n/**\nThe default set of highlighting [tags](#highlight.Tag).\n\nThis collection is heavily biased towards programming languages,\nand necessarily incomplete. A full ontology of syntactic\nconstructs would fill a stack of books, and be impractical to\nwrite themes for. So try to make do with this set. If all else\nfails, [open an\nissue](https://github.com/codemirror/codemirror.next) to propose a\nnew tag, or [define](#highlight.Tag^define) a local custom tag for\nyour use case.\n\nNote that it is not obligatory to always attach the most specific\ntag possible to an element—if your grammar can't easily\ndistinguish a certain type of element (such as a local variable),\nit is okay to style it as its more general variant (a variable).\n\nFor tags that extend some parent tag, the documentation links to\nthe parent.\n*/\nconst tags = {\n  /**\n  A comment.\n  */\n  comment,\n  /**\n  A line [comment](#highlight.tags.comment).\n  */\n  lineComment: t(comment),\n  /**\n  A block [comment](#highlight.tags.comment).\n  */\n  blockComment: t(comment),\n  /**\n  A documentation [comment](#highlight.tags.comment).\n  */\n  docComment: t(comment),\n  /**\n  Any kind of identifier.\n  */\n  name,\n  /**\n  The [name](#highlight.tags.name) of a variable.\n  */\n  variableName: t(name),\n  /**\n  A type [name](#highlight.tags.name).\n  */\n  typeName: typeName,\n  /**\n  A tag name (subtag of [`typeName`](#highlight.tags.typeName)).\n  */\n  tagName: t(typeName),\n  /**\n  A property or field [name](#highlight.tags.name).\n  */\n  propertyName: propertyName,\n  /**\n  An attribute name (subtag of [`propertyName`](#highlight.tags.propertyName)).\n  */\n  attributeName: t(propertyName),\n  /**\n  The [name](#highlight.tags.name) of a class.\n  */\n  className: t(name),\n  /**\n  A label [name](#highlight.tags.name).\n  */\n  labelName: t(name),\n  /**\n  A namespace [name](#highlight.tags.name).\n  */\n  namespace: t(name),\n  /**\n  The [name](#highlight.tags.name) of a macro.\n  */\n  macroName: t(name),\n  /**\n  A literal value.\n  */\n  literal,\n  /**\n  A string [literal](#highlight.tags.literal).\n  */\n  string,\n  /**\n  A documentation [string](#highlight.tags.string).\n  */\n  docString: t(string),\n  /**\n  A character literal (subtag of [string](#highlight.tags.string)).\n  */\n  character: t(string),\n  /**\n  An attribute value (subtag of [string](#highlight.tags.string)).\n  */\n  attributeValue: t(string),\n  /**\n  A number [literal](#highlight.tags.literal).\n  */\n  number,\n  /**\n  An integer [number](#highlight.tags.number) literal.\n  */\n  integer: t(number),\n  /**\n  A floating-point [number](#highlight.tags.number) literal.\n  */\n  float: t(number),\n  /**\n  A boolean [literal](#highlight.tags.literal).\n  */\n  bool: t(literal),\n  /**\n  Regular expression [literal](#highlight.tags.literal).\n  */\n  regexp: t(literal),\n  /**\n  An escape [literal](#highlight.tags.literal), for example a\n  backslash escape in a string.\n  */\n  escape: t(literal),\n  /**\n  A color [literal](#highlight.tags.literal).\n  */\n  color: t(literal),\n  /**\n  A URL [literal](#highlight.tags.literal).\n  */\n  url: t(literal),\n  /**\n  A language keyword.\n  */\n  keyword,\n  /**\n  The [keyword](#highlight.tags.keyword) for the self or this\n  object.\n  */\n  self: t(keyword),\n  /**\n  The [keyword](#highlight.tags.keyword) for null.\n  */\n  null: t(keyword),\n  /**\n  A [keyword](#highlight.tags.keyword) denoting some atomic value.\n  */\n  atom: t(keyword),\n  /**\n  A [keyword](#highlight.tags.keyword) that represents a unit.\n  */\n  unit: t(keyword),\n  /**\n  A modifier [keyword](#highlight.tags.keyword).\n  */\n  modifier: t(keyword),\n  /**\n  A [keyword](#highlight.tags.keyword) that acts as an operator.\n  */\n  operatorKeyword: t(keyword),\n  /**\n  A control-flow related [keyword](#highlight.tags.keyword).\n  */\n  controlKeyword: t(keyword),\n  /**\n  A [keyword](#highlight.tags.keyword) that defines something.\n  */\n  definitionKeyword: t(keyword),\n  /**\n  A [keyword](#highlight.tags.keyword) related to defining or\n  interfacing with modules.\n  */\n  moduleKeyword: t(keyword),\n  /**\n  An operator.\n  */\n  operator,\n  /**\n  An [operator](#highlight.tags.operator) that dereferences something.\n  */\n  derefOperator: t(operator),\n  /**\n  Arithmetic-related [operator](#highlight.tags.operator).\n  */\n  arithmeticOperator: t(operator),\n  /**\n  Logical [operator](#highlight.tags.operator).\n  */\n  logicOperator: t(operator),\n  /**\n  Bit [operator](#highlight.tags.operator).\n  */\n  bitwiseOperator: t(operator),\n  /**\n  Comparison [operator](#highlight.tags.operator).\n  */\n  compareOperator: t(operator),\n  /**\n  [Operator](#highlight.tags.operator) that updates its operand.\n  */\n  updateOperator: t(operator),\n  /**\n  [Operator](#highlight.tags.operator) that defines something.\n  */\n  definitionOperator: t(operator),\n  /**\n  Type-related [operator](#highlight.tags.operator).\n  */\n  typeOperator: t(operator),\n  /**\n  Control-flow [operator](#highlight.tags.operator).\n  */\n  controlOperator: t(operator),\n  /**\n  Program or markup punctuation.\n  */\n  punctuation,\n  /**\n  [Punctuation](#highlight.tags.punctuation) that separates\n  things.\n  */\n  separator: t(punctuation),\n  /**\n  Bracket-style [punctuation](#highlight.tags.punctuation).\n  */\n  bracket,\n  /**\n  Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`\n  tokens).\n  */\n  angleBracket: t(bracket),\n  /**\n  Square [brackets](#highlight.tags.bracket) (usually `[` and `]`\n  tokens).\n  */\n  squareBracket: t(bracket),\n  /**\n  Parentheses (usually `(` and `)` tokens). Subtag of\n  [bracket](#highlight.tags.bracket).\n  */\n  paren: t(bracket),\n  /**\n  Braces (usually `{` and `}` tokens). Subtag of\n  [bracket](#highlight.tags.bracket).\n  */\n  brace: t(bracket),\n  /**\n  Content, for example plain text in XML or markup documents.\n  */\n  content,\n  /**\n  [Content](#highlight.tags.content) that represents a heading.\n  */\n  heading,\n  /**\n  A level 1 [heading](#highlight.tags.heading).\n  */\n  heading1: t(heading),\n  /**\n  A level 2 [heading](#highlight.tags.heading).\n  */\n  heading2: t(heading),\n  /**\n  A level 3 [heading](#highlight.tags.heading).\n  */\n  heading3: t(heading),\n  /**\n  A level 4 [heading](#highlight.tags.heading).\n  */\n  heading4: t(heading),\n  /**\n  A level 5 [heading](#highlight.tags.heading).\n  */\n  heading5: t(heading),\n  /**\n  A level 6 [heading](#highlight.tags.heading).\n  */\n  heading6: t(heading),\n  /**\n  A prose separator (such as a horizontal rule).\n  */\n  contentSeparator: t(content),\n  /**\n  [Content](#highlight.tags.content) that represents a list.\n  */\n  list: t(content),\n  /**\n  [Content](#highlight.tags.content) that represents a quote.\n  */\n  quote: t(content),\n  /**\n  [Content](#highlight.tags.content) that is emphasized.\n  */\n  emphasis: t(content),\n  /**\n  [Content](#highlight.tags.content) that is styled strong.\n  */\n  strong: t(content),\n  /**\n  [Content](#highlight.tags.content) that is part of a link.\n  */\n  link: t(content),\n  /**\n  [Content](#highlight.tags.content) that is styled as code or\n  monospace.\n  */\n  monospace: t(content),\n  /**\n  [Content](#highlight.tags.content) that has a strike-through\n  style.\n  */\n  strikethrough: t(content),\n  /**\n  Inserted text in a change-tracking format.\n  */\n  inserted: t(),\n  /**\n  Deleted text.\n  */\n  deleted: t(),\n  /**\n  Changed text.\n  */\n  changed: t(),\n  /**\n  An invalid or unsyntactic element.\n  */\n  invalid: t(),\n  /**\n  Metadata or meta-instruction.\n  */\n  meta,\n  /**\n  [Metadata](#highlight.tags.meta) that applies to the entire\n  document.\n  */\n  documentMeta: t(meta),\n  /**\n  [Metadata](#highlight.tags.meta) that annotates or adds\n  attributes to a given syntactic element.\n  */\n  annotation: t(meta),\n  /**\n  Processing instruction or preprocessor directive. Subtag of\n  [meta](#highlight.tags.meta).\n  */\n  processingInstruction: t(meta),\n  /**\n  [Modifier](#highlight.Tag^defineModifier) that indicates that a\n  given element is being defined. Expected to be used with the\n  various [name](#highlight.tags.name) tags.\n  */\n  definition: Tag.defineModifier(),\n  /**\n  [Modifier](#highlight.Tag^defineModifier) that indicates that\n  something is constant. Mostly expected to be used with\n  [variable names](#highlight.tags.variableName).\n  */\n  constant: Tag.defineModifier(),\n  /**\n  [Modifier](#highlight.Tag^defineModifier) used to indicate that\n  a [variable](#highlight.tags.variableName) or [property\n  name](#highlight.tags.propertyName) is being called or defined\n  as a function.\n  */\n  function: Tag.defineModifier(),\n  /**\n  [Modifier](#highlight.Tag^defineModifier) that can be applied to\n  [names](#highlight.tags.name) to indicate that they belong to\n  the language's standard environment.\n  */\n  standard: Tag.defineModifier(),\n  /**\n  [Modifier](#highlight.Tag^defineModifier) that indicates a given\n  [names](#highlight.tags.name) is local to some scope.\n  */\n  local: Tag.defineModifier(),\n  /**\n  A generic variant [modifier](#highlight.Tag^defineModifier) that\n  can be used to tag language-specific alternative variants of\n  some common tag. It is recommended for themes to define special\n  forms of at least the [string](#highlight.tags.string) and\n  [variable name](#highlight.tags.variableName) tags, since those\n  come up a lot.\n  */\n  special: Tag.defineModifier()\n};\n/**\nThis is a highlighter that adds stable, predictable classes to\ntokens, for styling with external CSS.\n\nThe following tags are mapped to their name prefixed with `\"tok-\"`\n(for example `\"tok-comment\"`):\n\n* [`link`](#highlight.tags.link)\n* [`heading`](#highlight.tags.heading)\n* [`emphasis`](#highlight.tags.emphasis)\n* [`strong`](#highlight.tags.strong)\n* [`keyword`](#highlight.tags.keyword)\n* [`atom`](#highlight.tags.atom)\n* [`bool`](#highlight.tags.bool)\n* [`url`](#highlight.tags.url)\n* [`labelName`](#highlight.tags.labelName)\n* [`inserted`](#highlight.tags.inserted)\n* [`deleted`](#highlight.tags.deleted)\n* [`literal`](#highlight.tags.literal)\n* [`string`](#highlight.tags.string)\n* [`number`](#highlight.tags.number)\n* [`variableName`](#highlight.tags.variableName)\n* [`typeName`](#highlight.tags.typeName)\n* [`namespace`](#highlight.tags.namespace)\n* [`className`](#highlight.tags.className)\n* [`macroName`](#highlight.tags.macroName)\n* [`propertyName`](#highlight.tags.propertyName)\n* [`operator`](#highlight.tags.operator)\n* [`comment`](#highlight.tags.comment)\n* [`meta`](#highlight.tags.meta)\n* [`punctuation`](#highlight.tags.punctuation)\n* [`invalid`](#highlight.tags.invalid)\n\nIn addition, these mappings are provided:\n\n* [`regexp`](#highlight.tags.regexp),\n  [`escape`](#highlight.tags.escape), and\n  [`special`](#highlight.tags.special)[`(string)`](#highlight.tags.string)\n  are mapped to `\"tok-string2\"`\n* [`special`](#highlight.tags.special)[`(variableName)`](#highlight.tags.variableName)\n  to `\"tok-variableName2\"`\n* [`local`](#highlight.tags.local)[`(variableName)`](#highlight.tags.variableName)\n  to `\"tok-variableName tok-local\"`\n* [`definition`](#highlight.tags.definition)[`(variableName)`](#highlight.tags.variableName)\n  to `\"tok-variableName tok-definition\"`\n* [`definition`](#highlight.tags.definition)[`(propertyName)`](#highlight.tags.propertyName)\n  to `\"tok-propertyName tok-definition\"`\n*/\nconst classHighlighter = tagHighlighter([{\n  tag: tags.link,\n  class: \"tok-link\"\n}, {\n  tag: tags.heading,\n  class: \"tok-heading\"\n}, {\n  tag: tags.emphasis,\n  class: \"tok-emphasis\"\n}, {\n  tag: tags.strong,\n  class: \"tok-strong\"\n}, {\n  tag: tags.keyword,\n  class: \"tok-keyword\"\n}, {\n  tag: tags.atom,\n  class: \"tok-atom\"\n}, {\n  tag: tags.bool,\n  class: \"tok-bool\"\n}, {\n  tag: tags.url,\n  class: \"tok-url\"\n}, {\n  tag: tags.labelName,\n  class: \"tok-labelName\"\n}, {\n  tag: tags.inserted,\n  class: \"tok-inserted\"\n}, {\n  tag: tags.deleted,\n  class: \"tok-deleted\"\n}, {\n  tag: tags.literal,\n  class: \"tok-literal\"\n}, {\n  tag: tags.string,\n  class: \"tok-string\"\n}, {\n  tag: tags.number,\n  class: \"tok-number\"\n}, {\n  tag: [tags.regexp, tags.escape, tags.special(tags.string)],\n  class: \"tok-string2\"\n}, {\n  tag: tags.variableName,\n  class: \"tok-variableName\"\n}, {\n  tag: tags.local(tags.variableName),\n  class: \"tok-variableName tok-local\"\n}, {\n  tag: tags.definition(tags.variableName),\n  class: \"tok-variableName tok-definition\"\n}, {\n  tag: tags.special(tags.variableName),\n  class: \"tok-variableName2\"\n}, {\n  tag: tags.definition(tags.propertyName),\n  class: \"tok-propertyName tok-definition\"\n}, {\n  tag: tags.typeName,\n  class: \"tok-typeName\"\n}, {\n  tag: tags.namespace,\n  class: \"tok-namespace\"\n}, {\n  tag: tags.className,\n  class: \"tok-className\"\n}, {\n  tag: tags.macroName,\n  class: \"tok-macroName\"\n}, {\n  tag: tags.propertyName,\n  class: \"tok-propertyName\"\n}, {\n  tag: tags.operator,\n  class: \"tok-operator\"\n}, {\n  tag: tags.comment,\n  class: \"tok-comment\"\n}, {\n  tag: tags.meta,\n  class: \"tok-meta\"\n}, {\n  tag: tags.invalid,\n  class: \"tok-invalid\"\n}, {\n  tag: tags.punctuation,\n  class: \"tok-punctuation\"\n}]);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL0BsZXplci9oaWdobGlnaHQvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBeUM7QUFFekMsSUFBSUMsU0FBUyxHQUFHLENBQUM7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNQyxHQUFHLENBQUM7RUFDTjtBQUNKO0FBQ0E7RUFDSUMsV0FBV0E7RUFDWDtBQUNKO0FBQ0E7QUFDQTtFQUNJQyxHQUFHO0VBQ0g7QUFDSjtBQUNBO0FBQ0E7RUFDSUMsSUFBSTtFQUNKO0FBQ0o7QUFDQTtFQUNJQyxRQUFRLEVBQUU7SUFDTixJQUFJLENBQUNGLEdBQUcsR0FBR0EsR0FBRztJQUNkLElBQUksQ0FBQ0MsSUFBSSxHQUFHQSxJQUFJO0lBQ2hCLElBQUksQ0FBQ0MsUUFBUSxHQUFHQSxRQUFRO0lBQ3hCO0FBQ1I7QUFDQTtJQUNRLElBQUksQ0FBQ0MsRUFBRSxHQUFHTixTQUFTLEVBQUU7RUFDekI7RUFDQTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtFQUNJLE9BQU9PLE1BQU1BLENBQUNDLE1BQU0sRUFBRTtJQUNsQixJQUFJQSxNQUFNLEtBQUssSUFBSSxJQUFJQSxNQUFNLEtBQUssS0FBSyxDQUFDLEdBQUcsS0FBSyxDQUFDLEdBQUdBLE1BQU0sQ0FBQ0osSUFBSSxFQUMzRCxNQUFNLElBQUlLLEtBQUssQ0FBQyxvQ0FBb0MsQ0FBQztJQUN6RCxJQUFJQyxHQUFHLEdBQUcsSUFBSVQsR0FBRyxDQUFDLEVBQUUsRUFBRSxJQUFJLEVBQUUsRUFBRSxDQUFDO0lBQy9CUyxHQUFHLENBQUNQLEdBQUcsQ0FBQ1EsSUFBSSxDQUFDRCxHQUFHLENBQUM7SUFDakIsSUFBSUYsTUFBTSxFQUNOLEtBQUssSUFBSUksQ0FBQyxJQUFJSixNQUFNLENBQUNMLEdBQUcsRUFD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SSxDQUFDZ0gsU0FBUztFQUFFakYsS0FBSyxFQUFFO0FBQWdCLENBQUMsRUFDL0M7RUFBRW5FLEdBQUcsRUFBRW9DLElBQUksQ0FBQzRGLFlBQVk7RUFBRTdELEtBQUssRUFBRTtBQUFtQixDQUFDLEVBQ3JEO0VBQUVuRSxHQUFHLEVBQUVvQyxJQUFJLENBQUNtRyxRQUFRO0VBQUVwRSxLQUFLLEVBQUU7QUFBZSxDQUFDLEVBQzdDO0VBQUVuRSxHQUFHLEVBQUVvQyxJQUFJLENBQUN5RixPQUFPO0VBQUUxRCxLQUFLLEVBQUU7QUFBYyxDQUFDLEVBQzNDO0VBQUVuRSxHQUFHLEVBQUVvQyxJQUFJLENBQUNzRyxJQUFJO0VBQUV2RSxLQUFLLEVBQUU7QUFBVyxDQUFDLEVBQ3JDO0VBQUVuRSxHQUFHLEVBQUVvQyxJQUFJLENBQUNtSyxPQUFPO0VBQUVwSSxLQUFLLEVBQUU7QUFBYyxDQUFDLEVBQzNDO0VBQUVuRSxHQUFHLEVBQUVvQyxJQUFJLENBQUNvRyxXQUFXO0VBQUVyRSxLQUFLLEVBQUU7QUFBa0IsQ0FBQyxDQUN0RCxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmlkZ2UtY29kZW1pcnJvci8uLi8uLi9ub2RlX21vZHVsZXMvQGxlemVyL2hpZ2hsaWdodC9kaXN0L2luZGV4LmpzPzc3MWYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTm9kZVByb3AgfSBmcm9tICdAbGV6ZXIvY29tbW9uJztcblxubGV0IG5leHRUYWdJRCA9IDA7XG4vKipcbkhpZ2hsaWdodGluZyB0YWdzIGFyZSBtYXJrZXJzIHRoYXQgZGVub3RlIGEgaGlnaGxpZ2h0aW5nIGNhdGVnb3J5LlxuVGhleSBhcmUgW2Fzc29jaWF0ZWRdKCNoaWdobGlnaHQuc3R5bGVUYWdzKSB3aXRoIHBhcnRzIG9mIGEgc3ludGF4XG50cmVlIGJ5IGEgbGFuZ3VhZ2UgbW9kZSwgYW5kIHRoZW4gbWFwcGVkIHRvIGFuIGFjdHVhbCBDU1Mgc3R5bGUgYnlcbmEgW2hpZ2hsaWdodGVyXSgjaGlnaGxpZ2h0LkhpZ2hsaWdodGVyKS5cblxuQmVjYXVzZSBzeW50YXggdHJlZSBub2RlIHR5cGVzIGFuZCBoaWdobGlnaHQgc3R5bGVzIGhhdmUgdG8gYmVcbmFibGUgdG8gdGFsayB0aGUgc2FtZSBsYW5ndWFnZSwgQ29kZU1pcnJvciB1c2VzIGEgbW9zdGx5IF9jbG9zZWRfXG5bdm9jYWJ1bGFyeV0oI2hpZ2hsaWdodC50YWdzKSBvZiBzeW50YXggdGFncyAoYXMgb3Bwb3NlZCB0b1xudHJhZGl0aW9uYWwgb3BlbiBzdHJpbmctYmFzZWQgc3lzdGVtcywgd2hpY2ggbWFrZSBpdCBoYXJkIGZvclxuaGlnaGxpZ2h0aW5nIHRoZW1lcyB0byBjb3ZlciBhbGwgdGhlIHRva2VucyBwcm9kdWNlZCBieSB0aGVcbnZhcmlvdXMgbGFuZ3VhZ2VzKS5cblxuSXQgX2lzXyBwb3NzaWJsZSB0byBbZGVmaW5lXSgjaGlnaGxpZ2h0LlRhZ15kZWZpbmUpIHlvdXIgb3duXG5oaWdobGlnaHRpbmcgdGFncyBmb3Igc3lzdGVtLWludGVybmFsIHVzZSAod2hlcmUgeW91IGNvbnRyb2wgYm90aFxudGhlIGxhbmd1YWdlIHBhY2thZ2UgYW5kIHRoZSBoaWdobGlnaHRlciksIGJ1dCBzdWNoIHRhZ3Mgd2lsbCBub3RcbmJlIHBpY2tlZCB1cCBieSByZWd1bGFyIGhpZ2hsaWdodGVycyAodGhvdWdoIHlvdSBjYW4gZGVyaXZlIHRoZW1cbmZyb20gc3RhbmRhcmQgdGFncyB0byBhbGxvdyBoaWdobGlnaHRlcnMgdG8gZmFsbCBiYWNrIHRvIHRob3NlKS5cbiovXG5jbGFzcyBUYWcge1xuICAgIC8qKlxuICAgIEBpbnRlcm5hbFxuICAgICovXG4gICAgY29uc3RydWN0b3IoXG4gICAgLyoqXG4gICAgVGhlIHNldCBvZiB0aGlzIHRhZyBhbmQgYWxsIGl0cyBwYXJlbnQgdGFncywgc3RhcnRpbmcgd2l0aFxuICAgIHRoaXMgb25lIGl0c2VsZiBhbmQgc29ydGVkIGluIG9yZGVyIG9mIGRlY3JlYXNpbmcgc3BlY2lmaWNpdHkuXG4gICAgKi9cbiAgICBzZXQsIFxuICAgIC8qKlxuICAgIFRoZSBiYXNlIHVubW9kaWZpZWQgdGFnIHRoYXQgdGhpcyBvbmUgaXMgYmFzZWQgb24sIGlmIGl0J3NcbiAgICBtb2RpZmllZCBAaW50ZXJuYWxcbiAgICAqL1xuICAgIGJhc2UsIFxuICAgIC8qKlxuICAgIFRoZSBtb2RpZmllcnMgYXBwbGllZCB0byB0aGlzLmJhc2UgQGludGVybmFsXG4gICAgKi9cbiAgICBtb2RpZmllZCkge1xuICAgICAgICB0aGlzLnNldCA9IHNldDtcbiAgICAgICAgdGhpcy5iYXNlID0gYmFzZTtcbiAgICAgICAgdGhpcy5tb2RpZmllZCA9IG1vZGlmaWVkO1xuICAgICAgICAvKipcbiAgICAgICAgQGludGVybmFsXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuaWQgPSBuZXh0VGFnSUQrKztcbiAgICB9XG4gICAgLyoqXG4gICAgRGVmaW5lIGEgbmV3IHRhZy4gSWYgYHBhcmVudGAgaXMgZ2l2ZW4sIHRoZSB0YWcgaXMgdHJlYXRlZCBhcyBhXG4gICAgc3ViLXRhZyBvZiB0aGF0IHBhcmVudCwgYW5kXG4gICAgW2hpZ2hsaWdodGVyc10oI2hpZ2hsaWdodC50YWdIaWdobGlnaHRlcikgdGhhdCBkb24ndCBtZW50aW9uXG4gICAgdGhpcyB0YWcgd2lsbCB0cnkgdG8gZmFsbCBiYWNrIHRvIHRoZSBwYXJlbnQgdGFnIChvciBncmFuZHBhcmVudFxuICAgIHRhZywgZXRjKS5cbiAgICAqL1xuICAgIHN0YXRpYyBkZWZpbmUocGFyZW50KSB7XG4gICAgICAgIGlmIChwYXJlbnQgPT09IG51bGwgfHwgcGFyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJlbnQuYmFzZSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbiBub3QgZGVyaXZlIGZyb20gYSBtb2RpZmllZCB0YWdcIik7XG4gICAgICAgIGxldCB0YWcgPSBuZXcgVGFnKFtdLCBudWxsLCBbXSk7XG4gICAgICAgIHRhZy5zZXQucHVzaCh0YWcpO1xuICAgICAgICBpZiAocGFyZW50KVxuICAgICAgICAgICAgZm9yIChsZXQgdCBvZiBwYXJlbnQuc2V0KVxuICAgICAgICAgICAgICAgIHRhZy5zZXQucHVzaCh0KTtcbiAgICAgICAgcmV0dXJuIHRhZztcbiAgICB9XG4gICAgLyoqXG4gICAgRGVmaW5lIGEgdGFnIF9tb2RpZmllcl8sIHdoaWNoIGlzIGEgZnVuY3Rpb24gdGhhdCwgZ2l2ZW4gYSB0YWcsXG4gICAgd2lsbCByZXR1cm4gYSB0YWcgdGhhdCBpcyBhIHN1YnRhZyBvZiB0aGUgb3JpZ2luYWwuIEFwcGx5aW5nIHRoZVxuICAgIHNhbWUgbW9kaWZpZXIgdG8gYSB0d2ljZSB0YWcgd2lsbCByZXR1cm4gdGhlIHNhbWUgdmFsdWUgKGBtMSh0MSlcbiAgICA9PSBtMSh0MSlgKSBhbmQgYXBwbHlpbmcgbXVsdGlwbGUgbW9kaWZpZXJzIHdpbGwsIHJlZ2FyZGxlc3Mgb3JcbiAgICBvcmRlciwgcHJvZHVjZSB0aGUgc2FtZSB0YWcgKGBtMShtMih0MSkpID09IG0yKG0xKHQxKSlgKS5cbiAgICBcbiAgICBXaGVuIG11bHRpcGxlIG1vZGlmaWVycyBhcmUgYXBwbGllZCB0byBhIGdpdmVuIGJhc2UgdGFnLCBlYWNoXG4gICAgc21hbGxlciBzZXQgb2YgbW9kaWZpZXJzIGlzIHJlZ2lzdGVyZWQgYXMgYSBwYXJlbnQsIHNvIHRoYXQgZm9yXG4gICAgZXhhbXBsZSBgbTEobTIobTModDEpKSlgIGlzIGEgc3VidHlwZSBvZiBgbTEobTIodDEpKWAsXG4gICAgYG0xKG0zKHQxKWAsIGFuZCBzbyBvbi5cbiAgICAqL1xuICAgIHN0YXRpYyBkZWZpbmVNb2RpZmllcigpIHtcbiAgICAgICAgbGV0IG1vZCA9IG5ldyBNb2RpZmllcjtcbiAgICAgICAgcmV0dXJuICh0YWcpID0+IHtcbiAgICAgICAgICAgIGlmICh0YWcubW9kaWZpZWQuaW5kZXhPZihtb2QpID4gLTEpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhZztcbiAgICAgICAgICAgIHJldHVybiBNb2RpZmllci5nZXQodGFnLmJhc2UgfHwgdGFnLCB0YWcubW9kaWZpZWQuY29uY2F0KG1vZCkuc29ydCgoYSwgYikgPT4gYS5pZCAtIGIuaWQpKTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5sZXQgbmV4dE1vZGlmaWVySUQgPSAwO1xuY2xhc3MgTW9kaWZpZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmluc3RhbmNlcyA9IFtdO1xuICAgICAgICB0aGlzLmlkID0gbmV4dE1vZGlmaWVySUQrKztcbiAgICB9XG4gICAgc3RhdGljIGdldChiYXNlLCBtb2RzKSB7XG4gICAgICAgIGlmICghbW9kcy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gYmFzZTtcbiAgICAgICAgbGV0IGV4aXN0cyA9IG1vZHNbMF0uaW5zdGFuY2VzLmZpbmQodCA9PiB0LmJhc2UgPT0gYmFzZSAmJiBzYW1lQXJyYXkobW9kcywgdC5tb2RpZmllZCkpO1xuICAgICAgICBpZiAoZXhpc3RzKVxuICAgICAgICAgICAgcmV0dXJuIGV4aXN0cztcbiAgICAgICAgbGV0IHNldCA9IFtdLCB0YWcgPSBuZXcgVGFnKHNldCwgYmFzZSwgbW9kcyk7XG4gICAgICAgIGZvciAobGV0IG0gb2YgbW9kcylcbiAgICAgICAgICAgIG0uaW5zdGFuY2VzLnB1c2godGFnKTtcbiAgICAgICAgbGV0IGNvbmZpZ3MgPSBwb3dlclNldChtb2RzKTtcbiAgICAgICAgZm9yIChsZXQgcGFyZW50IG9mIGJhc2Uuc2V0KVxuICAgICAgICAgICAgaWYgKCFwYXJlbnQubW9kaWZpZWQubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGNvbmZpZyBvZiBjb25maWdzKVxuICAgICAgICAgICAgICAgICAgICBzZXQucHVzaChNb2RpZmllci5nZXQocGFyZW50LCBjb25maWcpKTtcbiAgICAgICAgcmV0dXJuIHRhZztcbiAgICB9XG59XG5mdW5jdGlvbiBzYW1lQXJyYXkoYSwgYikge1xuICAgIHJldHVybiBhLmxlbmd0aCA9PSBiLmxlbmd0aCAmJiBhLmV2ZXJ5KCh4LCBpKSA9PiB4ID09IGJbaV0pO1xufVxuZnVuY3Rpb24gcG93ZXJTZXQoYXJyYXkpIHtcbiAgICBsZXQgc2V0cyA9IFtbXV07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBmb3IgKGxldCBqID0gMCwgZSA9IHNldHMubGVuZ3RoOyBqIDwgZTsgaisrKSB7XG4gICAgICAgICAgICBzZXRzLnB1c2goc2V0c1tqXS5jb25jYXQoYXJyYXlbaV0pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2V0cy5zb3J0KChhLCBiKSA9PiBiLmxlbmd0aCAtIGEubGVuZ3RoKTtcbn1cbi8qKlxuVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIGFkZCBhIHNldCBvZiB0YWdzIHRvIGEgbGFuZ3VhZ2Ugc3ludGF4XG52aWEgW2BOb2RlU2V0LmV4dGVuZGBdKCNjb21tb24uTm9kZVNldC5leHRlbmQpIG9yXG5bYExSUGFyc2VyLmNvbmZpZ3VyZWBdKCNsci5MUlBhcnNlci5jb25maWd1cmUpLlxuXG5UaGUgYXJndW1lbnQgb2JqZWN0IG1hcHMgbm9kZSBzZWxlY3RvcnMgdG8gW2hpZ2hsaWdodGluZ1xudGFnc10oI2hpZ2hsaWdodC5UYWcpIG9yIGFycmF5cyBvZiB0YWdzLlxuXG5Ob2RlIHNlbGVjdG9ycyBtYXkgaG9sZCBvbmUgb3IgbW9yZSAoc3BhY2Utc2VwYXJhdGVkKSBub2RlIHBhdGhzLlxuU3VjaCBhIHBhdGggY2FuIGJlIGEgW25vZGUgbmFtZV0oI2NvbW1vbi5Ob2RlVHlwZS5uYW1lKSwgb3Jcbm11bHRpcGxlIG5vZGUgbmFtZXMgKG9yIGAqYCB3aWxkY2FyZHMpIHNlcGFyYXRlZCBieSBzbGFzaFxuY2hhcmFjdGVycywgYXMgaW4gYFwiQmxvY2svRGVjbGFyYXRpb24vVmFyaWFibGVOYW1lXCJgLiBTdWNoIGEgcGF0aFxubWF0Y2hlcyB0aGUgZmluYWwgbm9kZSBidXQgb25seSBpZiBpdHMgZGlyZWN0IHBhcmVudCBub2RlcyBhcmUgdGhlXG5vdGhlciBub2RlcyBtZW50aW9uZWQuIEEgYCpgIGluIHN1Y2ggYSBwYXRoIG1hdGNoZXMgYW55IHBhcmVudCxcbmJ1dCBvbmx5IGEgc2luZ2xlIGxldmVs4oCUd2lsZGNhcmRzIHRoYXQgbWF0Y2ggbXVsdGlwbGUgcGFyZW50c1xuYXJlbid0IHN1cHBvcnRlZCwgYm90aCBmb3IgZWZmaWNpZW5jeSByZWFzb25zIGFuZCBiZWNhdXNlIExlemVyXG50cmVlcyBtYWtlIGl0IHJhdGhlciBoYXJkIHRvIHJlYXNvbiBhYm91dCB3aGF0IHRoZXkgd291bGQgbWF0Y2guKVxuXG5BIHBhdGggY2FuIGJlIGVuZGVkIHdpdGggYC8uLi5gIHRvIGluZGljYXRlIHRoYXQgdGhlIHRhZyBhc3NpZ25lZFxudG8gdGhlIG5vZGUgc2hvdWxkIGFsc28gYXBwbHkgdG8gYWxsIGNoaWxkIG5vZGVzLCBldmVuIGlmIHRoZXlcbm1hdGNoIHRoZWlyIG93biBzdHlsZSAoYnkgZGVmYXVsdCwgb25seSB0aGUgaW5uZXJtb3N0IHN0eWxlIGlzXG51c2VkKS5cblxuV2hlbiBhIHBhdGggZW5kcyBpbiBgIWAsIGFzIGluIGBBdHRyaWJ1dGUhYCwgbm8gZnVydGhlciBtYXRjaGluZ1xuaGFwcGVucyBmb3IgdGhlIG5vZGUncyBjaGlsZCBub2RlcywgYW5kIHRoZSBlbnRpcmUgbm9kZSBnZXRzIHRoZVxuZ2l2ZW4gc3R5bGUuXG5cbkluIHRoaXMgbm90YXRpb24sIG5vZGUgbmFtZXMgdGhhdCBjb250YWluIGAvYCwgYCFgLCBgKmAsIG9yIGAuLi5gXG5tdXN0IGJlIHF1b3RlZCBhcyBKU09OIHN0cmluZ3MuXG5cbkZvciBleGFtcGxlOlxuXG5gYGBqYXZhc2NyaXB0XG5wYXJzZXIud2l0aFByb3BzKFxuICBzdHlsZVRhZ3Moe1xuICAgIC8vIFN0eWxlIE51bWJlciBhbmQgQmlnTnVtYmVyIG5vZGVzXG4gICAgXCJOdW1iZXIgQmlnTnVtYmVyXCI6IHRhZ3MubnVtYmVyLFxuICAgIC8vIFN0eWxlIEVzY2FwZSBub2RlcyB3aG9zZSBwYXJlbnQgaXMgU3RyaW5nXG4gICAgXCJTdHJpbmcvRXNjYXBlXCI6IHRhZ3MuZXNjYXBlLFxuICAgIC8vIFN0eWxlIGFueXRoaW5nIGluc2lkZSBBdHRyaWJ1dGVzIG5vZGVzXG4gICAgXCJBdHRyaWJ1dGVzIVwiOiB0YWdzLm1ldGEsXG4gICAgLy8gQWRkIGEgc3R5bGUgdG8gYWxsIGNvbnRlbnQgaW5zaWRlIEl0YWxpYyBub2Rlc1xuICAgIFwiSXRhbGljLy4uLlwiOiB0YWdzLmVtcGhhc2lzLFxuICAgIC8vIFN0eWxlIEludmFsaWRTdHJpbmcgbm9kZXMgYXMgYm90aCBgc3RyaW5nYCBhbmQgYGludmFsaWRgXG4gICAgXCJJbnZhbGlkU3RyaW5nXCI6IFt0YWdzLnN0cmluZywgdGFncy5pbnZhbGlkXSxcbiAgICAvLyBTdHlsZSB0aGUgbm9kZSBuYW1lZCBcIi9cIiBhcyBwdW5jdHVhdGlvblxuICAgICdcIi9cIic6IHRhZ3MucHVuY3R1YXRpb25cbiAgfSlcbilcbmBgYFxuKi9cbmZ1bmN0aW9uIHN0eWxlVGFncyhzcGVjKSB7XG4gICAgbGV0IGJ5TmFtZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZm9yIChsZXQgcHJvcCBpbiBzcGVjKSB7XG4gICAgICAgIGxldCB0YWdzID0gc3BlY1twcm9wXTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHRhZ3MpKVxuICAgICAgICAgICAgdGFncyA9IFt0YWdzXTtcbiAgICAgICAgZm9yIChsZXQgcGFydCBvZiBwcm9wLnNwbGl0KFwiIFwiKSlcbiAgICAgICAgICAgIGlmIChwYXJ0KSB7XG4gICAgICAgICAgICAgICAgbGV0IHBpZWNlcyA9IFtdLCBtb2RlID0gMiAvKiBNb2RlLk5vcm1hbCAqLywgcmVzdCA9IHBhcnQ7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgcG9zID0gMDs7KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN0ID09IFwiLi4uXCIgJiYgcG9zID4gMCAmJiBwb3MgKyAzID09IHBhcnQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlID0gMSAvKiBNb2RlLkluaGVyaXQgKi87XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgbSA9IC9eXCIoPzpbXlwiXFxcXF18XFxcXC4pKj9cInxbXlxcLyFdKy8uZXhlYyhyZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIHBhdGg6IFwiICsgcGFydCk7XG4gICAgICAgICAgICAgICAgICAgIHBpZWNlcy5wdXNoKG1bMF0gPT0gXCIqXCIgPyBcIlwiIDogbVswXVswXSA9PSAnXCInID8gSlNPTi5wYXJzZShtWzBdKSA6IG1bMF0pO1xuICAgICAgICAgICAgICAgICAgICBwb3MgKz0gbVswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb3MgPT0gcGFydC5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgbGV0IG5leHQgPSBwYXJ0W3BvcysrXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvcyA9PSBwYXJ0Lmxlbmd0aCAmJiBuZXh0ID09IFwiIVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlID0gMCAvKiBNb2RlLk9wYXF1ZSAqLztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ICE9IFwiL1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbnZhbGlkIHBhdGg6IFwiICsgcGFydCk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3QgPSBwYXJ0LnNsaWNlKHBvcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBsYXN0ID0gcGllY2VzLmxlbmd0aCAtIDEsIGlubmVyID0gcGllY2VzW2xhc3RdO1xuICAgICAgICAgICAgICAgIGlmICghaW5uZXIpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiSW52YWxpZCBwYXRoOiBcIiArIHBhcnQpO1xuICAgICAgICAgICAgICAgIGxldCBydWxlID0gbmV3IFJ1bGUodGFncywgbW9kZSwgbGFzdCA+IDAgPyBwaWVjZXMuc2xpY2UoMCwgbGFzdCkgOiBudWxsKTtcbiAgICAgICAgICAgICAgICBieU5hbWVbaW5uZXJdID0gcnVsZS5zb3J0KGJ5TmFtZVtpbm5lcl0pO1xuICAgICAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcnVsZU5vZGVQcm9wLmFkZChieU5hbWUpO1xufVxuY29uc3QgcnVsZU5vZGVQcm9wID0gbmV3IE5vZGVQcm9wKCk7XG5jbGFzcyBSdWxlIHtcbiAgICBjb25zdHJ1Y3Rvcih0YWdzLCBtb2RlLCBjb250ZXh0LCBuZXh0KSB7XG4gICAgICAgIHRoaXMudGFncyA9IHRhZ3M7XG4gICAgICAgIHRoaXMubW9kZSA9IG1vZGU7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMubmV4dCA9IG5leHQ7XG4gICAgfVxuICAgIGdldCBvcGFxdWUoKSB7IHJldHVybiB0aGlzLm1vZGUgPT0gMCAvKiBNb2RlLk9wYXF1ZSAqLzsgfVxuICAgIGdldCBpbmhlcml0KCkgeyByZXR1cm4gdGhpcy5tb2RlID09IDEgLyogTW9kZS5Jbmhlcml0ICovOyB9XG4gICAgc29ydChvdGhlcikge1xuICAgICAgICBpZiAoIW90aGVyIHx8IG90aGVyLmRlcHRoIDwgdGhpcy5kZXB0aCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0ID0gb3RoZXI7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBvdGhlci5uZXh0ID0gdGhpcy5zb3J0KG90aGVyLm5leHQpO1xuICAgICAgICByZXR1cm4gb3RoZXI7XG4gICAgfVxuICAgIGdldCBkZXB0aCgpIHsgcmV0dXJuIHRoaXMuY29udGV4dCA/IHRoaXMuY29udGV4dC5sZW5ndGggOiAwOyB9XG59XG5SdWxlLmVtcHR5ID0gbmV3IFJ1bGUoW10sIDIgLyogTW9kZS5Ob3JtYWwgKi8sIG51bGwpO1xuLyoqXG5EZWZpbmUgYSBbaGlnaGxpZ2h0ZXJdKCNoaWdobGlnaHQuSGlnaGxpZ2h0ZXIpIGZyb20gYW4gYXJyYXkgb2ZcbnRhZy9jbGFzcyBwYWlycy4gQ2xhc3NlcyBhc3NvY2lhdGVkIHdpdGggbW9yZSBzcGVjaWZpYyB0YWdzIHdpbGxcbnRha2UgcHJlY2VkZW5jZS5cbiovXG5mdW5jdGlvbiB0YWdIaWdobGlnaHRlcih0YWdzLCBvcHRpb25zKSB7XG4gICAgbGV0IG1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgZm9yIChsZXQgc3R5bGUgb2YgdGFncykge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc3R5bGUudGFnKSlcbiAgICAgICAgICAgIG1hcFtzdHlsZS50YWcuaWRdID0gc3R5bGUuY2xhc3M7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGZvciAobGV0IHRhZyBvZiBzdHlsZS50YWcpXG4gICAgICAgICAgICAgICAgbWFwW3RhZy5pZF0gPSBzdHlsZS5jbGFzcztcbiAgICB9XG4gICAgbGV0IHsgc2NvcGUsIGFsbCA9IG51bGwgfSA9IG9wdGlvbnMgfHwge307XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3R5bGU6ICh0YWdzKSA9PiB7XG4gICAgICAgICAgICBsZXQgY2xzID0gYWxsO1xuICAgICAgICAgICAgZm9yIChsZXQgdGFnIG9mIHRhZ3MpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBzdWIgb2YgdGFnLnNldCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdGFnQ2xhc3MgPSBtYXBbc3ViLmlkXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhZ0NsYXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbHMgPSBjbHMgPyBjbHMgKyBcIiBcIiArIHRhZ0NsYXNzIDogdGFnQ2xhc3M7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjbHM7XG4gICAgICAgIH0sXG4gICAgICAgIHNjb3BlXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGhpZ2hsaWdodFRhZ3MoaGlnaGxpZ2h0ZXJzLCB0YWdzKSB7XG4gICAgbGV0IHJlc3VsdCA9IG51bGw7XG4gICAgZm9yIChsZXQgaGlnaGxpZ2h0ZXIgb2YgaGlnaGxpZ2h0ZXJzKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IGhpZ2hsaWdodGVyLnN0eWxlKHRhZ3MpO1xuICAgICAgICBpZiAodmFsdWUpXG4gICAgICAgICAgICByZXN1bHQgPSByZXN1bHQgPyByZXN1bHQgKyBcIiBcIiArIHZhbHVlIDogdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbkhpZ2hsaWdodCB0aGUgZ2l2ZW4gW3RyZWVdKCNjb21tb24uVHJlZSkgd2l0aCB0aGUgZ2l2ZW5cbltoaWdobGlnaHRlcl0oI2hpZ2hsaWdodC5IaWdobGlnaHRlcikuIE9mdGVuLCB0aGUgaGlnaGVyLWxldmVsXG5bYGhpZ2hsaWdodENvZGVgXSgjaGlnaGxpZ2h0LmhpZ2hsaWdodENvZGUpIGZ1bmN0aW9uIGlzIGVhc2llciB0b1xudXNlLlxuKi9cbmZ1bmN0aW9uIGhpZ2hsaWdodFRyZWUodHJlZSwgaGlnaGxpZ2h0ZXIsIFxuLyoqXG5Bc3NpZ24gc3R5bGluZyB0byBhIHJlZ2lvbiBvZiB0aGUgdGV4dC4gV2lsbCBiZSBjYWxsZWQsIGluIG9yZGVyXG5vZiBwb3NpdGlvbiwgZm9yIGFueSByYW5nZXMgd2hlcmUgbW9yZSB0aGFuIHplcm8gY2xhc3NlcyBhcHBseS5cbmBjbGFzc2VzYCBpcyBhIHNwYWNlIHNlcGFyYXRlZCBzdHJpbmcgb2YgQ1NTIGNsYXNzZXMuXG4qL1xucHV0U3R5bGUsIFxuLyoqXG5UaGUgc3RhcnQgb2YgdGhlIHJhbmdlIHRvIGhpZ2hsaWdodC5cbiovXG5mcm9tID0gMCwgXG4vKipcblRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuKi9cbnRvID0gdHJlZS5sZW5ndGgpIHtcbiAgICBsZXQgYnVpbGRlciA9IG5ldyBIaWdobGlnaHRCdWlsZGVyKGZyb20sIEFycmF5LmlzQXJyYXkoaGlnaGxpZ2h0ZXIpID8gaGlnaGxpZ2h0ZXIgOiBbaGlnaGxpZ2h0ZXJdLCBwdXRTdHlsZSk7XG4gICAgYnVpbGRlci5oaWdobGlnaHRSYW5nZSh0cmVlLmN1cnNvcigpLCBmcm9tLCB0bywgXCJcIiwgYnVpbGRlci5oaWdobGlnaHRlcnMpO1xuICAgIGJ1aWxkZXIuZmx1c2godG8pO1xufVxuLyoqXG5IaWdobGlnaHQgdGhlIGdpdmVuIHRyZWUgd2l0aCB0aGUgZ2l2ZW4gaGlnaGxpZ2h0ZXIsIGNhbGxpbmdcbmBwdXRUZXh0YCBmb3IgZXZlcnkgcGllY2Ugb2YgdGV4dCwgZWl0aGVyIHdpdGggYSBzZXQgb2YgY2xhc3NlcyBvclxud2l0aCB0aGUgZW1wdHkgc3RyaW5nIHdoZW4gdW5zdHlsZWQsIGFuZCBgcHV0QnJlYWtgIGZvciBldmVyeSBsaW5lXG5icmVhay5cbiovXG5mdW5jdGlvbiBoaWdobGlnaHRDb2RlKGNvZGUsIHRyZWUsIGhpZ2hsaWdodGVyLCBwdXRUZXh0LCBwdXRCcmVhaywgZnJvbSA9IDAsIHRvID0gY29kZS5sZW5ndGgpIHtcbiAgICBsZXQgcG9zID0gZnJvbTtcbiAgICBmdW5jdGlvbiB3cml0ZVRvKHAsIGNsYXNzZXMpIHtcbiAgICAgICAgaWYgKHAgPD0gcG9zKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBmb3IgKGxldCB0ZXh0ID0gY29kZS5zbGljZShwb3MsIHApLCBpID0gMDs7KSB7XG4gICAgICAgICAgICBsZXQgbmV4dEJyZWFrID0gdGV4dC5pbmRleE9mKFwiXFxuXCIsIGkpO1xuICAgICAgICAgICAgbGV0IHVwdG8gPSBuZXh0QnJlYWsgPCAwID8gdGV4dC5sZW5ndGggOiBuZXh0QnJlYWs7XG4gICAgICAgICAgICBpZiAodXB0byA+IGkpXG4gICAgICAgICAgICAgICAgcHV0VGV4dCh0ZXh0LnNsaWNlKGksIHVwdG8pLCBjbGFzc2VzKTtcbiAgICAgICAgICAgIGlmIChuZXh0QnJlYWsgPCAwKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgcHV0QnJlYWsoKTtcbiAgICAgICAgICAgIGkgPSBuZXh0QnJlYWsgKyAxO1xuICAgICAgICB9XG4gICAgICAgIHBvcyA9IHA7XG4gICAgfVxuICAgIGhpZ2hsaWdodFRyZWUodHJlZSwgaGlnaGxpZ2h0ZXIsIChmcm9tLCB0bywgY2xhc3NlcykgPT4ge1xuICAgICAgICB3cml0ZVRvKGZyb20sIFwiXCIpO1xuICAgICAgICB3cml0ZVRvKHRvLCBjbGFzc2VzKTtcbiAgICB9LCBmcm9tLCB0byk7XG4gICAgd3JpdGVUbyh0bywgXCJcIik7XG59XG5jbGFzcyBIaWdobGlnaHRCdWlsZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihhdCwgaGlnaGxpZ2h0ZXJzLCBzcGFuKSB7XG4gICAgICAgIHRoaXMuYXQgPSBhdDtcbiAgICAgICAgdGhpcy5oaWdobGlnaHRlcnMgPSBoaWdobGlnaHRlcnM7XG4gICAgICAgIHRoaXMuc3BhbiA9IHNwYW47XG4gICAgICAgIHRoaXMuY2xhc3MgPSBcIlwiO1xuICAgIH1cbiAgICBzdGFydFNwYW4oYXQsIGNscykge1xuICAgICAgICBpZiAoY2xzICE9IHRoaXMuY2xhc3MpIHtcbiAgICAgICAgICAgIHRoaXMuZmx1c2goYXQpO1xuICAgICAgICAgICAgaWYgKGF0ID4gdGhpcy5hdClcbiAgICAgICAgICAgICAgICB0aGlzLmF0ID0gYXQ7XG4gICAgICAgICAgICB0aGlzLmNsYXNzID0gY2xzO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZsdXNoKHRvKSB7XG4gICAgICAgIGlmICh0byA+IHRoaXMuYXQgJiYgdGhpcy5jbGFzcylcbiAgICAgICAgICAgIHRoaXMuc3Bhbih0aGlzLmF0LCB0bywgdGhpcy5jbGFzcyk7XG4gICAgfVxuICAgIGhpZ2hsaWdodFJhbmdlKGN1cnNvciwgZnJvbSwgdG8sIGluaGVyaXRlZENsYXNzLCBoaWdobGlnaHRlcnMpIHtcbiAgICAgICAgbGV0IHsgdHlwZSwgZnJvbTogc3RhcnQsIHRvOiBlbmQgfSA9IGN1cnNvcjtcbiAgICAgICAgaWYgKHN0YXJ0ID49IHRvIHx8IGVuZCA8PSBmcm9tKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodHlwZS5pc1RvcClcbiAgICAgICAgICAgIGhpZ2hsaWdodGVycyA9IHRoaXMuaGlnaGxpZ2h0ZXJzLmZpbHRlcihoID0+ICFoLnNjb3BlIHx8IGguc2NvcGUodHlwZSkpO1xuICAgICAgICBsZXQgY2xzID0gaW5oZXJpdGVkQ2xhc3M7XG4gICAgICAgIGxldCBydWxlID0gZ2V0U3R5bGVUYWdzKGN1cnNvcikgfHwgUnVsZS5lbXB0eTtcbiAgICAgICAgbGV0IHRhZ0NscyA9IGhpZ2hsaWdodFRhZ3MoaGlnaGxpZ2h0ZXJzLCBydWxlLnRhZ3MpO1xuICAgICAgICBpZiAodGFnQ2xzKSB7XG4gICAgICAgICAgICBpZiAoY2xzKVxuICAgICAgICAgICAgICAgIGNscyArPSBcIiBcIjtcbiAgICAgICAgICAgIGNscyArPSB0YWdDbHM7XG4gICAgICAgICAgICBpZiAocnVsZS5tb2RlID09IDEgLyogTW9kZS5Jbmhlcml0ICovKVxuICAgICAgICAgICAgICAgIGluaGVyaXRlZENsYXNzICs9IChpbmhlcml0ZWRDbGFzcyA/IFwiIFwiIDogXCJcIikgKyB0YWdDbHM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdGFydFNwYW4oTWF0aC5tYXgoZnJvbSwgc3RhcnQpLCBjbHMpO1xuICAgICAgICBpZiAocnVsZS5vcGFxdWUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxldCBtb3VudGVkID0gY3Vyc29yLnRyZWUgJiYgY3Vyc29yLnRyZWUucHJvcChOb2RlUHJvcC5tb3VudGVkKTtcbiAgICAgICAgaWYgKG1vdW50ZWQgJiYgbW91bnRlZC5vdmVybGF5KSB7XG4gICAgICAgICAgICBsZXQgaW5uZXIgPSBjdXJzb3Iubm9kZS5lbnRlcihtb3VudGVkLm92ZXJsYXlbMF0uZnJvbSArIHN0YXJ0LCAxKTtcbiAgICAgICAgICAgIGxldCBpbm5lckhpZ2hsaWdodGVycyA9IHRoaXMuaGlnaGxpZ2h0ZXJzLmZpbHRlcihoID0+ICFoLnNjb3BlIHx8IGguc2NvcGUobW91bnRlZC50cmVlLnR5cGUpKTtcbiAgICAgICAgICAgIGxldCBoYXNDaGlsZCA9IGN1cnNvci5maXJzdENoaWxkKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMCwgcG9zID0gc3RhcnQ7OyBpKyspIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dCA9IGkgPCBtb3VudGVkLm92ZXJsYXkubGVuZ3RoID8gbW91bnRlZC5vdmVybGF5W2ldIDogbnVsbDtcbiAgICAgICAgICAgICAgICBsZXQgbmV4dFBvcyA9IG5leHQgPyBuZXh0LmZyb20gKyBzdGFydCA6IGVuZDtcbiAgICAgICAgICAgICAgICBsZXQgcmFuZ2VGcm9tID0gTWF0aC5tYXgoZnJvbSwgcG9zKSwgcmFuZ2VUbyA9IE1hdGgubWluKHRvLCBuZXh0UG9zKTtcbiAgICAgICAgICAgICAgICBpZiAocmFuZ2VGcm9tIDwgcmFuZ2VUbyAmJiBoYXNDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY3Vyc29yLmZyb20gPCByYW5nZVRvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZ2hsaWdodFJhbmdlKGN1cnNvciwgcmFuZ2VGcm9tLCByYW5nZVRvLCBpbmhlcml0ZWRDbGFzcywgaGlnaGxpZ2h0ZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRTcGFuKE1hdGgubWluKHJhbmdlVG8sIGN1cnNvci50byksIGNscyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3Vyc29yLnRvID49IG5leHRQb3MgfHwgIWN1cnNvci5uZXh0U2libGluZygpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghbmV4dCB8fCBuZXh0UG9zID4gdG8pXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIHBvcyA9IG5leHQudG8gKyBzdGFydDtcbiAgICAgICAgICAgICAgICBpZiAocG9zID4gZnJvbSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZ2hsaWdodFJhbmdlKGlubmVyLmN1cnNvcigpLCBNYXRoLm1heChmcm9tLCBuZXh0LmZyb20gKyBzdGFydCksIE1hdGgubWluKHRvLCBwb3MpLCBcIlwiLCBpbm5lckhpZ2hsaWdodGVycyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRTcGFuKE1hdGgubWluKHRvLCBwb3MpLCBjbHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNDaGlsZClcbiAgICAgICAgICAgICAgICBjdXJzb3IucGFyZW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3Vyc29yLmZpcnN0Q2hpbGQoKSkge1xuICAgICAgICAgICAgaWYgKG1vdW50ZWQpXG4gICAgICAgICAgICAgICAgaW5oZXJpdGVkQ2xhc3MgPSBcIlwiO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGlmIChjdXJzb3IudG8gPD0gZnJvbSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnNvci5mcm9tID49IHRvKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB0aGlzLmhpZ2hsaWdodFJhbmdlKGN1cnNvciwgZnJvbSwgdG8sIGluaGVyaXRlZENsYXNzLCBoaWdobGlnaHRlcnMpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRTcGFuKE1hdGgubWluKHRvLCBjdXJzb3IudG8pLCBjbHMpO1xuICAgICAgICAgICAgfSB3aGlsZSAoY3Vyc29yLm5leHRTaWJsaW5nKCkpO1xuICAgICAgICAgICAgY3Vyc29yLnBhcmVudCgpO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG5NYXRjaCBhIHN5bnRheCBub2RlJ3MgW2hpZ2hsaWdodCBydWxlc10oI2hpZ2hsaWdodC5zdHlsZVRhZ3MpLiBJZlxudGhlcmUncyBhIG1hdGNoLCByZXR1cm4gaXRzIHNldCBvZiB0YWdzLCBhbmQgd2hldGhlciBpdCBpc1xub3BhcXVlICh1c2VzIGEgYCFgKSBvciBhcHBsaWVzIHRvIGFsbCBjaGlsZCBub2RlcyAoYC8uLi5gKS5cbiovXG5mdW5jdGlvbiBnZXRTdHlsZVRhZ3Mobm9kZSkge1xuICAgIGxldCBydWxlID0gbm9kZS50eXBlLnByb3AocnVsZU5vZGVQcm9wKTtcbiAgICB3aGlsZSAocnVsZSAmJiBydWxlLmNvbnRleHQgJiYgIW5vZGUubWF0Y2hDb250ZXh0KHJ1bGUuY29udGV4dCkpXG4gICAgICAgIHJ1bGUgPSBydWxlLm5leHQ7XG4gICAgcmV0dXJuIHJ1bGUgfHwgbnVsbDtcbn1cbmNvbnN0IHQgPSBUYWcuZGVmaW5lO1xuY29uc3QgY29tbWVudCA9IHQoKSwgbmFtZSA9IHQoKSwgdHlwZU5hbWUgPSB0KG5hbWUpLCBwcm9wZXJ0eU5hbWUgPSB0KG5hbWUpLCBsaXRlcmFsID0gdCgpLCBzdHJpbmcgPSB0KGxpdGVyYWwpLCBudW1iZXIgPSB0KGxpdGVyYWwpLCBjb250ZW50ID0gdCgpLCBoZWFkaW5nID0gdChjb250ZW50KSwga2V5d29yZCA9IHQoKSwgb3BlcmF0b3IgPSB0KCksIHB1bmN0dWF0aW9uID0gdCgpLCBicmFja2V0ID0gdChwdW5jdHVhdGlvbiksIG1ldGEgPSB0KCk7XG4vKipcblRoZSBkZWZhdWx0IHNldCBvZiBoaWdobGlnaHRpbmcgW3RhZ3NdKCNoaWdobGlnaHQuVGFnKS5cblxuVGhpcyBjb2xsZWN0aW9uIGlzIGhlYXZpbHkgYmlhc2VkIHRvd2FyZHMgcHJvZ3JhbW1pbmcgbGFuZ3VhZ2VzLFxuYW5kIG5lY2Vzc2FyaWx5IGluY29tcGxldGUuIEEgZnVsbCBvbnRvbG9neSBvZiBzeW50YWN0aWNcbmNvbnN0cnVjdHMgd291bGQgZmlsbCBhIHN0YWNrIG9mIGJvb2tzLCBhbmQgYmUgaW1wcmFjdGljYWwgdG9cbndyaXRlIHRoZW1lcyBmb3IuIFNvIHRyeSB0byBtYWtlIGRvIHdpdGggdGhpcyBzZXQuIElmIGFsbCBlbHNlXG5mYWlscywgW29wZW4gYW5cbmlzc3VlXShodHRwczovL2dpdGh1Yi5jb20vY29kZW1pcnJvci9jb2RlbWlycm9yLm5leHQpIHRvIHByb3Bvc2UgYVxubmV3IHRhZywgb3IgW2RlZmluZV0oI2hpZ2hsaWdodC5UYWdeZGVmaW5lKSBhIGxvY2FsIGN1c3RvbSB0YWcgZm9yXG55b3VyIHVzZSBjYXNlLlxuXG5Ob3RlIHRoYXQgaXQgaXMgbm90IG9ibGlnYXRvcnkgdG8gYWx3YXlzIGF0dGFjaCB0aGUgbW9zdCBzcGVjaWZpY1xudGFnIHBvc3NpYmxlIHRvIGFuIGVsZW1lbnTigJRpZiB5b3VyIGdyYW1tYXIgY2FuJ3QgZWFzaWx5XG5kaXN0aW5ndWlzaCBhIGNlcnRhaW4gdHlwZSBvZiBlbGVtZW50IChzdWNoIGFzIGEgbG9jYWwgdmFyaWFibGUpLFxuaXQgaXMgb2theSB0byBzdHlsZSBpdCBhcyBpdHMgbW9yZSBnZW5lcmFsIHZhcmlhbnQgKGEgdmFyaWFibGUpLlxuXG5Gb3IgdGFncyB0aGF0IGV4dGVuZCBzb21lIHBhcmVudCB0YWcsIHRoZSBkb2N1bWVudGF0aW9uIGxpbmtzIHRvXG50aGUgcGFyZW50LlxuKi9cbmNvbnN0IHRhZ3MgPSB7XG4gICAgLyoqXG4gICAgQSBjb21tZW50LlxuICAgICovXG4gICAgY29tbWVudCxcbiAgICAvKipcbiAgICBBIGxpbmUgW2NvbW1lbnRdKCNoaWdobGlnaHQudGFncy5jb21tZW50KS5cbiAgICAqL1xuICAgIGxpbmVDb21tZW50OiB0KGNvbW1lbnQpLFxuICAgIC8qKlxuICAgIEEgYmxvY2sgW2NvbW1lbnRdKCNoaWdobGlnaHQudGFncy5jb21tZW50KS5cbiAgICAqL1xuICAgIGJsb2NrQ29tbWVudDogdChjb21tZW50KSxcbiAgICAvKipcbiAgICBBIGRvY3VtZW50YXRpb24gW2NvbW1lbnRdKCNoaWdobGlnaHQudGFncy5jb21tZW50KS5cbiAgICAqL1xuICAgIGRvY0NvbW1lbnQ6IHQoY29tbWVudCksXG4gICAgLyoqXG4gICAgQW55IGtpbmQgb2YgaWRlbnRpZmllci5cbiAgICAqL1xuICAgIG5hbWUsXG4gICAgLyoqXG4gICAgVGhlIFtuYW1lXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZSkgb2YgYSB2YXJpYWJsZS5cbiAgICAqL1xuICAgIHZhcmlhYmxlTmFtZTogdChuYW1lKSxcbiAgICAvKipcbiAgICBBIHR5cGUgW25hbWVdKCNoaWdobGlnaHQudGFncy5uYW1lKS5cbiAgICAqL1xuICAgIHR5cGVOYW1lOiB0eXBlTmFtZSxcbiAgICAvKipcbiAgICBBIHRhZyBuYW1lIChzdWJ0YWcgb2YgW2B0eXBlTmFtZWBdKCNoaWdobGlnaHQudGFncy50eXBlTmFtZSkpLlxuICAgICovXG4gICAgdGFnTmFtZTogdCh0eXBlTmFtZSksXG4gICAgLyoqXG4gICAgQSBwcm9wZXJ0eSBvciBmaWVsZCBbbmFtZV0oI2hpZ2hsaWdodC50YWdzLm5hbWUpLlxuICAgICovXG4gICAgcHJvcGVydHlOYW1lOiBwcm9wZXJ0eU5hbWUsXG4gICAgLyoqXG4gICAgQW4gYXR0cmlidXRlIG5hbWUgKHN1YnRhZyBvZiBbYHByb3BlcnR5TmFtZWBdKCNoaWdobGlnaHQudGFncy5wcm9wZXJ0eU5hbWUpKS5cbiAgICAqL1xuICAgIGF0dHJpYnV0ZU5hbWU6IHQocHJvcGVydHlOYW1lKSxcbiAgICAvKipcbiAgICBUaGUgW25hbWVdKCNoaWdobGlnaHQudGFncy5uYW1lKSBvZiBhIGNsYXNzLlxuICAgICovXG4gICAgY2xhc3NOYW1lOiB0KG5hbWUpLFxuICAgIC8qKlxuICAgIEEgbGFiZWwgW25hbWVdKCNoaWdobGlnaHQudGFncy5uYW1lKS5cbiAgICAqL1xuICAgIGxhYmVsTmFtZTogdChuYW1lKSxcbiAgICAvKipcbiAgICBBIG5hbWVzcGFjZSBbbmFtZV0oI2hpZ2hsaWdodC50YWdzLm5hbWUpLlxuICAgICovXG4gICAgbmFtZXNwYWNlOiB0KG5hbWUpLFxuICAgIC8qKlxuICAgIFRoZSBbbmFtZV0oI2hpZ2hsaWdodC50YWdzLm5hbWUpIG9mIGEgbWFjcm8uXG4gICAgKi9cbiAgICBtYWNyb05hbWU6IHQobmFtZSksXG4gICAgLyoqXG4gICAgQSBsaXRlcmFsIHZhbHVlLlxuICAgICovXG4gICAgbGl0ZXJhbCxcbiAgICAvKipcbiAgICBBIHN0cmluZyBbbGl0ZXJhbF0oI2hpZ2hsaWdodC50YWdzLmxpdGVyYWwpLlxuICAgICovXG4gICAgc3RyaW5nLFxuICAgIC8qKlxuICAgIEEgZG9jdW1lbnRhdGlvbiBbc3RyaW5nXSgjaGlnaGxpZ2h0LnRhZ3Muc3RyaW5nKS5cbiAgICAqL1xuICAgIGRvY1N0cmluZzogdChzdHJpbmcpLFxuICAgIC8qKlxuICAgIEEgY2hhcmFjdGVyIGxpdGVyYWwgKHN1YnRhZyBvZiBbc3RyaW5nXSgjaGlnaGxpZ2h0LnRhZ3Muc3RyaW5nKSkuXG4gICAgKi9cbiAgICBjaGFyYWN0ZXI6IHQoc3RyaW5nKSxcbiAgICAvKipcbiAgICBBbiBhdHRyaWJ1dGUgdmFsdWUgKHN1YnRhZyBvZiBbc3RyaW5nXSgjaGlnaGxpZ2h0LnRhZ3Muc3RyaW5nKSkuXG4gICAgKi9cbiAgICBhdHRyaWJ1dGVWYWx1ZTogdChzdHJpbmcpLFxuICAgIC8qKlxuICAgIEEgbnVtYmVyIFtsaXRlcmFsXSgjaGlnaGxpZ2h0LnRhZ3MubGl0ZXJhbCkuXG4gICAgKi9cbiAgICBudW1iZXIsXG4gICAgLyoqXG4gICAgQW4gaW50ZWdlciBbbnVtYmVyXSgjaGlnaGxpZ2h0LnRhZ3MubnVtYmVyKSBsaXRlcmFsLlxuICAgICovXG4gICAgaW50ZWdlcjogdChudW1iZXIpLFxuICAgIC8qKlxuICAgIEEgZmxvYXRpbmctcG9pbnQgW251bWJlcl0oI2hpZ2hsaWdodC50YWdzLm51bWJlcikgbGl0ZXJhbC5cbiAgICAqL1xuICAgIGZsb2F0OiB0KG51bWJlciksXG4gICAgLyoqXG4gICAgQSBib29sZWFuIFtsaXRlcmFsXSgjaGlnaGxpZ2h0LnRhZ3MubGl0ZXJhbCkuXG4gICAgKi9cbiAgICBib29sOiB0KGxpdGVyYWwpLFxuICAgIC8qKlxuICAgIFJlZ3VsYXIgZXhwcmVzc2lvbiBbbGl0ZXJhbF0oI2hpZ2hsaWdodC50YWdzLmxpdGVyYWwpLlxuICAgICovXG4gICAgcmVnZXhwOiB0KGxpdGVyYWwpLFxuICAgIC8qKlxuICAgIEFuIGVzY2FwZSBbbGl0ZXJhbF0oI2hpZ2hsaWdodC50YWdzLmxpdGVyYWwpLCBmb3IgZXhhbXBsZSBhXG4gICAgYmFja3NsYXNoIGVzY2FwZSBpbiBhIHN0cmluZy5cbiAgICAqL1xuICAgIGVzY2FwZTogdChsaXRlcmFsKSxcbiAgICAvKipcbiAgICBBIGNvbG9yIFtsaXRlcmFsXSgjaGlnaGxpZ2h0LnRhZ3MubGl0ZXJhbCkuXG4gICAgKi9cbiAgICBjb2xvcjogdChsaXRlcmFsKSxcbiAgICAvKipcbiAgICBBIFVSTCBbbGl0ZXJhbF0oI2hpZ2hsaWdodC50YWdzLmxpdGVyYWwpLlxuICAgICovXG4gICAgdXJsOiB0KGxpdGVyYWwpLFxuICAgIC8qKlxuICAgIEEgbGFuZ3VhZ2Uga2V5d29yZC5cbiAgICAqL1xuICAgIGtleXdvcmQsXG4gICAgLyoqXG4gICAgVGhlIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkgZm9yIHRoZSBzZWxmIG9yIHRoaXNcbiAgICBvYmplY3QuXG4gICAgKi9cbiAgICBzZWxmOiB0KGtleXdvcmQpLFxuICAgIC8qKlxuICAgIFRoZSBba2V5d29yZF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpIGZvciBudWxsLlxuICAgICovXG4gICAgbnVsbDogdChrZXl3b3JkKSxcbiAgICAvKipcbiAgICBBIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkgZGVub3Rpbmcgc29tZSBhdG9taWMgdmFsdWUuXG4gICAgKi9cbiAgICBhdG9tOiB0KGtleXdvcmQpLFxuICAgIC8qKlxuICAgIEEgW2tleXdvcmRdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKSB0aGF0IHJlcHJlc2VudHMgYSB1bml0LlxuICAgICovXG4gICAgdW5pdDogdChrZXl3b3JkKSxcbiAgICAvKipcbiAgICBBIG1vZGlmaWVyIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkuXG4gICAgKi9cbiAgICBtb2RpZmllcjogdChrZXl3b3JkKSxcbiAgICAvKipcbiAgICBBIFtrZXl3b3JkXSgjaGlnaGxpZ2h0LnRhZ3Mua2V5d29yZCkgdGhhdCBhY3RzIGFzIGFuIG9wZXJhdG9yLlxuICAgICovXG4gICAgb3BlcmF0b3JLZXl3b3JkOiB0KGtleXdvcmQpLFxuICAgIC8qKlxuICAgIEEgY29udHJvbC1mbG93IHJlbGF0ZWQgW2tleXdvcmRdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKS5cbiAgICAqL1xuICAgIGNvbnRyb2xLZXl3b3JkOiB0KGtleXdvcmQpLFxuICAgIC8qKlxuICAgIEEgW2tleXdvcmRdKCNoaWdobGlnaHQudGFncy5rZXl3b3JkKSB0aGF0IGRlZmluZXMgc29tZXRoaW5nLlxuICAgICovXG4gICAgZGVmaW5pdGlvbktleXdvcmQ6IHQoa2V5d29yZCksXG4gICAgLyoqXG4gICAgQSBba2V5d29yZF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpIHJlbGF0ZWQgdG8gZGVmaW5pbmcgb3JcbiAgICBpbnRlcmZhY2luZyB3aXRoIG1vZHVsZXMuXG4gICAgKi9cbiAgICBtb2R1bGVLZXl3b3JkOiB0KGtleXdvcmQpLFxuICAgIC8qKlxuICAgIEFuIG9wZXJhdG9yLlxuICAgICovXG4gICAgb3BlcmF0b3IsXG4gICAgLyoqXG4gICAgQW4gW29wZXJhdG9yXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpIHRoYXQgZGVyZWZlcmVuY2VzIHNvbWV0aGluZy5cbiAgICAqL1xuICAgIGRlcmVmT3BlcmF0b3I6IHQob3BlcmF0b3IpLFxuICAgIC8qKlxuICAgIEFyaXRobWV0aWMtcmVsYXRlZCBbb3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikuXG4gICAgKi9cbiAgICBhcml0aG1ldGljT3BlcmF0b3I6IHQob3BlcmF0b3IpLFxuICAgIC8qKlxuICAgIExvZ2ljYWwgW29wZXJhdG9yXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpLlxuICAgICovXG4gICAgbG9naWNPcGVyYXRvcjogdChvcGVyYXRvciksXG4gICAgLyoqXG4gICAgQml0IFtvcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKS5cbiAgICAqL1xuICAgIGJpdHdpc2VPcGVyYXRvcjogdChvcGVyYXRvciksXG4gICAgLyoqXG4gICAgQ29tcGFyaXNvbiBbb3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikuXG4gICAgKi9cbiAgICBjb21wYXJlT3BlcmF0b3I6IHQob3BlcmF0b3IpLFxuICAgIC8qKlxuICAgIFtPcGVyYXRvcl0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKSB0aGF0IHVwZGF0ZXMgaXRzIG9wZXJhbmQuXG4gICAgKi9cbiAgICB1cGRhdGVPcGVyYXRvcjogdChvcGVyYXRvciksXG4gICAgLyoqXG4gICAgW09wZXJhdG9yXSgjaGlnaGxpZ2h0LnRhZ3Mub3BlcmF0b3IpIHRoYXQgZGVmaW5lcyBzb21ldGhpbmcuXG4gICAgKi9cbiAgICBkZWZpbml0aW9uT3BlcmF0b3I6IHQob3BlcmF0b3IpLFxuICAgIC8qKlxuICAgIFR5cGUtcmVsYXRlZCBbb3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikuXG4gICAgKi9cbiAgICB0eXBlT3BlcmF0b3I6IHQob3BlcmF0b3IpLFxuICAgIC8qKlxuICAgIENvbnRyb2wtZmxvdyBbb3BlcmF0b3JdKCNoaWdobGlnaHQudGFncy5vcGVyYXRvcikuXG4gICAgKi9cbiAgICBjb250cm9sT3BlcmF0b3I6IHQob3BlcmF0b3IpLFxuICAgIC8qKlxuICAgIFByb2dyYW0gb3IgbWFya3VwIHB1bmN0dWF0aW9uLlxuICAgICovXG4gICAgcHVuY3R1YXRpb24sXG4gICAgLyoqXG4gICAgW1B1bmN0dWF0aW9uXSgjaGlnaGxpZ2h0LnRhZ3MucHVuY3R1YXRpb24pIHRoYXQgc2VwYXJhdGVzXG4gICAgdGhpbmdzLlxuICAgICovXG4gICAgc2VwYXJhdG9yOiB0KHB1bmN0dWF0aW9uKSxcbiAgICAvKipcbiAgICBCcmFja2V0LXN0eWxlIFtwdW5jdHVhdGlvbl0oI2hpZ2hsaWdodC50YWdzLnB1bmN0dWF0aW9uKS5cbiAgICAqL1xuICAgIGJyYWNrZXQsXG4gICAgLyoqXG4gICAgQW5nbGUgW2JyYWNrZXRzXSgjaGlnaGxpZ2h0LnRhZ3MuYnJhY2tldCkgKHVzdWFsbHkgYDxgIGFuZCBgPmBcbiAgICB0b2tlbnMpLlxuICAgICovXG4gICAgYW5nbGVCcmFja2V0OiB0KGJyYWNrZXQpLFxuICAgIC8qKlxuICAgIFNxdWFyZSBbYnJhY2tldHNdKCNoaWdobGlnaHQudGFncy5icmFja2V0KSAodXN1YWxseSBgW2AgYW5kIGBdYFxuICAgIHRva2VucykuXG4gICAgKi9cbiAgICBzcXVhcmVCcmFja2V0OiB0KGJyYWNrZXQpLFxuICAgIC8qKlxuICAgIFBhcmVudGhlc2VzICh1c3VhbGx5IGAoYCBhbmQgYClgIHRva2VucykuIFN1YnRhZyBvZlxuICAgIFticmFja2V0XSgjaGlnaGxpZ2h0LnRhZ3MuYnJhY2tldCkuXG4gICAgKi9cbiAgICBwYXJlbjogdChicmFja2V0KSxcbiAgICAvKipcbiAgICBCcmFjZXMgKHVzdWFsbHkgYHtgIGFuZCBgfWAgdG9rZW5zKS4gU3VidGFnIG9mXG4gICAgW2JyYWNrZXRdKCNoaWdobGlnaHQudGFncy5icmFja2V0KS5cbiAgICAqL1xuICAgIGJyYWNlOiB0KGJyYWNrZXQpLFxuICAgIC8qKlxuICAgIENvbnRlbnQsIGZvciBleGFtcGxlIHBsYWluIHRleHQgaW4gWE1MIG9yIG1hcmt1cCBkb2N1bWVudHMuXG4gICAgKi9cbiAgICBjb250ZW50LFxuICAgIC8qKlxuICAgIFtDb250ZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29udGVudCkgdGhhdCByZXByZXNlbnRzIGEgaGVhZGluZy5cbiAgICAqL1xuICAgIGhlYWRpbmcsXG4gICAgLyoqXG4gICAgQSBsZXZlbCAxIFtoZWFkaW5nXSgjaGlnaGxpZ2h0LnRhZ3MuaGVhZGluZykuXG4gICAgKi9cbiAgICBoZWFkaW5nMTogdChoZWFkaW5nKSxcbiAgICAvKipcbiAgICBBIGxldmVsIDIgW2hlYWRpbmddKCNoaWdobGlnaHQudGFncy5oZWFkaW5nKS5cbiAgICAqL1xuICAgIGhlYWRpbmcyOiB0KGhlYWRpbmcpLFxuICAgIC8qKlxuICAgIEEgbGV2ZWwgMyBbaGVhZGluZ10oI2hpZ2hsaWdodC50YWdzLmhlYWRpbmcpLlxuICAgICovXG4gICAgaGVhZGluZzM6IHQoaGVhZGluZyksXG4gICAgLyoqXG4gICAgQSBsZXZlbCA0IFtoZWFkaW5nXSgjaGlnaGxpZ2h0LnRhZ3MuaGVhZGluZykuXG4gICAgKi9cbiAgICBoZWFkaW5nNDogdChoZWFkaW5nKSxcbiAgICAvKipcbiAgICBBIGxldmVsIDUgW2hlYWRpbmddKCNoaWdobGlnaHQudGFncy5oZWFkaW5nKS5cbiAgICAqL1xuICAgIGhlYWRpbmc1OiB0KGhlYWRpbmcpLFxuICAgIC8qKlxuICAgIEEgbGV2ZWwgNiBbaGVhZGluZ10oI2hpZ2hsaWdodC50YWdzLmhlYWRpbmcpLlxuICAgICovXG4gICAgaGVhZGluZzY6IHQoaGVhZGluZyksXG4gICAgLyoqXG4gICAgQSBwcm9zZSBzZXBhcmF0b3IgKHN1Y2ggYXMgYSBob3Jpem9udGFsIHJ1bGUpLlxuICAgICovXG4gICAgY29udGVudFNlcGFyYXRvcjogdChjb250ZW50KSxcbiAgICAvKipcbiAgICBbQ29udGVudF0oI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHRoYXQgcmVwcmVzZW50cyBhIGxpc3QuXG4gICAgKi9cbiAgICBsaXN0OiB0KGNvbnRlbnQpLFxuICAgIC8qKlxuICAgIFtDb250ZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29udGVudCkgdGhhdCByZXByZXNlbnRzIGEgcXVvdGUuXG4gICAgKi9cbiAgICBxdW90ZTogdChjb250ZW50KSxcbiAgICAvKipcbiAgICBbQ29udGVudF0oI2hpZ2hsaWdodC50YWdzLmNvbnRlbnQpIHRoYXQgaXMgZW1waGFzaXplZC5cbiAgICAqL1xuICAgIGVtcGhhc2lzOiB0KGNvbnRlbnQpLFxuICAgIC8qKlxuICAgIFtDb250ZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29udGVudCkgdGhhdCBpcyBzdHlsZWQgc3Ryb25nLlxuICAgICovXG4gICAgc3Ryb25nOiB0KGNvbnRlbnQpLFxuICAgIC8qKlxuICAgIFtDb250ZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29udGVudCkgdGhhdCBpcyBwYXJ0IG9mIGEgbGluay5cbiAgICAqL1xuICAgIGxpbms6IHQoY29udGVudCksXG4gICAgLyoqXG4gICAgW0NvbnRlbnRdKCNoaWdobGlnaHQudGFncy5jb250ZW50KSB0aGF0IGlzIHN0eWxlZCBhcyBjb2RlIG9yXG4gICAgbW9ub3NwYWNlLlxuICAgICovXG4gICAgbW9ub3NwYWNlOiB0KGNvbnRlbnQpLFxuICAgIC8qKlxuICAgIFtDb250ZW50XSgjaGlnaGxpZ2h0LnRhZ3MuY29udGVudCkgdGhhdCBoYXMgYSBzdHJpa2UtdGhyb3VnaFxuICAgIHN0eWxlLlxuICAgICovXG4gICAgc3RyaWtldGhyb3VnaDogdChjb250ZW50KSxcbiAgICAvKipcbiAgICBJbnNlcnRlZCB0ZXh0IGluIGEgY2hhbmdlLXRyYWNraW5nIGZvcm1hdC5cbiAgICAqL1xuICAgIGluc2VydGVkOiB0KCksXG4gICAgLyoqXG4gICAgRGVsZXRlZCB0ZXh0LlxuICAgICovXG4gICAgZGVsZXRlZDogdCgpLFxuICAgIC8qKlxuICAgIENoYW5nZWQgdGV4dC5cbiAgICAqL1xuICAgIGNoYW5nZWQ6IHQoKSxcbiAgICAvKipcbiAgICBBbiBpbnZhbGlkIG9yIHVuc3ludGFjdGljIGVsZW1lbnQuXG4gICAgKi9cbiAgICBpbnZhbGlkOiB0KCksXG4gICAgLyoqXG4gICAgTWV0YWRhdGEgb3IgbWV0YS1pbnN0cnVjdGlvbi5cbiAgICAqL1xuICAgIG1ldGEsXG4gICAgLyoqXG4gICAgW01ldGFkYXRhXSgjaGlnaGxpZ2h0LnRhZ3MubWV0YSkgdGhhdCBhcHBsaWVzIHRvIHRoZSBlbnRpcmVcbiAgICBkb2N1bWVudC5cbiAgICAqL1xuICAgIGRvY3VtZW50TWV0YTogdChtZXRhKSxcbiAgICAvKipcbiAgICBbTWV0YWRhdGFdKCNoaWdobGlnaHQudGFncy5tZXRhKSB0aGF0IGFubm90YXRlcyBvciBhZGRzXG4gICAgYXR0cmlidXRlcyB0byBhIGdpdmVuIHN5bnRhY3RpYyBlbGVtZW50LlxuICAgICovXG4gICAgYW5ub3RhdGlvbjogdChtZXRhKSxcbiAgICAvKipcbiAgICBQcm9jZXNzaW5nIGluc3RydWN0aW9uIG9yIHByZXByb2Nlc3NvciBkaXJlY3RpdmUuIFN1YnRhZyBvZlxuICAgIFttZXRhXSgjaGlnaGxpZ2h0LnRhZ3MubWV0YSkuXG4gICAgKi9cbiAgICBwcm9jZXNzaW5nSW5zdHJ1Y3Rpb246IHQobWV0YSksXG4gICAgLyoqXG4gICAgW01vZGlmaWVyXSgjaGlnaGxpZ2h0LlRhZ15kZWZpbmVNb2RpZmllcikgdGhhdCBpbmRpY2F0ZXMgdGhhdCBhXG4gICAgZ2l2ZW4gZWxlbWVudCBpcyBiZWluZyBkZWZpbmVkLiBFeHBlY3RlZCB0byBiZSB1c2VkIHdpdGggdGhlXG4gICAgdmFyaW91cyBbbmFtZV0oI2hpZ2hsaWdodC50YWdzLm5hbWUpIHRhZ3MuXG4gICAgKi9cbiAgICBkZWZpbml0aW9uOiBUYWcuZGVmaW5lTW9kaWZpZXIoKSxcbiAgICAvKipcbiAgICBbTW9kaWZpZXJdKCNoaWdobGlnaHQuVGFnXmRlZmluZU1vZGlmaWVyKSB0aGF0IGluZGljYXRlcyB0aGF0XG4gICAgc29tZXRoaW5nIGlzIGNvbnN0YW50LiBNb3N0bHkgZXhwZWN0ZWQgdG8gYmUgdXNlZCB3aXRoXG4gICAgW3ZhcmlhYmxlIG5hbWVzXSgjaGlnaGxpZ2h0LnRhZ3MudmFyaWFibGVOYW1lKS5cbiAgICAqL1xuICAgIGNvbnN0YW50OiBUYWcuZGVmaW5lTW9kaWZpZXIoKSxcbiAgICAvKipcbiAgICBbTW9kaWZpZXJdKCNoaWdobGlnaHQuVGFnXmRlZmluZU1vZGlmaWVyKSB1c2VkIHRvIGluZGljYXRlIHRoYXRcbiAgICBhIFt2YXJpYWJsZV0oI2hpZ2hsaWdodC50YWdzLnZhcmlhYmxlTmFtZSkgb3IgW3Byb3BlcnR5XG4gICAgbmFtZV0oI2hpZ2hsaWdodC50YWdzLnByb3BlcnR5TmFtZSkgaXMgYmVpbmcgY2FsbGVkIG9yIGRlZmluZWRcbiAgICBhcyBhIGZ1bmN0aW9uLlxuICAgICovXG4gICAgZnVuY3Rpb246IFRhZy5kZWZpbmVNb2RpZmllcigpLFxuICAgIC8qKlxuICAgIFtNb2RpZmllcl0oI2hpZ2hsaWdodC5UYWdeZGVmaW5lTW9kaWZpZXIpIHRoYXQgY2FuIGJlIGFwcGxpZWQgdG9cbiAgICBbbmFtZXNdKCNoaWdobGlnaHQudGFncy5uYW1lKSB0byBpbmRpY2F0ZSB0aGF0IHRoZXkgYmVsb25nIHRvXG4gICAgdGhlIGxhbmd1YWdlJ3Mgc3RhbmRhcmQgZW52aXJvbm1lbnQuXG4gICAgKi9cbiAgICBzdGFuZGFyZDogVGFnLmRlZmluZU1vZGlmaWVyKCksXG4gICAgLyoqXG4gICAgW01vZGlmaWVyXSgjaGlnaGxpZ2h0LlRhZ15kZWZpbmVNb2RpZmllcikgdGhhdCBpbmRpY2F0ZXMgYSBnaXZlblxuICAgIFtuYW1lc10oI2hpZ2hsaWdodC50YWdzLm5hbWUpIGlzIGxvY2FsIHRvIHNvbWUgc2NvcGUuXG4gICAgKi9cbiAgICBsb2NhbDogVGFnLmRlZmluZU1vZGlmaWVyKCksXG4gICAgLyoqXG4gICAgQSBnZW5lcmljIHZhcmlhbnQgW21vZGlmaWVyXSgjaGlnaGxpZ2h0LlRhZ15kZWZpbmVNb2RpZmllcikgdGhhdFxuICAgIGNhbiBiZSB1c2VkIHRvIHRhZyBsYW5ndWFnZS1zcGVjaWZpYyBhbHRlcm5hdGl2ZSB2YXJpYW50cyBvZlxuICAgIHNvbWUgY29tbW9uIHRhZy4gSXQgaXMgcmVjb21tZW5kZWQgZm9yIHRoZW1lcyB0byBkZWZpbmUgc3BlY2lhbFxuICAgIGZvcm1zIG9mIGF0IGxlYXN0IHRoZSBbc3RyaW5nXSgjaGlnaGxpZ2h0LnRhZ3Muc3RyaW5nKSBhbmRcbiAgICBbdmFyaWFibGUgbmFtZV0oI2hpZ2hsaWdodC50YWdzLnZhcmlhYmxlTmFtZSkgdGFncywgc2luY2UgdGhvc2VcbiAgICBjb21lIHVwIGEgbG90LlxuICAgICovXG4gICAgc3BlY2lhbDogVGFnLmRlZmluZU1vZGlmaWVyKClcbn07XG4vKipcblRoaXMgaXMgYSBoaWdobGlnaHRlciB0aGF0IGFkZHMgc3RhYmxlLCBwcmVkaWN0YWJsZSBjbGFzc2VzIHRvXG50b2tlbnMsIGZvciBzdHlsaW5nIHdpdGggZXh0ZXJuYWwgQ1NTLlxuXG5UaGUgZm9sbG93aW5nIHRhZ3MgYXJlIG1hcHBlZCB0byB0aGVpciBuYW1lIHByZWZpeGVkIHdpdGggYFwidG9rLVwiYFxuKGZvciBleGFtcGxlIGBcInRvay1jb21tZW50XCJgKTpcblxuKiBbYGxpbmtgXSgjaGlnaGxpZ2h0LnRhZ3MubGluaylcbiogW2BoZWFkaW5nYF0oI2hpZ2hsaWdodC50YWdzLmhlYWRpbmcpXG4qIFtgZW1waGFzaXNgXSgjaGlnaGxpZ2h0LnRhZ3MuZW1waGFzaXMpXG4qIFtgc3Ryb25nYF0oI2hpZ2hsaWdodC50YWdzLnN0cm9uZylcbiogW2BrZXl3b3JkYF0oI2hpZ2hsaWdodC50YWdzLmtleXdvcmQpXG4qIFtgYXRvbWBdKCNoaWdobGlnaHQudGFncy5hdG9tKVxuKiBbYGJvb2xgXSgjaGlnaGxpZ2h0LnRhZ3MuYm9vbClcbiogW2B1cmxgXSgjaGlnaGxpZ2h0LnRhZ3MudXJsKVxuKiBbYGxhYmVsTmFtZWBdKCNoaWdobGlnaHQudGFncy5sYWJlbE5hbWUpXG4qIFtgaW5zZXJ0ZWRgXSgjaGlnaGxpZ2h0LnRhZ3MuaW5zZXJ0ZWQpXG4qIFtgZGVsZXRlZGBdKCNoaWdobGlnaHQudGFncy5kZWxldGVkKVxuKiBbYGxpdGVyYWxgXSgjaGlnaGxpZ2h0LnRhZ3MubGl0ZXJhbClcbiogW2BzdHJpbmdgXSgjaGlnaGxpZ2h0LnRhZ3Muc3RyaW5nKVxuKiBbYG51bWJlcmBdKCNoaWdobGlnaHQudGFncy5udW1iZXIpXG4qIFtgdmFyaWFibGVOYW1lYF0oI2hpZ2hsaWdodC50YWdzLnZhcmlhYmxlTmFtZSlcbiogW2B0eXBlTmFtZWBdKCNoaWdobGlnaHQudGFncy50eXBlTmFtZSlcbiogW2BuYW1lc3BhY2VgXSgjaGlnaGxpZ2h0LnRhZ3MubmFtZXNwYWNlKVxuKiBbYGNsYXNzTmFtZWBdKCNoaWdobGlnaHQudGFncy5jbGFzc05hbWUpXG4qIFtgbWFjcm9OYW1lYF0oI2hpZ2hsaWdodC50YWdzLm1hY3JvTmFtZSlcbiogW2Bwcm9wZXJ0eU5hbWVgXSgjaGlnaGxpZ2h0LnRhZ3MucHJvcGVydHlOYW1lKVxuKiBbYG9wZXJhdG9yYF0oI2hpZ2hsaWdodC50YWdzLm9wZXJhdG9yKVxuKiBbYGNvbW1lbnRgXSgjaGlnaGxpZ2h0LnRhZ3MuY29tbWVudClcbiogW2BtZXRhYF0oI2hpZ2hsaWdodC50YWdzLm1ldGEpXG4qIFtgcHVuY3R1YXRpb25gXSgjaGlnaGxpZ2h0LnRhZ3MucHVuY3R1YXRpb24pXG4qIFtgaW52YWxpZGBdKCNoaWdobGlnaHQudGFncy5pbnZhbGlkKVxuXG5JbiBhZGRpdGlvbiwgdGhlc2UgbWFwcGluZ3MgYXJlIHByb3ZpZGVkOlxuXG4qIFtgcmVnZXhwYF0oI2hpZ2hsaWdodC50YWdzLnJlZ2V4cCksXG4gIFtgZXNjYXBlYF0oI2hpZ2hsaWdodC50YWdzLmVzY2FwZSksIGFuZFxuICBbYHNwZWNpYWxgXSgjaGlnaGxpZ2h0LnRhZ3Muc3BlY2lhbClbYChzdHJpbmcpYF0oI2hpZ2hsaWdodC50YWdzLnN0cmluZylcbiAgYXJlIG1hcHBlZCB0byBgXCJ0b2stc3RyaW5nMlwiYFxuKiBbYHNwZWNpYWxgXSgjaGlnaGxpZ2h0LnRhZ3Muc3BlY2lhbClbYCh2YXJpYWJsZU5hbWUpYF0oI2hpZ2hsaWdodC50YWdzLnZhcmlhYmxlTmFtZSlcbiAgdG8gYFwidG9rLXZhcmlhYmxlTmFtZTJcImBcbiogW2Bsb2NhbGBdKCNoaWdobGlnaHQudGFncy5sb2NhbClbYCh2YXJpYWJsZU5hbWUpYF0oI2hpZ2hsaWdodC50YWdzLnZhcmlhYmxlTmFtZSlcbiAgdG8gYFwidG9rLXZhcmlhYmxlTmFtZSB0b2stbG9jYWxcImBcbiogW2BkZWZpbml0aW9uYF0oI2hpZ2hsaWdodC50YWdzLmRlZmluaXRpb24pW2AodmFyaWFibGVOYW1lKWBdKCNoaWdobGlnaHQudGFncy52YXJpYWJsZU5hbWUpXG4gIHRvIGBcInRvay12YXJpYWJsZU5hbWUgdG9rLWRlZmluaXRpb25cImBcbiogW2BkZWZpbml0aW9uYF0oI2hpZ2hsaWdodC50YWdzLmRlZmluaXRpb24pW2AocHJvcGVydHlOYW1lKWBdKCNoaWdobGlnaHQudGFncy5wcm9wZXJ0eU5hbWUpXG4gIHRvIGBcInRvay1wcm9wZXJ0eU5hbWUgdG9rLWRlZmluaXRpb25cImBcbiovXG5jb25zdCBjbGFzc0hpZ2hsaWdodGVyID0gdGFnSGlnaGxpZ2h0ZXIoW1xuICAgIHsgdGFnOiB0YWdzLmxpbmssIGNsYXNzOiBcInRvay1saW5rXCIgfSxcbiAgICB7IHRhZzogdGFncy5oZWFkaW5nLCBjbGFzczogXCJ0b2staGVhZGluZ1wiIH0sXG4gICAgeyB0YWc6IHRhZ3MuZW1waGFzaXMsIGNsYXNzOiBcInRvay1lbXBoYXNpc1wiIH0sXG4gICAgeyB0YWc6IHRhZ3Muc3Ryb25nLCBjbGFzczogXCJ0b2stc3Ryb25nXCIgfSxcbiAgICB7IHRhZzogdGFncy5rZXl3b3JkLCBjbGFzczogXCJ0b2sta2V5d29yZFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuYXRvbSwgY2xhc3M6IFwidG9rLWF0b21cIiB9LFxuICAgIHsgdGFnOiB0YWdzLmJvb2wsIGNsYXNzOiBcInRvay1ib29sXCIgfSxcbiAgICB7IHRhZzogdGFncy51cmwsIGNsYXNzOiBcInRvay11cmxcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmxhYmVsTmFtZSwgY2xhc3M6IFwidG9rLWxhYmVsTmFtZVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuaW5zZXJ0ZWQsIGNsYXNzOiBcInRvay1pbnNlcnRlZFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MuZGVsZXRlZCwgY2xhc3M6IFwidG9rLWRlbGV0ZWRcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmxpdGVyYWwsIGNsYXNzOiBcInRvay1saXRlcmFsXCIgfSxcbiAgICB7IHRhZzogdGFncy5zdHJpbmcsIGNsYXNzOiBcInRvay1zdHJpbmdcIiB9LFxuICAgIHsgdGFnOiB0YWdzLm51bWJlciwgY2xhc3M6IFwidG9rLW51bWJlclwiIH0sXG4gICAgeyB0YWc6IFt0YWdzLnJlZ2V4cCwgdGFncy5lc2NhcGUsIHRhZ3Muc3BlY2lhbCh0YWdzLnN0cmluZyldLCBjbGFzczogXCJ0b2stc3RyaW5nMlwiIH0sXG4gICAgeyB0YWc6IHRhZ3MudmFyaWFibGVOYW1lLCBjbGFzczogXCJ0b2stdmFyaWFibGVOYW1lXCIgfSxcbiAgICB7IHRhZzogdGFncy5sb2NhbCh0YWdzLnZhcmlhYmxlTmFtZSksIGNsYXNzOiBcInRvay12YXJpYWJsZU5hbWUgdG9rLWxvY2FsXCIgfSxcbiAgICB7IHRhZzogdGFncy5kZWZpbml0aW9uKHRhZ3MudmFyaWFibGVOYW1lKSwgY2xhc3M6IFwidG9rLXZhcmlhYmxlTmFtZSB0b2stZGVmaW5pdGlvblwiIH0sXG4gICAgeyB0YWc6IHRhZ3Muc3BlY2lhbCh0YWdzLnZhcmlhYmxlTmFtZSksIGNsYXNzOiBcInRvay12YXJpYWJsZU5hbWUyXCIgfSxcbiAgICB7IHRhZzogdGFncy5kZWZpbml0aW9uKHRhZ3MucHJvcGVydHlOYW1lKSwgY2xhc3M6IFwidG9rLXByb3BlcnR5TmFtZSB0b2stZGVmaW5pdGlvblwiIH0sXG4gICAgeyB0YWc6IHRhZ3MudHlwZU5hbWUsIGNsYXNzOiBcInRvay10eXBlTmFtZVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MubmFtZXNwYWNlLCBjbGFzczogXCJ0b2stbmFtZXNwYWNlXCIgfSxcbiAgICB7IHRhZzogdGFncy5jbGFzc05hbWUsIGNsYXNzOiBcInRvay1jbGFzc05hbWVcIiB9LFxuICAgIHsgdGFnOiB0YWdzLm1hY3JvTmFtZSwgY2xhc3M6IFwidG9rLW1hY3JvTmFtZVwiIH0sXG4gICAgeyB0YWc6IHRhZ3MucHJvcGVydHlOYW1lLCBjbGFzczogXCJ0b2stcHJvcGVydHlOYW1lXCIgfSxcbiAgICB7IHRhZzogdGFncy5vcGVyYXRvciwgY2xhc3M6IFwidG9rLW9wZXJhdG9yXCIgfSxcbiAgICB7IHRhZzogdGFncy5jb21tZW50LCBjbGFzczogXCJ0b2stY29tbWVudFwiIH0sXG4gICAgeyB0YWc6IHRhZ3MubWV0YSwgY2xhc3M6IFwidG9rLW1ldGFcIiB9LFxuICAgIHsgdGFnOiB0YWdzLmludmFsaWQsIGNsYXNzOiBcInRvay1pbnZhbGlkXCIgfSxcbiAgICB7IHRhZzogdGFncy5wdW5jdHVhdGlvbiwgY2xhc3M6IFwidG9rLXB1bmN0dWF0aW9uXCIgfVxuXSk7XG5cbmV4cG9ydCB7IFRhZywgY2xhc3NIaWdobGlnaHRlciwgZ2V0U3R5bGVUYWdzLCBoaWdobGlnaHRDb2RlLCBoaWdobGlnaHRUcmVlLCBzdHlsZVRhZ3MsIHRhZ0hpZ2hsaWdodGVyLCB0YWdzIH07XG4iXSwibmFtZXMiOlsiTm9kZVByb3AiLCJuZXh0VGFnSUQiLCJUYWciLCJjb25zdHJ1Y3RvciIsInNldCIsImJhc2UiLCJtb2RpZmllZCIsImlkIiwiZGVmaW5lIiwicGFyZW50IiwiRXJyb3IiLCJ0YWciLCJwdXNoIiwidCIsImRlZmluZU1vZGlmaWVyIiwibW9kIiwiTW9kaWZpZXIiLCJpbmRleE9mIiwiZ2V0IiwiY29uY2F0Iiwic29ydCIsImEiLCJiIiwibmV4dE1vZGlmaWVySUQiLCJpbnN0YW5jZXMiLCJtb2RzIiwibGVuZ3RoIiwiZXhpc3RzIiwiZmluZCIsInNhbWVBcnJheSIsIm0iLCJjb25maWdzIiwicG93ZXJTZXQiLCJjb25maWciLCJldmVyeSIsIngiLCJpIiwiYXJyYXkiLCJzZXRzIiwiaiIsImUiLCJzdHlsZVRhZ3MiLCJzcGVjIiwiYnlOYW1lIiwiT2JqZWN0IiwiY3JlYXRlIiwicHJvcCIsInRhZ3MiLCJBcnJheSIsImlzQXJyYXkiLCJwYXJ0Iiwic3BsaXQiLCJwaWVjZXMiLCJtb2RlIiwicmVzdCIsInBvcyIsImV4ZWMiLCJSYW5nZUVycm9yIiwiSlNPTiIsInBhcnNlIiwibmV4dCIsInNsaWNlIiwibGFzdCIsImlubmVyIiwicnVsZSIsIlJ1bGUiLCJydWxlTm9kZVByb3AiLCJhZGQiLCJjb250ZXh0Iiwib3BhcXVlIiwiaW5oZXJpdCIsIm90aGVyIiwiZGVwdGgiLCJlbXB0eSIsInRhZ0hpZ2hsaWdodGVyIiwib3B0aW9ucyIsIm1hcCIsInN0eWxlIiwiY2xhc3MiLCJzY29wZSIsImFsbCIsImNscyIsInN1YiIsInRhZ0NsYXNzIiwiaGlnaGxpZ2h0VGFncyIsImhpZ2hsaWdodGVycyIsInJlc3VsdCIsImhpZ2hsaWdodGVyIiwidmFsdWUiLCJoaWdobGlnaHRUcmVlIiwidHJlZSIsInB1dFN0eWxlIiwiZnJvbSIsInRvIiwiYnVpbGRlciIsIkhpZ2hsaWdodEJ1aWxkZXIiLCJoaWdobGlnaHRSYW5nZSIsImN1cnNvciIsImZsdXNoIiwiaGlnaGxpZ2h0Q29kZSIsImNvZGUiLCJwdXRUZXh0IiwicHV0QnJlYWsiLCJ3cml0ZVRvIiwicCIsImNsYXNzZXMiLCJ0ZXh0IiwibmV4dEJyZWFrIiwidXB0byIsImF0Iiwic3BhbiIsInN0YXJ0U3BhbiIsImluaGVyaXRlZENsYXNzIiwidHlwZSIsInN0YXJ0IiwiZW5kIiwiaXNUb3AiLCJmaWx0ZXIiLCJoIiwiZ2V0U3R5bGVUYWdzIiwidGFnQ2xzIiwiTWF0aCIsIm1heCIsIm1vdW50ZWQiLCJvdmVybGF5Iiwibm9kZSIsImVudGVyIiwiaW5uZXJIaWdobGlnaHRlcnMiLCJoYXNDaGlsZCIsImZpcnN0Q2hpbGQiLCJuZXh0UG9zIiwicmFuZ2VGcm9tIiwicmFuZ2VUbyIsIm1pbiIsIm5leHRTaWJsaW5nIiwibWF0Y2hDb250ZXh0IiwiY29tbWVudCIsIm5hbWUiLCJ0eXBlTmFtZSIsInByb3BlcnR5TmFtZSIsImxpdGVyYWwiLCJzdHJpbmciLCJudW1iZXIiLCJjb250ZW50IiwiaGVhZGluZyIsImtleXdvcmQiLCJvcGVyYXRvciIsInB1bmN0dWF0aW9uIiwiYnJhY2tldCIsIm1ldGEiLCJsaW5lQ29tbWVudCIsImJsb2NrQ29tbWVudCIsImRvY0NvbW1lbnQiLCJ2YXJpYWJsZU5hbWUiLCJ0YWdOYW1lIiwiYXR0cmlidXRlTmFtZSIsImNsYXNzTmFtZSIsImxhYmVsTmFtZSIsIm5hbWVzcGFjZSIsIm1hY3JvTmFtZSIsImRvY1N0cmluZyIsImNoYXJhY3RlciIsImF0dHJpYnV0ZVZhbHVlIiwiaW50ZWdlciIsImZsb2F0IiwiYm9vbCIsInJlZ2V4cCIsImVzY2FwZSIsImNvbG9yIiwidXJsIiwic2VsZiIsIm51bGwiLCJhdG9tIiwidW5pdCIsIm1vZGlmaWVyIiwib3BlcmF0b3JLZXl3b3JkIiwiY29udHJvbEtleXdvcmQiLCJkZWZpbml0aW9uS2V5d29yZCIsIm1vZHVsZUtleXdvcmQiLCJkZXJlZk9wZXJhdG9yIiwiYXJpdGhtZXRpY09wZXJhdG9yIiwibG9naWNPcGVyYXRvciIsImJpdHdpc2VPcGVyYXRvciIsImNvbXBhcmVPcGVyYXRvciIsInVwZGF0ZU9wZXJhdG9yIiwiZGVmaW5pdGlvbk9wZXJhdG9yIiwidHlwZU9wZXJhdG9yIiwiY29udHJvbE9wZXJhdG9yIiwic2VwYXJhdG9yIiwiYW5nbGVCcmFja2V0Iiwic3F1YXJlQnJhY2tldCIsInBhcmVuIiwiYnJhY2UiLCJoZWFkaW5nMSIsImhlYWRpbmcyIiwiaGVhZGluZzMiLCJoZWFkaW5nNCIsImhlYWRpbmc1IiwiaGVhZGluZzYiLCJjb250ZW50U2VwYXJhdG9yIiwibGlzdCIsInF1b3RlIiwiZW1waGFzaXMiLCJzdHJvbmciLCJsaW5rIiwibW9ub3NwYWNlIiwic3RyaWtldGhyb3VnaCIsImluc2VydGVkIiwiZGVsZXRlZCIsImNoYW5nZWQiLCJpbnZhbGlkIiwiZG9jdW1lbnRNZXRhIiwiYW5ub3RhdGlvbiIsInByb2Nlc3NpbmdJbnN0cnVjdGlvbiIsImRlZmluaXRpb24iLCJjb25zdGFudCIsImZ1bmN0aW9uIiwic3RhbmRhcmQiLCJsb2NhbCIsInNwZWNpYWwiLCJjbGFzc0hpZ2hsaWdodGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/@lezer/highlight/dist/index.js\n");

/***/ })

}]);